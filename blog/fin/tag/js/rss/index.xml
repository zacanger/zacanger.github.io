<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[undefined - angr]]></title><description><![CDATA[writings from zac anger]]></description><link>http://blog.zacanger.com/</link><generator>Ghost</generator><lastBuildDate>Thu, 05 May 2016 22:25:08 GMT</lastBuildDate><atom:link href="http://blog.zacanger.com/tag/undefined/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[ideas for a better jsx]]></title><description><![CDATA[<p>please note: these aren&#39;t all my ideas, some are from <a href="http://ryanwalsh.io">ryan walsh</a></p>
<p>also, all of this was from back when both myself and ryan were just starting to learn react</p>
<p>i don&#39;t dislike jsx, i got over that</p>
<p>pretty sure ryan did, too</p>
<pre class="hljs"><code><span class="hljs-comment">// JSX</span>
export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileInfo</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {</span>
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div className=<span class="hljs-string">&quot;profile-info-container&quot;</span>&gt;

        &lt;div className=<span class="hljs-string">&quot;profile-image-wrapper&quot;</span>&gt;
          &lt;img className=<span class="hljs-string">&quot;profile-image&quot;</span> src=<span class="hljs-string">&quot;<a href="https://avatars1.githubusercontent.com/u/12636781?v=3&amp;s=460">https://avatars1.githubusercontent.com/u/12636781?v=3&amp;s=460</a>&quot;</span> /&gt;
        &lt;/div&gt;

        &lt;div className=<span class="hljs-string">&quot;name-info-container&quot;</span>&gt;
          &lt;h2 className=<span class="hljs-string">&quot;display-name&quot;</span>&gt;<span class="hljs-type">Ryan</span> <span class="hljs-type">Walsh</span>&lt;/h2&gt;
          &lt;h3 className=<span class="hljs-string">&quot;username&quot;</span>&gt;r-walsh&lt;/h3&gt;
        &lt;/div&gt;

        &lt;table className=<span class="hljs-string">&quot;profile-guide-info&quot;</span>&gt;
          &lt;tr className=<span class="hljs-string">&quot;number-container&quot;</span>&gt;
            &lt;th className=<span class="hljs-string">&quot;guide-info-number&quot;</span>&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-authored&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;<span class="hljs-number">12</span>&lt;/a&gt;&lt;/span&gt;
            &lt;/th&gt;
            &lt;th className=<span class="hljs-string">&quot;guide-info-number&quot;</span>&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-favorites&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;<span class="hljs-number">20</span>&lt;/a&gt;&lt;/span&gt;
            &lt;/th&gt;
            &lt;th className=<span class="hljs-string">&quot;guide-info-number&quot;</span>&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-followers&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;<span class="hljs-number">47</span>&lt;/a&gt;&lt;/span&gt;
            &lt;/th&gt;
          &lt;/tr&gt;

          &lt;tr&gt;
            &lt;td&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-authored&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;&lt;i className=<span class="hljs-string">&quot;fa fa-pencil&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;&lt;/span&gt;
            &lt;/td&gt;
            &lt;td&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-favorites&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;&lt;i className=<span class="hljs-string">&quot;fa fa-heart&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;&lt;/span&gt;
            &lt;/td&gt;
            &lt;td&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-followers&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;&lt;i className=<span class="hljs-string">&quot;fa fa-eye&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;&lt;/span&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;

      &lt;/div&gt;
    )
  }
}

<span class="hljs-comment">// Other nonsense</span>
export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileInfo</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {</span>
  render() {
    <span class="hljs-keyword">return</span> (
      div( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-guide-info-container&#39;] } ) {

        div( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-string">&quot;profile-image-wrapper&quot;</span>] } ) {
          img( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-image&#39;], src: <span class="hljs-symbol">&#39;https</span>:<span class="hljs-comment">//avatars1.githubusercontent.com/u/12636781?v=3&amp;s=460&#39; } ) {}</span>
        }

        div( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> <span class="hljs-symbol">&#39;name</span>-info-container&#39; } ) {
          h2( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> <span class="hljs-string">&quot;display-name&quot;</span> } ) { <span class="hljs-type">John</span> <span class="hljs-type">Doe</span> }
          h3( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> <span class="hljs-symbol">&#39;usernam</span>e&#39; } ) { jdoe }
        }

        table( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-guide-info&#39;] } ) {
          tr( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;number</span>-container&#39;] } ) {
            th( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;guide</span>-info-number&#39;] } ) {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } )
            }

            th( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;guide</span>-info-number&#39;] } ) {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } )
            }

            th( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;guide</span>-info-number&#39;] } ) {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } )
            }
          }

          tr() {
            td() {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } ) {}
            }

            td() {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } ) {}
            }

            td() {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } ) {}
            }
          }
        }
      }
    )
  }
}

<span class="hljs-comment">// why not like this?</span>
export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileInfo</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>{</span>
  render() {
    <span class="hljs-keyword">return</span> ({
      div : {
        <span class="hljs-class"><span class="hljs-keyword">class</span> :</span> [<span class="hljs-symbol">&#39;fo</span>o&#39;, <span class="hljs-symbol">&#39;ba</span>r&#39;]
      , p : {
          str : <span class="hljs-symbol">&#39;Bespoke</span> scenester retro bitters <span class="hljs-type">Pitchfork</span> <span class="hljs-number">8</span>-bit mixtape <span class="hljs-type">PBR</span>&amp;<span class="hljs-type">B</span> mlkshk iphone wire-rimmed glasses forage <span class="hljs-type">Helvetica</span> put a bird on it intelligentsia semiotics leggings normcore. <span class="hljs-type">Flexitarian</span> <span class="hljs-type">Echo</span> <span class="hljs-type">Park</span> mustache carles kickstarter <span class="hljs-type">Echo</span> <span class="hljs-type">Park</span> <span class="hljs-type">Blue</span> <span class="hljs-type">Bottle</span> actually tumblr beard literally tote bag <span class="hljs-type">Pitchfork</span> cray shabby <span class="hljs-type">Portland</span> stumptown asymmetrical.&#39;
        }
      }
    , footer : {
        span : {
          str : <code>&lt;span class=&quot;hljs-type&quot;&gt;Copyright&lt;/span&gt; ${datespan} ${company}. &lt;span class=&quot;hljs-type&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;Rights&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;Reserved&lt;/span&gt;.</code>
}}})}

<span class="hljs-comment">// or this?</span>
const n = notJSX
function notJSXparser(){
  <span class="hljs-keyword">return</span> n(<span class="hljs-symbol">&#39;bod</span>y&#39;, [
    n(<span class="hljs-symbol">&#39;h</span>1&#39;, {<span class="hljs-symbol">&#39;this</span> is a website&#39;},
      n(&#39;p&#39;, {<span class="hljs-symbol">&#39;this</span> is a lot of text! texytext, text. texting. txet.&#39;},
        n(<span class="hljs-symbol">&#39;foote</span>r&#39;, {<code>&lt;span class=&quot;hljs-type&quot;&gt;Copyright&lt;/span&gt; ${stuff}</code>})
      )
    )
  ])
}

<span class="hljs-comment">// how they do it in EVE&#39;s UI (<span class="hljs-doctag">note:</span> they use typescript and an in-house custom lib they call &#39;microReact&#39;)</span>
const page = {
  t          : <span class="hljs-symbol">&#39;spa</span>n&#39; <span class="hljs-comment">// the tag type; defauts to &#39;div&#39;</span>
, c          : <span class="hljs-symbol">&#39;col</span>-<span class="hljs-number">12</span>&#39; <span class="hljs-comment">// className</span>
, text       : <span class="hljs-symbol">&#39;some</span> content&#39;
, children   : [{
    <span class="hljs-comment">// array of further nodes</span>
  }]
, top        : <span class="hljs-number">10</span>
, width      : <span class="hljs-number">100</span> <span class="hljs-comment">// more styles can go here, like react&#39;s style object basically</span>
, click      : someHandler
, svg        : <span class="hljs-literal">true</span> <span class="hljs-comment">// to add svg properties... why? idk. just &#39;cuz, i guess.</span>
, cx         : <span class="hljs-number">4</span>
, cy         : <span class="hljs-number">4</span>
, postRender : someDomManipulationFunction <span class="hljs-comment">// on insertion and on update</span>
}

<span class="hljs-comment">// how jsx actually kinda works (reactelement anyway) under the hood:</span>
let someEl = {
  <span class="hljs-class"><span class="hljs-keyword">type</span>  :</span> <span class="hljs-symbol">&#39;di</span>v&#39;
, props : {}
, ref   : <span class="hljs-literal">null</span>
, key   : <span class="hljs-literal">null</span>
}</code></pre>]]></description><link>/2016/05/05/better-jsx.html</link><guid isPermaLink="true">/2016/05/05/better-jsx.html</guid><category><![CDATA[jsx]]></category><category><![CDATA[react]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 06:00:00 GMT</pubDate></item><item><title><![CDATA[currying and partial application]]></title><description><![CDATA[<pre class="hljs"><code><span class="hljs-comment">// Prototype&#39;s version?</span>
<span class="hljs-built_in">Function</span>.prototype.curry = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> fn   = <span class="hljs-keyword">this</span>
    , args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args.concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)))
  }
}

<span class="hljs-comment">// Functional&#39;s version?</span>
<span class="hljs-built_in">Function</span>.prototype.partial = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> fn   = <span class="hljs-keyword">this</span>
    , args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> arg = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length &amp;&amp; arg &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
      <span class="hljs-keyword">if</span> (args[i] === <span class="hljs-literal">undefined</span>) {
        args [i] = <span class="hljs-built_in">arguments</span>[arg++]
      }
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args)
    }
  }
}

<span class="hljs-comment">// from angus croll&#39;s blog</span>
<span class="hljs-comment">// note, the toArray is because the <code>arguments</code> array is actually and object</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">enumm</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(enumm)
}
<span class="hljs-comment">// toArray is superfluous now, though, because we can just do</span>
<span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>)
<span class="hljs-comment">//</span>
<span class="hljs-built_in">Function</span>.prototype.curry = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }
  <span class="hljs-keyword">var</span> <strong> method = <span class="hljs-keyword">this</span>
    , args      = toArray(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> </strong>method.apply(<span class="hljs-keyword">this</span>, args.concat(toArray(<span class="hljs-built_in">arguments</span>)))
  }
}
<span class="hljs-comment">// and an example from his blog, using the above</span>
<span class="hljs-keyword">const</span>
  converter = (ratio, symbol, input) =&gt; [(input <em> ratio).toFixed(<span class="hljs-number">1</span>), symbol].join(<span class="hljs-string">&#39; &#39;</span>)
, kgToLb    = converter.curry(<span class="hljs-number">2.2</span>, <span class="hljs-string">&#39;lbs&#39;</span>)
, liToPi    = converter.curry(<span class="hljs-number">1.98</span>, <span class="hljs-string">&#39;pints&#39;</span>)
, miToKm    = converter.curry(<span class="hljs-number">1.62</span>, <span class="hljs-string">&#39;km&#39;</span>)


<span class="hljs-comment">// note that these are all examples of partial application,</span>
<span class="hljs-comment">// not true currying as one would have in a purely functional language</span>
<span class="hljs-comment">// see:</span>
<span class="hljs-keyword">const</span> foo = (a, b) =&gt; a + b
foo.partiallyApply(<span class="hljs-number">2</span>) <span class="hljs-comment">// b =&gt; 2 + b</span>
foo.curry() <span class="hljs-comment">// a =&gt; b =&gt; a + b</span>
foo.curry()(<span class="hljs-number">2</span>) <span class="hljs-comment">// foo.partiallyApply(2)</span>

<span class="hljs-built_in">Function</span>.prototype.curry = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span>
    method = <span class="hljs-keyword">this</span>
  , i      = <span class="hljs-number">0</span>
  , len    = <span class="hljs-keyword">this</span>.length
  , args   = []

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
    args.push(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">if</span> (++i &lt; len) {
      <span class="hljs-keyword">return</span> f
    } <span class="hljs-keyword">else</span> {
      method.apply(<span class="hljs-keyword">this</span>, args)
    }
  }
  <span class="hljs-keyword">return</span> f
}

<span class="hljs-comment">// here&#39;s a super simplistic adding thingy</span>
<span class="hljs-keyword">const</span> adder = (a, b) =&gt; <span class="hljs-keyword">typeof</span>(b) !== <span class="hljs-string">&#39;undefined&#39;</span> ? a + b : c =&gt; a + c
<span class="hljs-comment">// i think the es6 is right for this? in es5 also:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adder</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">&#39;undefined&#39;</span>) {
    <span class="hljs-keyword">return</span> a + b
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>)</span>{
      <span class="hljs-keyword">return</span> a + c
    }
  }
}

<span class="hljs-comment">// the real difference between partial application and currying:</span>
<span class="hljs-comment">// a curried function will accept ONLY one argument at a time.</span>
<span class="hljs-comment">// it will continue accepting one argument each time it&#39;s called right</span>
<span class="hljs-comment">// up until it&#39;s got enough, then will finally be executed for realz.</span>

<span class="hljs-comment">// so: a function that can take a function as input, and an int for</span>
<span class="hljs-comment">// the max args. should be able to call like so:</span>
curry(fn, n, ...args) <span class="hljs-comment">// ... that is,</span>
curry(fn, n, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// or</span>
curry(fn, n)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) <span class="hljs-comment">// or</span>
curry(fn, n)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// and we should get the same results each way.</span>
<span class="hljs-comment">// so</span>
curry(fn, n, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) == curry(fn, n, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)

<span class="hljs-comment">// notes on the below:</span>
<span class="hljs-comment">// fn.apply(a, [1, 2, 3]) is kinda the same as doing</span>
<span class="hljs-comment">// fn.call(a, 1, 2, 3), where <code>a</code> is <code>this</code></span>
<span class="hljs-keyword">const</span> argsArr = args =&gt; <span class="hljs-built_in">Array</span>.from(args)

<span class="hljs-keyword">const</span> curry = (fn, n) =&gt; {
  <span class="hljs-keyword">const</span> args = argsArr(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">if</span> (n === args.length -<span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">undefined</span>, args.slice(<span class="hljs-number">2</span>))
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> () =&gt; {
      <span class="hljs-keyword">return</span> curry.apply(<span class="hljs-literal">undefined</span>, args.concat(<span class="hljs-built_in">arguments</span>))
    }
  }
}
<span class="hljs-comment">// so try:</span>
<span class="hljs-keyword">const</span> addFour = (a, b, c, d) =&gt; a + b + c + d
curry(addFour, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)

<span class="hljs-comment">// modified to use Function.length</span>
<span class="hljs-keyword">const</span> newCurry = (fn, n) =&gt; {
  <span class="hljs-keyword">let</span> args = argsArr(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(n) == <span class="hljs-string">&#39;undefined&#39;</span>) {
    args[<span class="hljs-number">1</span>] = fn.length
  }
  <span class="hljs-keyword">if</span> (n === args.length - <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">undefined</span>, args.slice(<span class="hljs-number">2</span>))
  }
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> newCurry.apply(<span class="hljs-literal">undefined</span>, args.concat(argsArr(<span class="hljs-built_in">arguments</span>)))
  }
}


<span class="hljs-comment">// okay, so, from some other blog</span>
<span class="hljs-keyword">const</span> objs = [{id : <span class="hljs-number">1</span>}, {id : <span class="hljs-number">2</span>}, {id : <span class="hljs-number">3</span>}, {id : <span class="hljs-number">4</span>}]
objs.map(o =&gt; o.id)
<span class="hljs-comment">// this is actualy a lot cleaner than his example, because he&#39;s doing it like</span>
<span class="hljs-keyword">var</span> objs = [{id : <span class="hljs-number">1</span>}, {id : <span class="hljs-number">2</span>}, {id : <span class="hljs-number">3</span>}, {id : <span class="hljs-number">4</span>}]
objs.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>)</span>{<span class="hljs-keyword">return</span> o.id})
<span class="hljs-comment">// but we&#39;ll see where this goes, anyway</span>
<span class="hljs-keyword">const</span> curry = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;curry&#39;</span>) <span class="hljs-comment">// npm i -S curry</span>
<span class="hljs-keyword">const</span> get = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">property, object</span>)</span>{<span class="hljs-keyword">return</span> object[property]})
objs.map(get(<span class="hljs-string">&#39;id&#39;</span>))
<span class="hljs-comment">// meh.</span>
<span class="hljs-keyword">const</span> getIDs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">objects</span>)</span>{
  <span class="hljs-keyword">return</span> objects.map(get(<span class="hljs-string">&#39;id&#39;</span>))
}
getIDs(objs)
<span class="hljs-comment">// double meh.</span>
<span class="hljs-keyword">const</span> map    = curry((fn, val) =&gt; val.map(fn))
    , getIDs = map(get(<span class="hljs-string">&#39;id&#39;</span>))

<span class="hljs-comment">// still not sure this is actually cleaner xD</span>
<span class="hljs-comment">// let&#39;s keep going with his examples (translated to ES2015, though)</span>
<span class="hljs-comment">// some sample data (we&#39;ll pretend this is JSON we&#39;re getting from somewhere):</span>
<span class="hljs-keyword">const</span> sampleData = {
  <span class="hljs-string">&quot;user&quot;</span>  : <span class="hljs-string">&quot;z&quot;</span>
  , <span class="hljs-string">&quot;posts&quot;</span> : [
    {<span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;title!&quot;</span>     , <span class="hljs-string">&quot;contents&quot;</span> : <span class="hljs-string">&quot;asdf&quot;</span>  }
  , {<span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;something!&quot;</span> , <span class="hljs-string">&quot;contents&quot;</span> : <span class="hljs-string">&quot;ghjkl;&quot;</span>}
  ]
}
<span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>).get(<span class="hljs-string">&#39;something.whatever/that/data.json&#39;</span>)
.then(<span class="hljs-built_in">JSON</span>.parse)
.then(data =&gt; data.posts)
.then(posts =&gt; posts.map(post =&gt; post.title))
<span class="hljs-comment">// or, using the curry stuff</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>).get(<span class="hljs-string">&#39;something.whatever/that/data.json&#39;</span>)
.then(<span class="hljs-built_in">JSON</span>.parse)
.then(get(<span class="hljs-string">&#39;posts&#39;</span>))
.then(map(get(<span class="hljs-string">&#39;title&#39;</span>)))
<span class="hljs-comment">// uh</span>
<span class="hljs-comment">// okay</span>
<span class="hljs-comment">// i don&#39;t see that this is any better, here.</span>
<span class="hljs-comment">// oh wait, he wrote a follow-up!</span>

<span class="hljs-comment">// shit. i think some of this might be wrong.</span>
<span class="hljs-comment">// there&#39;s no <code>arguments</code>! i knew about <code>this</code>, but not <code>arguments</code>.</span>
<span class="hljs-comment">// (talking about when using <code>=&amp;gt;</code>, i mean.)</span>
<span class="hljs-comment">// not really a big deal, just in the above, we need to use <code>...args</code> instead.</span>
<span class="hljs-comment">// for example,</span>
<span class="hljs-keyword">let</span> sum = (...nums) =&gt; nums.reduce((a, b) =&gt; a + b)



<span class="hljs-comment">// examples:</span>
<span class="hljs-comment">// in es5:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatter</span>(<span class="hljs-params">tag, text</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;&lt;&#39;</span> + tag + <span class="hljs-string">&#39;&gt;&#39;</span> + text + <span class="hljs-string">&#39;&lt;/&#39;</span> + tag + <span class="hljs-string">&#39;&gt;&#39;</span>
}
<span class="hljs-keyword">var</span> p = formatter.bind(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#39;p&#39;</span>)
p(<span class="hljs-string">&#39;some content!&#39;</span>)
<span class="hljs-comment">// in es6:</span>
<span class="hljs-keyword">const</span> formatter = (tag, text) =&gt; <span class="hljs-string"><code>&amp;lt;&lt;span class=&quot;hljs-subst&quot;&gt;${tag}&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-subst&quot;&gt;${text}&lt;/span&gt;&amp;lt;/&lt;span class=&quot;hljs-subst&quot;&gt;${tag}&lt;/span&gt;&amp;gt;</code></span>
<span class="hljs-keyword">const</span> p = text =&gt; formatter(<span class="hljs-string">&#39;p&#39;</span>, text)
<span class="hljs-comment">// accepting addtional arguments (more text):</span>
<span class="hljs-keyword">const</span> fmt = (tag, text, moar) =&gt; <span class="hljs-string"><code>&amp;lt;&lt;span class=&quot;hljs-subst&quot;&gt;${tag}&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-subst&quot;&gt;${text}&lt;/span&gt;&lt;span class=&quot;hljs-subst&quot;&gt;${moar}&lt;/span&gt;&amp;lt;/&lt;span class=&quot;hljs-subst&quot;&gt;${tag}&lt;/span&gt;&amp;gt;</code></span>
<span class="hljs-keyword">const</span> span = ...args =&gt; fmt(<span class="hljs-string">&#39;span&#39;</span>, ...args)

<span class="hljs-comment">// okay, that&#39;s cute because it just lets you specify however many you want, but...</span>
<span class="hljs-keyword">const</span> cur = (fn, ...argsOne) =&gt; (...argsTwo) =&gt; fn(...argsOne, ...argsTwo)
<span class="hljs-comment">// or, allowing placeholders, as in underscore:</span>
<span class="hljs-keyword">const</span> curMore = (fn, ...argsOne) =&gt; {
  <span class="hljs-keyword">let</span> i = argsOne.indexOf(<em>)
  <span class="hljs-keyword">let</span> argsOne = (i === -<span class="hljs-number">1</span>) ? [] : argsOne.splice(i).slice(<span class="hljs-number">1</span>)
  <span class="hljs-keyword">return</span> (...argsTwo) =&gt; fn(...argsOne, ...argsTwo, ...argsThree)
}
<span class="hljs-comment">// which can then be used like:</span>
<span class="hljs-keyword">const</span> lessTen = curMore(subtract, </em>, <span class="hljs-number">10</span>) <span class="hljs-comment">// assuming we&#39;ve defined a <code>subtract</code> somewhere</span>



<span class="hljs-comment">// from brian lonsdorf&#39;s blog/medium, a better <code>curry</code> (better in that</span>
<span class="hljs-comment">// it should be easier to debug).</span>
<span class="hljs-comment">// <span class="hljs-doctag">note:</span> very definitely es5. and redifines toString().</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fx</span>)</span>{
  <span class="hljs-keyword">var</span> arity = fx.length
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> (args.length &gt;= arity) {
      <span class="hljs-keyword">return</span> fx.apply(<span class="hljs-literal">null</span>, args)
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> f1.apply(<span class="hljs-literal">null</span>, args.concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>)))
    }
    f2.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> fToString(fx) + <span class="hljs-string">&#39;(&#39;</span> + args.join(<span class="hljs-string">&#39;, &#39;</span>) + <span class="hljs-string">&#39;)&#39;</span>
    }
    <span class="hljs-keyword">return</span> f2
  }
  f1.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> fToString(fx)
  }
  <span class="hljs-keyword">return</span> f1
}
<span class="hljs-comment">// and a compose from the same:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> fns = <span class="hljs-built_in">arguments</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">result</span>)</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = fns.length - <span class="hljs-number">1</span>; i &gt; -<span class="hljs-number">1</span>; i--) {
      <span class="hljs-keyword">try</span> {
        result = fns[i].call(<span class="hljs-keyword">this</span>, result)
      } <span class="hljs-keyword">catch</span>(e) {
        e.message = f.toString() + <span class="hljs-string">&#39; failed at &#39;</span> fns[i].toString()
        <span class="hljs-keyword">throw</span>(e)
      }
    }
    f.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;compose(&#39;</span>+[].slice.call(fns).map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>)</span>{ <span class="hljs-keyword">return</span> f.toString() }).join(<span class="hljs-string">&#39;, &#39;</span>)+<span class="hljs-string">&#39;)&#39;</span>;
    }
    <span class="hljs-keyword">return</span> result
  }
  <span class="hljs-keyword">return</span> f
}



<span class="hljs-comment">// from reginald braithwaite&#39;s blog</span>
<span class="hljs-comment">// </em> arity: number of arguments a function accepts</span>
<span class="hljs-comment">//   <em> nullary function takes no arguments</span>
<span class="hljs-comment">//   </em> unary function accepts one</span>
<span class="hljs-comment">//   <em> polyadic function accepts more than one</span>
<span class="hljs-comment">//   </em> binary accepts two</span>
<span class="hljs-comment">//   <em> ternary function accepts three</span>
<span class="hljs-comment">//   </em> variadic function accepts a variable number of arguments</span>

<span class="hljs-comment">// a map fn</span>
<span class="hljs-keyword">const</span> <strong> map = [].map
<span class="hljs-keyword">const</span> square = n =&gt; n * n
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">list, unary</span>)</span>{
  <span class="hljs-keyword">return</span> </strong>map.call(list, unaryFn)
}
map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], square)

<span class="hljs-comment">// this is fine as long as map gets both arguments (is fully applied)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapWrap</span>(<span class="hljs-params">unaryFn</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>)</span>{
    <span class="hljs-keyword">return</span> map(list, unaryFn)
  }
}
mapWrap(square)([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])

<span class="hljs-keyword">const</span> squareAll = mapWrap(square)
squareAll([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])

<span class="hljs-comment">// woot! that&#39;s fine, but annoying to write. so, a function to wrap functions:</span>
<span class="hljs-comment">// const wrapper = unaryFn =&gt; list =&gt; map(list, unaryFn) // can become:</span>
<span class="hljs-comment">// const wrapper = second =&gt; first =&gt; binaryFn(first, second) // can become:</span>
<span class="hljs-keyword">const</span> rightCurry = binaryFn =&gt; secondArgument =&gt; firstArgument =&gt; binaryFn(firstArgument, secondArgument)
<span class="hljs-comment">// which can be used like</span>
<span class="hljs-keyword">const</span> rightCurryMap = rightCurry(map)
<span class="hljs-keyword">const</span> squareAll     = rightCurryMap(square)
squareAll([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])
<span class="hljs-comment">// calling this rightCurry because it takes any binary function and curries into a chain</span>
<span class="hljs-comment">// of unary functions, starting with the second argument. a curry that starts on the left</span>
<span class="hljs-comment">// is more common, and it&#39;s usually what people mean.</span>
<span class="hljs-keyword">const</span> curry = binaryFn =&gt; firstArg =&gt; secondArg =&gt; binaryFn(firstArg, secondArg)
<span class="hljs-keyword">const</span> cMap  = curry(map)
<span class="hljs-keyword">const</span> twice         = n =&gt; n + n <span class="hljs-comment">// why did i write this down?</span>
<span class="hljs-comment">// whether one goes with a leftmost or rightmost curry could depend on which things</span>
<span class="hljs-comment">// you might need to name and/or reuse</span>

<span class="hljs-comment">// okay so apparently a pattern like this:</span>
<span class="hljs-keyword">const</span> squareAll = rightCurry(map)(square)
<span class="hljs-keyword">const</span> doubleAll = rightCurry(map)(twice)
<span class="hljs-comment">// is called a:</span>
<span class="hljs-comment">// rightmost unary partial application of the map function</span>
<span class="hljs-comment">// which means it starts from the right, takes one arg, applies not all of the args, and works on the map fn</span>

<span class="hljs-comment">// the wrong way to build a first-class function to do this would be:</span>
<span class="hljs-keyword">const</span> rightUnPartApp = (binaryFn, secondArg) =&gt; rightCurr(binaryFn)(secondArg)
<span class="hljs-comment">// and a better way might be</span>
<span class="hljs-keyword">const</span> lastApplication = (binaryFn, secondArg) =&gt; firstArg =&gt; binaryFn(firstArg, secondArg)
<span class="hljs-comment">// which means we could do</span>
<span class="hljs-keyword">const</span> squareAll = lastApplication(map, square)
<span class="hljs-keyword">const</span> doubleAll = lastApplication(map, twice)
<span class="hljs-comment">// and so, we could do</span>
<span class="hljs-keyword">const</span> firstApp = (binaryFn, firstArg) =&gt; secondArg =&gt; binaryFn(firstArg, secondArg)

<span class="hljs-comment">// SO. wat.</span>
<span class="hljs-comment">// Currying : decomposition of a polyadic function into a chain of nested unary functions. Thus,</span>
<span class="hljs-comment">// decomposed, you can partially apply one or more arguments, although the curry operation itself</span>
<span class="hljs-comment">// does not apply any arguments to the function.</span>
<span class="hljs-comment">// Partial application : conversion of a polyadic function into a function taking fewer arguments</span>
<span class="hljs-comment">// by providing one or more arguments in advance.</span>




<span class="hljs-comment">// this is approximately the same as wu.js&#39;s .autoCurry() (which has been removed??)</span>
<span class="hljs-comment">// (es5, obvs. <span class="hljs-doctag">todo:</span> simplify, basically just by making it es6.)</span>
<span class="hljs-keyword">var</span> autoCurry = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{

  <span class="hljs-keyword">var</span>
    toArray = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">arr, from</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(arr, from || <span class="hljs-number">0</span>)
  }

, curry = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">var</span> args = toArray(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curried</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args.concat(toArray(<span class="hljs-built_in">arguments</span>)))
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">autoCurry</span>(<span class="hljs-params">fn, numArgs</span>)</span>{
    numArgs = numArgs || fn.length
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">autoCurried</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; numArgs) {
        <span class="hljs-keyword">return</span> numArgs - <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span> ?
        autoCurry(curry.apply(<span class="hljs-keyword">this</span>, [fn].concat(toArray(<span class="hljs-built_in">arguments</span>)))
      , numArgs - <span class="hljs-built_in">arguments</span>.length)           :
        curry.apply(<span class="hljs-keyword">this</span>, [fn].concat(toArray(<span class="hljs-built_in">arguments</span>)))
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
      }
    }
  }

}())</code></pre>]]></description><link>/2016/05/05/currying-and-partial-application.html</link><guid isPermaLink="true">/2016/05/05/currying-and-partial-application.html</guid><category><![CDATA[currying]]></category><category><![CDATA[fp]]></category><category><![CDATA[partial-application]]></category><category><![CDATA[functional-programming]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 06:00:00 GMT</pubDate></item><item><title><![CDATA[NOTES FROM DEVMOUNTAIN]]></title><description><![CDATA[<p>This is going to be a crapton of my notes, from when I was going through the course at DevMountain.</p>
<p>Looking back over these, a lot of them are dumb. What I mean by this is that my opinions on things were dumb.</p>
<p>Whatever.</p>
<p>Don&#39;t take it all so seriously. Some of it could be really helpful. This is about half of my collected
notes <em>that were inside project files</em>. Everything else has already been cleaned up and posted, or is in
a directory of drafts somewhere. This stuff is totally unedited.</p>
<hr>
<h2 id="ng-probs">ng probs</h2>
<pre class="hljs"><code><span class="hljs-comment">// this is in a <code>.then</code>. NOTE THAT ANGULAR WILL GIVE YOU AN OBJECT EVEN IF YOU HAVE AN ARRAY</span>
<span class="hljs-comment">// though it will give you your <em>objects</em> in the <em>array</em> that they come in, it&#39;ll still work</span>
<span class="hljs-comment">// on the front end.</span>
<span class="hljs-comment">// we were having issues here looping over the array and setting the returned index on scope,</span>
<span class="hljs-comment">// then trying to return that. this works a lot better.</span>
.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(stuff)</span></span>{
  <span class="hljs-variable">$scope</span>.foo = stuff
  <span class="hljs-variable">$scope</span>.things = stuff.StuffToBringBack
})</code></pre><hr>
<h2 id="angular-directives">angular: directives</h2>
<p>directives are different than controllers and services. directives ALWAYS return an object. when you write a
ctrl or svc you&#39;re giving some definitions to something that already exists. with directives you&#39;re closer
to writing routing. you&#39;re writing a set of instructions. they return an object. objects get, obviously,
key-value pairs.</p>
<pre class="hljs"><code><span class="hljs-class">.directive</span>(<span class="hljs-string">&#39;myDirective&#39;</span>, <span class="hljs-function">function</span>(){
  <span class="hljs-tag">return</span> {
    <span class="hljs-attribute">template</span>: <span class="hljs-string">&#39;Key: Value, key: value&#39;</span>;
  }
})</code></pre><p>directive names MUST be camelCase. pascal case will not be recognized. nor snake case?</p>
<p>i mean, really, it&#39;s all made a lot more complicated than it needs to be. we&#39;re starting out basically
just making our own little bits. it makes sense. if it works as a template file, or as just regular html,
it&#39;ll work as a custom directive. just more reusable as a directive.</p>
<p>we could have a directive with a TYPE. imagine a function that returns a customer with an attribute that&#39;s
.type... so we&#39;d have a directive called myCustomer, type=&quot;name&quot;, then another, type=&quot;smoking habits&quot;.
paramaters here are always (element, attribute).</p>
<p>Restrict as a property: E means element (so you&#39;d do <myDirective> instead of <div myDirective>
A is attribute, so it&#39;d be <div myDirective>
can do BOTH so it&#39;d work for either. (restrict: EA)
C is for class, but let&#39;s not do that! That seems like a really not okay and very bad idea.
This is basically for semantic enforcement. Element would be good for a custom block, eg</p>
<p><myDirective>a whole bunch of shit just about this one</myDirective></p>
<p><mySECONDdirective>another whole bunch</mySECONDdirective> etc
A would be good for tacking things onto elements that would likely be there anyway, it seems.
If you need to take in parameters, A would be better.</p>
<p>custom filters like this!</p>
<pre class="hljs"><code>&lt;input model=<span class="hljs-string">&quot;whatcha&quot;</span>&gt;
&lt;span custom=<span class="hljs-string">&quot;format&quot;</span>&gt;
<span class="hljs-keyword">function</span> link(scope, <span class="hljs-literal">element</span>, attributes){
var whatever
stuffings
}
<span class="hljs-keyword">return</span> { link: link; }
scp.<span class="hljs-variable">$watch</span>(<span class="hljs-string">&#39;format&#39;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-keyword">value</span>){
format=value;
updateTime();
});</code></pre><p>link ALWAYS takes in at leaste those three, and alkways in that order!</p>
<p>inside a directive, feel free to do some jquery-lite.
if you want to use, say, d3, or three.js, you can go ahead and inject that into angular
and use it. (we&#39;re talking about other DOM manupilation, not utilities like lodash).</p>
<p>inside a link whatever, that scp refers to its parent&#39;s scope, it shares parent&#39;s scope
by default. eg if custom up there is directly below mainCtrl, scp means mainCtrl&#39;s $scope.</p>
<p>underneath .directive, the scope: { stuff } actually means, like, scope INSTRUCTIONS or
somesuch.</p>
<p>SCOPE</p>
<pre class="hljs"><code><span class="hljs-tag">scope</span>: {
<span class="hljs-attribute">string</span>: <span class="hljs-string">&#39;@&#39;</span>,
<span class="hljs-attribute">link</span>: <span class="hljs-string">&#39;=&#39;</span>,
<span class="hljs-attribute">func</span>: <span class="hljs-string">&#39;&amp;&#39;</span>
}</code></pre><p>The properties on the scope object represent the attributes on the directive in the html. Our example scope object here would look something like this in the html.
<code>&lt;example-directive string=&quot;a string&quot; link=&quot;user&quot; func=&quot;updateUser()&quot;&gt;&lt;/example-directive&gt;</code>
The hard part here is the <code>@</code>, <code>=</code>, and <code>&amp;</code>. They each have very important and distinct meanings.</p>
<ul>
<li><code>@</code> says take in my attribute value as a string.</li>
<li><code>=</code> says take in my attribute value as a two-way bound variable from the parent scope.</li>
<li><p><code>&amp;</code> says take in my attribute value as a reference to a function on the parent scope.</p>
</li>
<li><p>(from another notes snippet):</p>
<ul>
<li><code>@</code> : string/text (one-way)</li>
<li><code>=</code> : two-way</li>
<li><code>&amp;</code> : binds parent scope&#39;s methods into directive&#39;s scope</li>
<li><code>&lt;</code> : one-way (outer-to-inner)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="firebase">firebase</h2>
<p>firebase with $firebaseObject (or $firebaseArray) and $bindTo just makes all
the <strong>MAGIC</strong> (that we poor slobs are are too dumb to even vaguely comprehend)
even MORE magical; with angularfire and firebase and angular doing everything
for you, we now have, basically, a subpar meteor-like 3-way-binding.</p>
<p><code>&lt;ng-change=&quot;$scope.save(thingy)&quot;&gt;</code> will propogate back to firebase
(or <code>&lt;ng-change=&quot;thingy(save)&quot;&gt; // $scope.sav(thingy)</code> if we&#39;re doing things
modularly).</p>
<p><code>ng-model-options=&quot;{debounce: {&#39;default&#39;: 5000}}&quot; // debounces. to 5000 ms. wowe.</code></p>
<hr>
<h2 id="express">express</h2>
<ul>
<li>if chain in express:</li>
<li>method, url, callback</li>
<li><code>app.all(&#39;/endpoint&#39;, function(){console.log(&#39;a thing&#39;)})</code></li>
<li>so it&#39;s one long chain of if statements. like we do manually. that&#39;s all.</li>
<li>express chain [{method: &#39;all&#39;, endpoint:&#39;/endpoint&#39;, function(){}, {method: &#39;get&#39;, endpoint:&#39;/nextone&#39;}etc etc etc etc}]d</li>
<li>all endpoints are hit, with exception dependent on response</li>
<li>req and res are passed to EVERY function by express</li>
<li>ongoing request and response are passed on down whole if statement chain</li>
<li>a controller can&#39;t reference arrays from another file.<ul>
<li>so, your server (or, let&#39;s say, your index) couldn&#39;t have something defined that a ctrl needs to access<ul>
<li>(assuming your ctrl is set up as a an object, module.exports = {} with your functions(req, res, next) all in there.)</li>
</ul>
</li>
<li>solution?</li>
<li>move your stuff into the file where you want to access it, i guess.</li>
<li>module.exports can be an array, too. that makes sense in a db context, okay.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="express-more">express more</h2>
<h4 id="req-params-vs-req-query">req.params vs req.query</h4>
<ul>
<li>Params and Query do the same thing.</li>
<li>Params is hardcoded into endpoint; query allows some flexibility.</li>
<li>Query uses <a href="http://url.url/api/endpoint?whatever=something">http://url.url/api/endpoint?whatever=something</a></li>
<li>Param would be more like <a href="http://url.url/api/endpoint/something">http://url.url/api/endpoint/something</a></li>
</ul>
<pre class="hljs"><code>app.get(<span class="hljs-string">&#39;api/hobbies/:type/:fun&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span></span>{
  req.params.<span class="hljs-built_in">type</span> // boring
  hobbies.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(hobby)</span></span>{
    <span class="hljs-keyword">if</span> (hobby.<span class="hljs-built_in">type</span> = req.params.<span class="hljs-built_in">type</span>) {
      res.send(hobby)
    }
  })
});

localhost:<span class="hljs-number">8989</span>/api/hobbies/boring/no

app.get(<span class="hljs-string">&#39;api/hobbies&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span></span>{
  req.query.<span class="hljs-built_in">type</span> // boring
  hobbies.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(hobby)</span></span>{
    <span class="hljs-keyword">if</span> (hobby.<span class="hljs-built_in">type</span> = req.query.<span class="hljs-built_in">type</span>) {
      res.send(hobby)
    }
  })
})

localhost:<span class="hljs-number">8989</span>/api/hobbies?<span class="hljs-built_in">type</span>=boring&amp;fun=no

var hobbies = [];</code></pre><h4 id="how-to-not-need-to-use-express-cors-or-whatever-cors-">how to not need to use express-cors (or whatever-cors)</h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#39;express&#39;</span>);
<span class="hljs-keyword">var</span> request = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#39;request&#39;</span>);

<span class="hljs-keyword">var</span> app = express();
app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&#39;/&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> url = apiServerHost + req.url;
  req.pipe(request(url)).pipe(res);
});

app.listen(process.env.PORT || <span class="hljs-number">3000</span>);</code></pre><p>OBVIOUSLY this only applies when everything&#39;s local; this is a proxy server, essentially, sort of.</p>
<p>also there&#39;s an express builtin: <code>app.use(express.static()</code>, eg <code>app.use(express.static(&#39;public&#39;))</code></p>
<h4 id="monogooooooooooo-se-">monogooooooooooo(se)</h4>
<p>Turns out if you send Mongoose anything that&#39;s not in your schema, it&#39;s just like &quot;Oh, okay, I&#39;m not interested&quot; and tosses that bit out, I guess.</p>
<p>When we&#39;re not doing eg <code>require(&#39;./path&#39;)</code> (but rather <code>require(/path)&#39; with no dot first</code>), it looks in <code>node_modules/</code>. Obvs usually we&#39;ll probably look from cwd instead. Any way to look from project root by default?</p>
<pre class="hljs"><code>getStuff: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span>{</span>
  <span class="hljs-transposed_variable">Stuff.</span>find().populate(<span class="hljs-string">&#39;things.whatevers&#39;</span>).exec()
    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data, err)</span></span>
<span class="hljs-comment">// etc., etc., etc., etc.</span></code></pre><hr>
<h2 id="ionic">ionic</h2>
<ul>
<li>We&#39;re getting a little super-fast (read: unplanned and, I think, unannounced) rundown on Ionic.</li>
<li>Which is totally fine, but it&#39;s basically Angular, plus Phonegap, which are two things I rather dislike.</li>
<li>Okay, I&#39;m using the Yeoman generator-ionic-gulp seed.</li>
<li>Aaaaand this is just like Angular, except with predefined CSS rules, basically.</li>
<li>The &#39;magic&#39; is all in the bit where it handles compiling/wrapping for you.</li>
<li>So... on with my personal project, I suppose.</li>
</ul>
<hr>
<h2 id="d3">D3</h2>
<ul>
<li>svg starts 0,0 top left, not bottom left.</li>
<li>svg has no z-index. just renders in order it&#39;s written.</li>
<li>rotations and transforms on svg will screw with things when it comes to moving stuff!</li>
<li>d3, chaining methods super common.</li>
</ul>
<hr>
<h2 id="react">react</h2>
<ul>
<li>react is reacty. it reacts, sometimes reactively.</li>
<li>it&#39;s still ugly as hell and i hope it dies, though.</li>
<li>note that i&#39;m doing all this in vim because:<ul>
<li>A. lighttable doesn&#39;t like react and</li>
<li>B. lighttable has my projects loadded up, currently, and i don&#39;t want to add yet another workspace.</li>
</ul>
</li>
<li>so, this will probably all be formatted like shit, because vim doesn&#39;t understand, no matter how many times i tell it, that i don&#39;t want it to turn spaces into tabs, i want the opposite.</li>
<li>oh well.</li>
</ul>
<hr>
<h2 id="s3">S3</h2>
<ul>
<li>Basically, since Mongo can&#39;t store images without doing difficult-ish things involving GridFS,
the prescription is to use S3 in... basically the same way, actually, which results in more total requests,
but the hope is that Amazon&#39;s caching or somesuch is good enough to offset the latency.</li>
<li>Amazon needs your regional server to be passed in during requests. Which is both sensible and silly, since really that should be a part of your keys.</li>
<li>When Amazon wants a &#39;Key&#39; in your paramss, that&#39;s not a key. That&#39;s the actual thing you&#39;re fuckin&#39; with. so, req.body.img.</li>
<li>Buffers in node are bytes in python are strings in PHP if they were mutable.</li>
</ul>
<hr>
<h2 id="deployment-while-in-development">deployment while in development</h2>
<h3 id="heroku">heroku</h3>
<ul>
<li>workflow: have a project. have a git repo in it. <code>heroku create</code>, assuming you use/have heroku.</li>
<li>(same as <code>git remote add heroku https://someurl.herokuapp.com</code>)</li>
</ul>
<h3 id="digital-ocean">digital ocean</h3>
<ul>
<li>digital ocean: works the same as ever, which is to say, it&#39;s not convenient,
but it it&#39;s okay. prefer koding if they let me back in, but if not,
maybe using codeanywhere/codenvy/c9/any one of the other IDEs with built in dev servers.</li>
</ul>
<hr>
<p>...that&#39;s all, for now. There will probably be more, once I sort through the first three weeks&#39; worth of shit.</p>
<p>tags: notes, devmountain, lol, i-am-ridiculous, directives, angular, firebase, express, mongo, mongoose, node, ionic, d3, react, heroku, digital-ocean</p>
]]></description><link>/2016/05/05/notes-from-devmountain-01.html</link><guid isPermaLink="true">/2016/05/05/notes-from-devmountain-01.html</guid><category><![CDATA[devmtn]]></category><category><![CDATA[notes]]></category><category><![CDATA[js]]></category><category><![CDATA[css]]></category><category><![CDATA[angular]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 06:00:00 GMT</pubDate></item><item><title><![CDATA[More DevMountain Notes]]></title><description><![CDATA[<p>This is a bunch more notes from my time going through the course at DevMountain.</p>
<p>These notes are specifically from the first three weeks. They&#39;re a mess.</p>
<p>Don&#39;t take anything too seriously. I probably didn&#39;t know what I was talking about, a lot of the time.</p>
<hr>
<h2 id="css">css</h2>
<p>if a div has position absolute, position RELATIVE on another
element will be in RELATION to the div that has ABSOLUTE.</p>
<p>so, top 0 is in RELATION to something else that has ABSOLUTE,
otherwise just defaults to in relative to HTML.</p>
<p>in simpler terms... position is basically just referring to its immediate parent,
unless there&#39;s no frame of reference there. all hierarchical. (lol hence C in CSS....)</p>
<ul>
<li>box-model:<ul>
<li>border goes OUTwards from the element</li>
<li>padding goes IN and squishes the element</li>
<li>LOTS of padding will actually stretch an element out</li>
<li>margins--space between picture and other items</li>
</ul>
</li>
</ul>
<hr>
<h2 id="rly-just-beginning-js">rly just beginning js</h2>
<pre class="hljs"><code><span class="hljs-comment">// Variables</span>

<span class="hljs-comment">// JavaScript uses &quot;lexical&quot; scoping for variables, meaning it matches</span>
<span class="hljs-comment">// a variable based on its name.  &quot;Name&quot; isn&#39;t the same as &quot;name&quot;.</span>

<span class="hljs-comment">// Variables hold values (Numbers, Strings, Arrays, Objects, Functions, Boolean)</span>
<span class="hljs-keyword">var</span> myAge = <span class="hljs-number">39</span>
<span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#39;Jared&#39;</span>
<span class="hljs-keyword">var</span> myKids = [<span class="hljs-string">&#39;Isaac&#39;</span>,<span class="hljs-string">&#39;Abbi&#39;</span>,<span class="hljs-string">&#39;Natalia&#39;</span>,<span class="hljs-string">&#39;Camila&#39;</span>,<span class="hljs-string">&#39;Bella&#39;</span>]

<span class="hljs-comment">// Conditional Statements (if/else)</span>

<span class="hljs-comment">// Conditional statements use comparison operators to produce a</span>
<span class="hljs-comment">// Boolean result (true/false)</span>
<span class="hljs-keyword">if</span> (myAge &lt; <span class="hljs-number">20</span>) {
  <span class="hljs-comment">// do something</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (myAge &lt; <span class="hljs-number">40</span>) {

} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// do something else</span>
}

<span class="hljs-comment">// Truthy and Falsy</span>
<span class="hljs-comment">// There are 6 values that are considered &quot;falsy&quot;</span>
<span class="hljs-comment">// &#39;&#39;,0,false,undefined,null,NaN</span>

<span class="hljs-comment">// == vs ===</span>
<span class="hljs-comment">// The double equals will convert the string to a number</span>
<span class="hljs-comment">// The triple equals will return false if the values aren&#39;t</span>
<span class="hljs-comment">// the same type</span>
<span class="hljs-keyword">if</span> (<span class="hljs-string">&#39;42&#39;</span> == <span class="hljs-number">42</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#39;42&#39; == 42&quot;</span>)
}

<span class="hljs-keyword">if</span> (<span class="hljs-string">&#39;42&#39;</span> === <span class="hljs-number">42</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#39;42&#39; === 42&quot;</span>)
}

<span class="hljs-comment">// Function Declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DoubleANumber</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-built_in">console</span>.log(number <em> <span class="hljs-number">2</span>)
}

<span class="hljs-comment">// A function can also return a value</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DoubleANumber2</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">return</span> number </em> <span class="hljs-number">2</span>
}

<span class="hljs-comment">// Function Invocation</span>
DoubleANumber(<span class="hljs-number">10</span>)

<span class="hljs-comment">// If a function returns a value, we save that in a variable</span>
<span class="hljs-keyword">var</span> doubled = DoubleANumber2(<span class="hljs-number">10</span>)
<span class="hljs-built_in">console</span>.log(doubled)

<span class="hljs-comment">// Function Expression</span>

<span class="hljs-comment">// Functions themselves can be stored in a variable</span>
<span class="hljs-keyword">var</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello&quot;</span>)
}

<span class="hljs-comment">// When a function is used in an expression, the function name</span>
<span class="hljs-comment">// isn&#39;t required.  This is called an anonymous function</span>
<span class="hljs-keyword">var</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello&quot;</span>)
}

<span class="hljs-comment">// We&#39;ll see where using anonymous functions is a common</span>
<span class="hljs-comment">// pattern in a future lesson</span>

<span class="hljs-comment">// Scope</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Jared&quot;</span>

<span class="hljs-comment">// A function can access variables declared outside the function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayMyName</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(name)
}

SayMyName()

<span class="hljs-comment">// A function argument is &quot;local&quot; to the function, and &quot;hides&quot;</span>
<span class="hljs-comment">// the outer variable with the same name</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayMyName2</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">console</span>.log(name)
}

SayMyName2(<span class="hljs-string">&quot;John&quot;</span>)

<span class="hljs-comment">// A variabled declared inside the function also &quot;hides&quot; the</span>
<span class="hljs-comment">// outer variable with the same name</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayMyName3</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Bob&quot;</span>
  <span class="hljs-built_in">console</span>.log(name)
}

SayMyName3()

<span class="hljs-comment">// But variables declared inside a function are only</span>
<span class="hljs-comment">// visible inside the function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ShowAge</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>
  <span class="hljs-built_in">console</span>.log(age)
}

<span class="hljs-comment">//console.log(age) // This is an error because &quot;age&quot; isn&#39;t defined</span>

<span class="hljs-comment">// Functions can be &quot;nested&quot; inside of other functions.  Scope works</span>
<span class="hljs-comment">// from the inside-out.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Grandpa</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Grandpa&quot;</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dad</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Dad&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Son&quot;</span>
    }
  }
}

<span class="hljs-comment">// There are two rules to remember with functions</span>
<span class="hljs-comment">// 1. A function can access the the variables declared in outer functions</span>
<span class="hljs-comment">// 2. A function can access those variables even after the outer function</span>
<span class="hljs-comment">//    has been invoked and returned.</span>
<span class="hljs-comment">// A function that has &quot;remembered&quot; these values is called a closure.</span>

<span class="hljs-comment">// Closures</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayMyName</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(firstName + <span class="hljs-string">&#39; &#39;</span> + lastName)
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;All done&#39;</span>)
  <span class="hljs-keyword">return</span> SayMyName;
}

<span class="hljs-keyword">var</span> person = Person(<span class="hljs-string">&#39;Jared&#39;</span>,<span class="hljs-string">&#39;Stark&#39;</span>)
person()

.call(scope, arg1, arg2, etc) <span class="hljs-comment">// takes ARGUMENTS, comma sep</span>
.apply(scope, [arg1, arg2, etc])<span class="hljs-comment">// takes ARRAY of arguments</span>
using .call() or .apply() invokes the <span class="hljs-function"><span class="hljs-keyword">function</span>, <span class="hljs-title">so</span> <span class="hljs-title">no</span> <span class="hljs-title">need</span> <span class="hljs-title">to</span> <span class="hljs-title">invoke</span> <span class="hljs-title">like</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>);
.<span class="hljs-title">bind</span>(<span class="hljs-params"></span>) <span class="hljs-title">does</span> <span class="hljs-title">NOT</span> <span class="hljs-title">invoke</span>, <span class="hljs-title">just</span> <span class="hljs-title">binds</span> <span class="hljs-title">values</span> <span class="hljs-title">prior</span> <span class="hljs-title">to</span> <span class="hljs-title">invocation</span>.
// <span class="hljs-title">this</span> <span class="hljs-title">way</span> <span class="hljs-title">one</span> <span class="hljs-title">can</span> <span class="hljs-title">bind</span> <span class="hljs-title">values</span> <span class="hljs-title">WITHOUT</span> <span class="hljs-title">calling</span> <span class="hljs-title">it</span>, <span class="hljs-title">so</span> <span class="hljs-title">no</span> <span class="hljs-title">need</span> <span class="hljs-title">to</span> <span class="hljs-title">create</span> <span class="hljs-title">another</span> <span class="hljs-title">inner</span> <span class="hljs-title">function</span>
// <span class="hljs-title">and</span> <span class="hljs-title">go</span> <span class="hljs-title">through</span> <span class="hljs-title">lots</span> <span class="hljs-title">of</span> <span class="hljs-title">work</span> <span class="hljs-title">to</span> <span class="hljs-title">avoid</span> <span class="hljs-title">screwing</span> <span class="hljs-title">up</span> <span class="hljs-title">scope</span></span></code></pre><hr>
<h2 id="js-basix">js basix</h2>
<pre class="hljs"><code>object that <span class="hljs-keyword">contains</span> a <span class="hljs-function"><span class="hljs-keyword">function</span></span> = {
  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">return</span>: stuffs
  }
}
<span class="hljs-keyword">call</span>.the(object(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>)</code></pre><ul>
<li><code>arrayName.pop()</code> removes the last item from the array</li>
<li><code>arrayName.push(&quot;item&quot;, &quot;maybeAnotherItem&quot;)</code> adds to the end of the array</li>
<li><code>arrayName[integer] = &quot;item&quot;</code> adds item at this place in array; could leave empty items thusly</li>
<li><code>arrayName.shift()</code> removes FIRST item from array</li>
<li><code>arrayName.unshift(&quot;item&quot;, &quot;more if you want&quot;, &quot;hey why not&quot;)</code> adds to the BEGINNING of array</li>
<li><p><code>arrayName.splice(startingInteger, integerofItemsToRemove, &quot;string&quot;, &quot;item&quot;, &quot;etc&quot;)</code></p>
<p>  // example:
  var bits = [&quot;bots&quot;, &quot;boots&quot;, &quot;bats&quot;, &quot;beets&quot;, &quot;boats&quot;, &quot;bets&quot;]
  bits.splice(2, 2, &quot;wat&quot;, &quot;wuuuuuuuh&quot;)
  // would result in:
  bots boots way wuuuh boats bets</p>
</li>
</ul>
<p>use same method to just remove from an array eg <code>bits.splice(3, 3)</code> would return from the above, <code>bots boots boats bets</code></p>
<p>to move items from one array to another, also splice, like so: <code>var stib = bits.splice(2, 5)</code></p>
<p>this would leave bits unchanged.
2 is the starting index of item to be copied;
5 is the element AFTER the last one to be copied.
can use same method simply to reduce current array (overwrite)</p>
<pre class="hljs"><code><span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>: booleans (so no quotes)
<span class="hljs-keyword">if</span> blahblah
    <span class="hljs-keyword">break</span>;
don<span class="hljs-string">&#39;t know why i&#39;</span>m making a note <span class="hljs-keyword">of</span> <span class="hljs-string">&#39;break.&#39;</span>

whateVaR.toLowerCase(); <span class="hljs-comment">//does that thing that it says it does. WOOWWOWOWOWW</span>
wutTHEfack.toUpperCase(); <span class="hljs-comment">//does the exact opposite of the thing above this line. MIND. BLOWN.</span>

.slice(indexinginteger, firstCharAFTERtheslice) <span class="hljs-comment">// so, second number minus first number equals total characters in the slice</span>
example: <span class="hljs-keyword">var</span> threeLetterPrefix = thatDudesName.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
.slice(singleNumber) would return <span class="hljs-keyword">until</span> the <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> the string.

<span class="hljs-keyword">var</span> blah = whatever.length
<span class="hljs-comment">//returns the length of &#39;whatever&#39;</span></code></pre><p>in the case of true || whatever, whatever will never be checked;
in the casae of false &amp;&amp; whatever, whatever will never be checked.
they are evaluated <em>only when necessary</em>.</p>
<p>expression is kinda like a clause in natural language;
can have nested subclauses, whatnots.
statemets, more like full, complete sentences.</p>
<p>builtin function <code>Number()</code> converts given value to integer. for example:</p>
<pre class="hljs"><code><span class="hljs-tag">var</span> ancient = <span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(prompt(<span class="hljs-string">&#39;how many milliseconds have you been alive?&#39;</span>)</span></span>, <span class="hljs-string">&#39;&#39;</span>))
<span class="hljs-function"><span class="hljs-title">alert</span><span class="hljs-params">(<span class="hljs-string">&#39;you&#39;</span>re one old sonofabitch, <span class="hljs-string">&quot; + ancient + &quot;</span> is a long freaking time.<span class="hljs-string">&#39;)</span></span></span></code></pre><p>do loop is similar to while, but do will always execute at least once;
it doesn&#39;t test until after the first execution. example:</p>
<pre class="hljs"><code><span class="hljs-operator"><span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">var</span> asdf = <span class="hljs-keyword">prompt</span>(<span class="hljs-string">&quot;what do they call you?&quot;</span>)
  } <span class="hljs-keyword">while</span> (!asdf)
console.<span class="hljs-keyword">log</span>(asdf)
// this will <span class="hljs-keyword">keep</span> prompting <span class="hljs-keyword">until</span> the <span class="hljs-keyword">prompt</span> recieves a <span class="hljs-keyword">string</span></span></code></pre><p>standard loop boilerplate pattern: counter variable to count (duh);
while loop (check counter against limit?) then update counter.</p>
<p>OH WAIT WE CALL THIS A FOR LOOP DUH.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">number</span> &lt;= <span class="hljs-number">26</span>; <span class="hljs-built_in">number</span> = <span class="hljs-built_in">number</span> + <span class="hljs-number">1</span>)
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">number</span>)
<span class="hljs-comment">//0</span>
<span class="hljs-comment">//1</span>
<span class="hljs-comment">//etc, until we are less than or equal to 26.</span></code></pre><ul>
<li>for loop syntax:<ul>
<li>for (bit that initializes the loop, like setting an integer at 0 to count up;</li>
<li>expression check if the loop should still go, like defining a counting limit;</li>
<li>what to do, if we&#39;ve made it through those first bits)</li>
<li>always needs three sections/two semicolons</li>
</ul>
</li>
</ul>
<p><code>+=</code> is not the only thing that works for updating;
looks like all math operations, when done <code>i *= i</code>;
obvs <code>i += i</code> and <code>i -= i</code> can be shortened to <code>i--</code> and <code>i++</code></p>
<p>switch: it&#39;s case, i guess, but minus esac (because, note, we also don&#39;t use done, or fi... wtf).</p>
<p>so:</p>
<pre class="hljs"><code><span class="hljs-keyword">switch</span> (thingy(whatthewhat)) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;oioioi!&quot;</span>:
    alert(<span class="hljs-string">&quot;OI! OI! OI!&quot;</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;blaahh&quot;</span>:
    whatever
  <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">default</span>:
    console.log(<span class="hljs-string">&quot;u r a bag of dix&quot;</span>)
  <span class="hljs-keyword">break</span>
}</code></pre><p>functions always have curly braces around body, even if just one command</p>
<p>braces are allowed everywhere but only define a new local environment within functions,
and only really useful for grouping conditionals and loops</p>
<p>like any other variable, functions can totally get new names.
their values are just as mutable as any other vars&#39;.</p>
<p>use brackets when accessing vague proprop (eg looping over) from object;
otherwise dot notation if know specific key</p>
<p>NOT <code>for i in arr.length whatever</code></p>
<p>....</p>
<p>rather,
<code>return arr[arr.length -1]</code></p>
<pre class="hljs"><code><span class="hljs-comment">//GLOBAL SCOPE</span>
<span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFunction</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">//LOCAL SCOPE FOR OUTERFUNCTION</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunction</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">//LOCAL SCOPE INNERFUNCTION</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;hello&#39;</span>;
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnOne</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-keyword">var</span> myNewFunction = outerFunction();
myNewFunction();
myNewFunction();
<span class="hljs-keyword">var</span> numOne = returnOne();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//local scoped makeCounter and children</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCounter</span><span class="hljs-params">()</span> </span>{
    counter++;
  }
}

<span class="hljs-keyword">var</span> count = makeCounter();
count(); <span class="hljs-comment">//return 1</span>
count(); <span class="hljs-comment">//return 2</span>
<span class="hljs-keyword">var</span> count = makeCounter();

<span class="hljs-keyword">var</span> secondCount = makeCounter();
secondCount() <span class="hljs-comment">//return 1</span></code></pre><p>a closure references variables OUTSIDE OF ITSELF
and remembers those even when its parent scope (parent function) has returned</p>
<p>remember, don&#39;t need to do
<code>if whatever == true/if whatever != true (or == false)</code>
just need to do</p>
<pre class="hljs"><code>if<span class="hljs-function"> (</span>whatever<span class="hljs-function">)</span><span class="hljs-instruction">
return </span>true
else<span class="hljs-instruction">
return </span>false
<span class="hljs-keyword">.</span>..<span class="hljs-instruction"> and </span>that&#39;s all.


// reversing an<span class="hljs-instruction"> array </span>without using<span class="hljs-function"> array.reverse(</span><span class="hljs-function">)</span> ...
function<span class="hljs-function"> flipIt(</span>arr<span class="hljs-function">)</span>{
  var flipped =<span class="hljs-instruction"> new </span>Array
 <span class="hljs-function"> for(</span>var i = arr.length-1; i &gt;= 0; i--<span class="hljs-function">)</span>{
   <span class="hljs-function"> flipped.push(</span>arr<span class="hljs-keyword">[</span>i]<span class="hljs-function">)</span>
  }
 <span class="hljs-instruction"> return </span>flipped
}</code></pre><hr>
<h2 id="ajax-jquery-snippets">ajax (jquery) snippets</h2>
<pre class="hljs"><code>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> app = $(<span class="hljs-string">&#39;app&#39;</span>)
  <span class="hljs-keyword">var</span> header = $(<span class="hljs-string">&#39;&lt;h3&gt;Random Colour Palette&lt;/h3&gt;&#39;</span>)
  <span class="hljs-keyword">var</span> button = $(<span class="hljs-string">&#39;&lt;button&gt;Colours!&lt;/button&gt;&#39;</span>)
  <span class="hljs-keyword">var</span> clear = $(<span class="hljs-string">&#39;&lt;button&gt;New ones!&lt;/button&gt;&#39;</span>)
  <span class="hljs-keyword">var</span> list = $(<span class="hljs-string">&#39;&lt;ul&gt;&lt;/ul&gt;&#39;</span>)
  button.on(<span class="hljs-string">&#39;click&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    $.ajax({
      method: <span class="hljs-string">&#39;GET&#39;</span>,
      url:<span class="hljs-string">&#39;<a href="http://www.colourlovers.com/api/palettes/random?format=json">http://www.colourlovers.com/api/palettes/random?format=json</a>&#39;</span>,
    }).then(data){
      <span class="hljs-keyword">var</span> dataObj = <span class="hljs-built_in">JSON</span>.parse(data)
      showData(dataObj)
    })
  }

  app.append(header)
  app.append(button)
  app.append(clear)
  app.append(palette)

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showData</span>(<span class="hljs-params">data</span>)</span>{
    <span class="hljs-keyword">var</span> image = indexOf(<span class="hljs-string">&#39;imageUrl&#39;</span>)
    <span class="hljs-keyword">var</span> paletteDiv = $(<span class="hljs-string">&#39;&lt;div&gt;&lt;/div&gt;&#39;</span>)
    <span class="hljs-comment">//    var image = $(image tag  + url)</span>

    pallet.append(paletteDiv)
  }

})</code></pre><hr>
<h2 id="toy-problem-notes-week-two">toy problem notes, week two</h2>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkEvens</span>(<span class="hljs-params"> num </span>) </span>{
  <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {    <span class="hljs-comment">// this just checks if the argument passed is divisible by two</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareLengths</span>(<span class="hljs-params"> originalArr, newArr </span>) </span>{
  <span class="hljs-keyword">if</span> (originalArr &gt; newArr) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;More odds than evens.&#39;</span>   <span class="hljs-comment">// this is pretty self-explanitory</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (originalArr &lt; newArr) { <span class="hljs-comment">// just comparing lengths (whodathunkit)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;More evens than odds.&#39;</span>   <span class="hljs-comment">// and returning based on which is longer</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;Same number of evens and odds&#39;</span>
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">howMany</span>(<span class="hljs-params"> originalArr, newArr, evensOrOdds </span>) </span>{
  <span class="hljs-keyword">if</span> (evensOrOdds === <span class="hljs-string">&#39;More odds than evens.&#39;</span>) {
    <span class="hljs-keyword">var</span> length = originalArr.length - newArr.length <span class="hljs-comment">// this is the bit where things are</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;There are &#39;</span> + length + <span class="hljs-string">&#39; more odds than evens.&#39;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (evensOrOdds === <span class="hljs-string">&#39;More evens than odds.&#39;</span>) {
    <span class="hljs-keyword">var</span> length = newArr.length - (originalArr.length - newArr.length)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;There are &#39;</span> + length + <span class="hljs-string">&#39; more evens than odds.&#39;</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;There are the same number of evens and odds.&#39;</span>)
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCallbacks</span>(<span class="hljs-params"> iterator, lengthCompare, counter, arr </span>) </span>{
  <span class="hljs-keyword">var</span> newArray = []                      <span class="hljs-comment">// hey hey hey, a sweet new array</span>
  arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> num, index </span>) </span>{   <span class="hljs-comment">// let&#39;s loop over the old array first</span>
    <span class="hljs-keyword">if</span> (checkEvens(num)) {               <span class="hljs-comment">// see if them items is %2===0</span>
      newArray.push(checkEvens(num))     <span class="hljs-comment">// if they is... i can&#39;t keep that up...</span>
    }                                    <span class="hljs-comment">// we just push them to the new array.</span>
  })
  <span class="hljs-keyword">var</span> evensOrOdds = lengthCompare(arr, newArray) <span class="hljs-comment">// we compare lengths of the old array and new array</span>
  counter(arr, newArray, evensOrOdds)            <span class="hljs-comment">// we pass the old array, the new array, and the variable above</span>
}                                                <span class="hljs-comment">// to the parameter from the top of this function</span>

<span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ,<span class="hljs-number">3</span> ,<span class="hljs-number">4</span> ,<span class="hljs-number">5</span> ,<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>] <span class="hljs-comment">// oh, HERE&#39;s that array we keep talking about</span>

myCallbacks(checkEvens, compareLengths, howMany, myArray) <span class="hljs-comment">// let&#39;s invoke that function and pass it ALL THE THINGS</span></code></pre><hr>
<h2 id="something-about-some-twitter-clone-thing">something about some twitter clone thing</h2>
<h3 id="do-this">do this</h3>
<ul>
<li>hide tweet button and character count initially (so, just not there)</li>
<li>on click, double textarea size, reveal character count and tweet button</li>
<li>ch count decrease realtime</li>
<li>at 10 chars, count turns red</li>
<li>if chars &gt; 140, disable tweet button (and re-enable if =&lt; 140)</li>
<li>new tweet pushed to column immediately, w/ prof image in top left, full username and name</li>
<li>tweet actions on :hover over individual tweets only</li>
<li>rt/timestamp/reply area hidden by default; expand on click</li>
<li>timestamps with timeago (or, i think, livestamp actually)</li>
<li>icons for favs/rts in upper right of tweet card</li>
<li>bootstrap tooltips on :hover over avatar</li>
<li>localstorage (or howabout localForage?)</li>
<li>or baas... ... yeah. localforage.</li>
</ul>
<h4 id="notes-on-changes">notes on changes</h4>
<ul>
<li>setting max-viewport is a <em>horrible</em> practice. nixed.</li>
<li>normalize instead of reset; cdn instead of stuck in our own stylesheet.</li>
<li>updated to jquery 2.1.4; cdn instead of in our js directory.</li>
<li>replacing ids with classes, at least for starters... just a few ids in here, sprinkled around </li>
<li><code>page-container</code> = <code>container</code></li>
<li><code>dashboard</code> = <code>dash</code></li>
<li><code>profile-summary</code> = <code>profile</code></li>
<li><code>char-count</code> = <code>count</code></li>
<li><code>tweet-controls</code> = <code>controls</code></li>
<li>because i don&#39;t like to type</li>
</ul>
<h4 id="notes-on-the-process-and-result-">notes on the process (and result)</h4>
<ul>
<li>so it turns out that i&#39;m 99% sure none of us is doing this right. after doing epic battle with</li>
<li>the javascripts, i&#39;ve been defeated. manually moving the first tweet down and putting the new</li>
<li>tweet&#39;s content in its place, right now, kind of relies solely on using the actual username/name</li>
<li>of the former top tweet on the feed (btw, css could probably use an update... twitter&#39;s one column</li>
<li>of user and tweets, and two side columns of promos and ads, now.). that&#39;s, uh, totally unrealistic.</li>
</ul>
<hr>
<h2 id="murr-nuutes">murr nuutes</h2>
<pre class="hljs"><code><span class="hljs-comment">// make a loop. then have it go 1-5 endlessly. then have it only do it once.</span>

<span class="hljs-comment">// our way</span>
<span class="hljs-comment">// function count () {</span>
<span class="hljs-comment">//   while (true) {</span>
<span class="hljs-comment">//    for (i = 1; i &lt;= 5; i++) {</span>
<span class="hljs-comment">//      console.log(i);</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// correct way</span>
<span class="hljs-comment">// function countOnce () {</span>
<span class="hljs-comment">//   for (var i = 0; i &lt; 1; i++) {</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">5</span>) {
      <span class="hljs-keyword">return</span> num++;
    } <span class="hljs-keyword">else</span> {
      num = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> num;
    }
  };
}
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// other way</span>

<span class="hljs-comment">// function makeCounter() {</span>
<span class="hljs-comment">//  var x = 1;</span>
<span class="hljs-comment">//  retrun function() {</span>
<span class="hljs-comment">//    console.log(x1);</span>
<span class="hljs-comment">//    x++;</span>
<span class="hljs-comment">//    if (x&gt;5) {</span>
<span class="hljs-comment">//      x=0;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">// }</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> counter2 = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCounter</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (counter2 &gt; <span class="hljs-number">11</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counter === <span class="hljs-number">6</span>) {
      counter = <span class="hljs-number">0</span>;
    }
    counter2++;
    <span class="hljs-keyword">return</span> counter++;
  };
}

<span class="hljs-comment">// Objects: less primitive than primitives.</span>
<span class="hljs-comment">// create an object literal that models a facebook message:</span>

<span class="hljs-comment">// var fbMsg = {</span>
<span class="hljs-comment">//    sender: &#39;Jack&#39;;</span>
<span class="hljs-comment">//    recipient: &#39;Jill&#39;;</span>
<span class="hljs-comment">//    topic: [&#39;water&#39;, &#39;pail&#39;, &#39;hill&#39;, &#39;cranial trauma&#39;]</span>
<span class="hljs-comment">//    }</span>

<span class="hljs-comment">// or, using new Object();</span>

<span class="hljs-keyword">var</span> fbMsg = { };
fbMsg.sender = <span class="hljs-string">&#39;Jack&#39;</span>;
fbMsg.recipient = <span class="hljs-string">&#39;Jill&#39;</span>;
fbMsg.topic = [<span class="hljs-string">&#39;water&#39;</span>, <span class="hljs-string">&#39;pail&#39;</span>, <span class="hljs-string">&#39;hill&#39;</span>, <span class="hljs-string">&#39;cranial trauma&#39;</span>];

<span class="hljs-comment">// removing from object, much less work than in array</span>

<span class="hljs-keyword">delete</span> message.recipient;

<span class="hljs-comment">// brackets also work for accessing properties on an object</span>

fbMsg[<span class="hljs-string">&#39;fuzzy date&#39;</span>] = <span class="hljs-string">&#39;yesterday afternoon&#39;</span>;

<span class="hljs-comment">// for loops over keys/values in an object:</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> fbMsg) {
  <span class="hljs-built_in">console</span>.log(key);
}

<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> fbMsg) {
  <span class="hljs-built_in">console</span>.log(fbMsg[value]);
}

<span class="hljs-comment">// you don&#39;t really NEED to declare that something&#39;s a variable...</span>
<span class="hljs-comment">// that&#39;s bad practice, though. that&#39;ll make your whatever a global variable.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// there are no constants in javascrpt, apparently.</span>
<span class="hljs-comment">// so, js isn&#39;t really modular. and scripts included in html will basically</span>
<span class="hljs-comment">// just override in loading order. so, a script tag by the footer would</span>
<span class="hljs-comment">// override one that&#39;s all the way up at the beginning of your body, if they</span>
<span class="hljs-comment">// had the same globals, for example.</span>

<span class="hljs-comment">// wrapping an entire function (even anonymous) in parens is a sweet idea!</span>
<span class="hljs-comment">// this way you&#39;re not polluting global namespace, and you can just</span>
<span class="hljs-comment">// invoke the &#39;function expression&#39; immediately, so it&#39;s not really any</span>
<span class="hljs-comment">// different in practice than as if you&#39;d left off the parents. so...</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> yo = <span class="hljs-string">&#39;billybob&#39;</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;what up &#39;</span> + yo);
})();(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> yo = <span class="hljs-string">&#39;margie-jo&#39;</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;what up &#39;</span> + yo);
})();

<span class="hljs-comment">// i guess a lot of minifiers will automatically just wrap all your scripts</span>
<span class="hljs-comment">// in these kind of expressions?</span>

<span class="hljs-comment">// a function is an object. it has a property called prototype.</span>
<span class="hljs-comment">// the keys of prototype (which is an object itself) are inhereted by any other</span>
<span class="hljs-comment">// object below that one.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// one can add to a prototype after declaring that function.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// a prototype describes the idea of a thing; here&#39;s all the things that would</span>
<span class="hljs-comment">// be in a facebook message, y&#39;know? so this way, we just made a CONSTRUCTOR.</span>
<span class="hljs-comment">// and there&#39;s your use for the new Object syntax! now we know how to use that.</span>
<span class="hljs-comment">//</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Message</span>(<span class="hljs-params">sender, recipient, topic</span>) </span>{
  <span class="hljs-keyword">this</span>.from = sender;
  <span class="hljs-keyword">this</span>.to = recipient;
  <span class="hljs-keyword">this</span>.subject = topic;
}

<span class="hljs-comment">// if you DON&#39;T explicity definte a prototype, you&#39;d get one anyway,</span>
<span class="hljs-comment">// it would basically just be implied/automatic.</span>
<span class="hljs-comment">// readability is a good reason to explicitly define it, though.</span>
<span class="hljs-comment">// also, you can set values in your prototype, obvs, that&#39;ll then be applied</span>
<span class="hljs-comment">// to all the stuffs that uses that prototype.</span>

<span class="hljs-comment">// // so we could also go ahead and comment out all that like so</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Message</span>(<span class="hljs-params"></span>) </span>{
}

Message.prototype = {
  to: <span class="hljs-string">&#39; &#39;</span>,
  from: <span class="hljs-string">&#39; &#39;</span>,
  about: <span class="hljs-string">&#39; &#39;</span>,
  date: <span class="hljs-string">&#39; &#39;</span> <span class="hljs-comment">// note no comma on this line</span>
};        <span class="hljs-comment">// also note that this could return stuff in ANY GODDAMN ORDER.</span>

<span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">new</span> Message (<span class="hljs-string">&#39;joe&#39;</span>, <span class="hljs-string">&#39;ruth&#39;</span>, <span class="hljs-string">&#39;pickles and cream cheese&#39;</span>);
<span class="hljs-keyword">var</span> mssg - <span class="hljs-keyword">new</span> Message (<span class="hljs-string">&#39;ann&#39;</span>, <span class="hljs-string">&#39;barb&#39;</span>, <span class="hljs-string">&#39;i hear joe eats some weird stuff&#39;</span>);
<span class="hljs-built_in">console</span>.log(msg, mssg);

<span class="hljs-comment">// this will make each one basically have the same structure (oh! prototype)</span>
<span class="hljs-comment">// is basically a framework for building objects!), but each INSTANCE is a</span>
<span class="hljs-comment">// totally different actual object. okay.</span>

<span class="hljs-comment">// the keyword this: this.thing, etc... this just references the new (current</span>
<span class="hljs-comment">// parent) object, that&#39;s all!</span>

<span class="hljs-comment">// okay. a method is a property containing a function definition. that sounds</span>
<span class="hljs-comment">// more complicated than it needs to. a method is kind of like a little</span>
<span class="hljs-comment">// function that works just on an object, i guess.</span>
<span class="hljs-comment">// or, in other words, it&#39;s literally just a property, the value of which</span>
<span class="hljs-comment">// happens to be a function.</span>

<span class="hljs-comment">// okay, and so as was just cleared up, things that use the notation that</span>
<span class="hljs-comment">// makes me think they&#39;re just being confusing and shit? yeah. basically just</span>
<span class="hljs-comment">// properties of the string object, or the window object, or the browser</span>
<span class="hljs-comment">// object, or the global (in node) object.</span>

<span class="hljs-comment">// but wait. what about node, really, seriously? i mean, is global the same</span>
<span class="hljs-comment">// as browser? or window? because those are actual structures that would need</span>
<span class="hljs-comment">// to be emulated, right? um... i&#39;ll want to ask our lecturer this, though</span>
<span class="hljs-comment">// chances are we&#39;ll actually be getting to this in a few weeks.</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// ARRAYS</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// Length of an array is how many items. In arrays, order matters (unlike objects).</span>



<span class="hljs-comment">// snippet for reversing strings, because we apparently don&#39;t have a builtin</span>
<span class="hljs-comment">// for this, exactly...</span>
<span class="hljs-keyword">var</span> reversed
  , name = <span class="hljs-string">&quot;zac anger&quot;</span>;

reversed = name.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>);
<span class="hljs-keyword">return</span>(reversed);

<span class="hljs-comment">//</span>
<span class="hljs-comment">// THIS</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// <code>this</code> is not assigned a value until an <em>object</em> invokes the <em>function</em></span>
<span class="hljs-comment">// where <code>this</code> is defined.</span>
<span class="hljs-comment">// So, while it seems (to me, and I guess to others) that <code>this</code> refers to the</span>
<span class="hljs-comment">// object, it&#39;s not until an object invokes a function that <code>this</code> is</span>
<span class="hljs-comment">// actually assigned a value. The actual <em>value</em> is <strong>only</strong> based on which</span>
<span class="hljs-comment">// object invoked said function. <code>this</code> has the value of the invoking object</span>
<span class="hljs-comment">// in most cases. sometimes it does not.</span>

<span class="hljs-comment">// IMPLICIT is the value attached to a keyword when it refers to an object</span>
<span class="hljs-comment">// and it applies to the PARENT object</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// EXPLICIT (call, apply, bind)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// DEFAULT (window object)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// NEW in creation of new objects</span>

<span class="hljs-comment">// To mantain <code>this</code> inside anonymous functions, we can set the value</span>
<span class="hljs-comment">// before entering all that forEach bidnez.</span>
<span class="hljs-comment">// eg var that = this ... lol</span>

<span class="hljs-keyword">var</span> arrOne = [<span class="hljs-number">1</span>, <span class="hljs-number">44</span>, <span class="hljs-number">7</span>, <span class="hljs-number">89</span>];
<span class="hljs-keyword">var</span> arrTwo = [<span class="hljs-number">44</span>, <span class="hljs-number">2</span>, <span class="hljs-number">19</span>, <span class="hljs-number">21</span>, <span class="hljs-number">37</span>, <span class="hljs-number">1</span>];
<span class="hljs-keyword">var</span> arrThree = [<span class="hljs-number">56</span>, <span class="hljs-number">19</span>, <span class="hljs-number">44</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">89</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayItUp</span>(<span class="hljs-params">arrOne, arrTwo, arrThree</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i =&gt; arrOne.length; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j =&gt; arrTwo.length; j++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k =&gt; arrThree.length; k++) {
        <span class="hljs-keyword">if</span> (arrOne[i] === arrTwo[j] &amp;&amp; arrOne[i] === arrThree[k]);
        arrFour.push(arrOne[i]);
      }
    }
  }
  <span class="hljs-keyword">return</span> arrFour;
}
arrayItUp(arrOne, arrTwo, arrThree);

<span class="hljs-comment">// all of this could&#39;ve just been basically a foreach loop... and avoided</span>
<span class="hljs-comment">// the scope problems... crap.</span>


<span class="hljs-comment">//</span>
<span class="hljs-comment">// back to <code>this</code></span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// because it&#39;s better to keep methods and their objects/properties together in</span>
<span class="hljs-comment">// the same model, one can always go ahead and make a method over there, and</span>
<span class="hljs-comment">// then include that method as the value to a key under the object. that way</span>
<span class="hljs-comment">// you&#39;ve got modularity of a sort, but also keeping your models together in</span>
<span class="hljs-comment">// one place.</span>
<span class="hljs-comment">// so defining it in one place and then pointing to it in a second and maybe</span>
<span class="hljs-comment">// invoking it in a third? it&#39;s still going to point to that <em>function</em> that</span>
<span class="hljs-comment">// called it (or, rather, that function&#39;s object).</span>
<span class="hljs-comment">// may be important, because he&#39;s said this several times now:</span>
<span class="hljs-comment">// &#39;we want our models to represent the real world.&#39; and...</span>
<span class="hljs-comment">// &#39;we want the behaviors that represent our models to be with those models.&#39;</span>
<span class="hljs-comment">// i suppose this is more expressive? either way, it&#39;s obvious how it&#39;d be</span>
<span class="hljs-comment">// much easier to maintain and scale.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// .call is ONLY on a function, yo.</span>
<span class="hljs-comment">// .apply works identically to call, except in how one passes in parameters.</span>
<span class="hljs-comment">// first argument is <em>always</em> what <code>this</code> is bound to... which to use depends</span>
<span class="hljs-comment">// on how you intend to pass in parameters.</span>
<span class="hljs-comment">// btw, <code>arguments</code> is actually a keyword, apparently--for use in functions,</span>
<span class="hljs-comment">// it provides an array of all the passed parameters.</span>
<span class="hljs-comment">// but with .call, the second argument is a comma sep list;</span>
<span class="hljs-comment">// .call and .apply invoke the function immediately. .bind dooesn&#39;t. instead,</span>
<span class="hljs-comment">// it kind of makes a new function for you. that&#39;s actually super cool!</span>
<span class="hljs-comment">// OKAY OKAY wait. so. both call and apply are functions  that can ONLY be</span>
<span class="hljs-comment">// called on other functions! The one difference here is that call accepts both</span>
<span class="hljs-comment">// a first argument AND ANY ADDITIONAL ARGUMENTS THA ARE PASSED TO IT.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// okay, here&#39;s a new example.</span>

<span class="hljs-keyword">var</span> car = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doors, model, make</span>) </span>{
  <span class="hljs-keyword">this</span>.doors = doors
  <span class="hljs-keyword">this</span>.make = make
  <span class="hljs-keyword">this</span>.model = model
  <span class="hljs-keyword">return</span>
}

car.call (car, <span class="hljs-number">2</span>, <span class="hljs-string">&#39;Hyundai&#39;</span>, <span class="hljs-string">&#39;Equus&#39;</span>);

<span class="hljs-comment">// so this is actually just a super roundabout way (in this simplified example)</span>
<span class="hljs-comment">// to do a constructor functon, i guess.</span>


<span class="hljs-comment">// okay, so the NEW keyword! var blah = new Blah(thing2 thing2);</span>
<span class="hljs-comment">// but javascript IMPLICITLY does that, and IMPLICITY returns things for you,</span>
<span class="hljs-comment">// and so makes things easier for you. HOWEVER, <code>new</code> is actually a shortcut</span>
<span class="hljs-comment">// for you. but don&#39;t do that. it&#39;s not pretty, and it&#39;s not nice.</span>
<span class="hljs-comment">// there&#39;s a thing that&#39;s like if (this instanceof Foo) or so, which will aid</span>
<span class="hljs-comment">// in avoiding using the window/browser/global object. syntax is super fuzzy</span>
<span class="hljs-comment">// though.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// currying: providing missing paramaters, some or all, when you call BIND.</span>
<span class="hljs-comment">// it will not override anything. so:</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">what</span>(<span class="hljs-params">one, two</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;oi! &#39;</span> + one);
}

<span class="hljs-keyword">var</span> huh = { meh: <span class="hljs-string">&#39;yo&#39;</span> }; meh.what(); (two);

<span class="hljs-comment">// so with apply, those other parameters after the first, you&#39;d better get</span>
<span class="hljs-comment">// them into an array.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// from rey:</span>
<span class="hljs-comment">// The this Keyword</span>
<span class="hljs-comment">// In JavaScript, the thing called this, is the object that &quot;owns&quot; the JavaScript code.</span>
<span class="hljs-comment">//The value of this, when used in a function, is the object that &quot;owns&quot; the function.</span>
<span class="hljs-comment">//The value of this, when used in an object, is the object itself.</span>
<span class="hljs-comment">//The this keyword in an object constructor does not have a value. It is only a substitute for the new object.</span>
<span class="hljs-comment">//The value of this will become the new object when the constructor is used to create an object.</span>
<span class="hljs-comment">//Note     Note that this is not a variable. It is a keyword. You cannot change the value of this.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//<a href="http://www.codeproject.com/Articles/857357/Introduction-to-HTML-WebSockets">http://www.codeproject.com/Articles/857357/Introduction-to-HTML-WebSockets</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API</a> and <a href="http://www.html5rocks.com/en/tutorials/websockets/basics/">http://www.html5rocks.com/en/tutorials/websockets/basics/</a> are some good primers on the websockets topic mentioned a little bit ago; and <a href="https://www.pubnub.com/blog/websockets-vs-rest-api-understanding-the-difference/">https://www.pubnub.com/blog/websockets-vs-rest-api-understanding-the-difference/</a> and <a href="https://news.ycombinator.com/item?id=3636681">https://news.ycombinator.com/item?id=3636681</a> for differences between websockets and http/rest/ajax/xhr/every-other-hacker-news-buzzword.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// ASYNC</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to avoid problems with async functions and synchronous functions causing conflicts</span>
<span class="hljs-comment">// (eg a sync one returning undefined because the async one hasn&#39;t finished yet),</span>
<span class="hljs-comment">// just do callbacks. that makes <strong>sense</strong>, okay!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// worth noting again that setTimeout really isn&#39;t fantastic practice, so maybe just don&#39;t do that...</span>
<span class="hljs-comment">// but if you do, it&#39;s super not difficult, so don&#39;t make it difficult.</span>
<span class="hljs-comment">// just put in a function (which can obviously just be calling something defined elsewhere), and the</span>
<span class="hljs-comment">// time (in milliseconds, which can also be calculated elsewhere). that&#39;s all.</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doThatThing</span>(<span class="hljs-params">arr</span>)</span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-string">&#39;Hello &#39;</span> + arr + <span class="hljs-string">&#39;, how are you?&#39;</span>);
}
setTimeout(doThatThing, <span class="hljs-number">1000</span>);

<span class="hljs-comment">// ask:</span>
<span class="hljs-comment">// would it be harmful to think of underscore (or functional javascript in general) as</span>
<span class="hljs-comment">// being modular libraries/modules? (because javascript, at least in the browser, is not</span>
<span class="hljs-comment">// inherently modular -- no more so than it is inherently functional, object-oriented,</span>
<span class="hljs-comment">// or anything else... it&#39;s dynamic and multi-paradigm).</span>

<span class="hljs-comment">// order.updateTotal();</span>
<span class="hljs-comment">// console.log(order.total.bind();</span>

<span class="hljs-comment">// he uses &#39;self&#39;; we could just as easily use &#39;that&#39; or whatever <code>var foo = this.bar</code></span>
<span class="hljs-comment">// ... or we could not, also.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Functions as parameters</span>

<span class="hljs-comment">// Create a function that calculates 10% tax</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateTax</span>(<span class="hljs-params">amount</span>) </span>{
  <span class="hljs-keyword">return</span> amount <em> <span class="hljs-number">0.10</span>;
}

<span class="hljs-comment">// Create a function that takes in an order amount calculates total</span>
<span class="hljs-comment">// including tax</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateTotal</span>(<span class="hljs-params">amount</span>) </span>{
  <span class="hljs-keyword">return</span> amount + calculateTax(amount);
}

<span class="hljs-keyword">var</span> orderTotal = calculateTotal(<span class="hljs-number">10.00</span>);
<span class="hljs-built_in">console</span>.log(orderTotal);

<span class="hljs-comment">// Create a function that calculates 7% tax for Utah</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateUtahTax</span>(<span class="hljs-params">amount</span>) </span>{
  <span class="hljs-keyword">return</span> amount </em> <span class="hljs-number">0.07</span>;
}

<span class="hljs-comment">// Update calculateTotal to include a state parameter use</span>
<span class="hljs-comment">// the new utah calculator when the state is Utah</span>
calculateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">amount, state</span>) </span>{
  <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#39;Utah&#39;</span>) {
    <span class="hljs-keyword">return</span> amount + calculateUtahTax(amount);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> amount + calculateTax(amount);
  }
};

orderTotal = calculateTotal(<span class="hljs-number">20</span>, <span class="hljs-string">&#39;Utah&#39;</span>);
<span class="hljs-built_in">console</span>.log(orderTotal);

<span class="hljs-comment">// Q: What are some potential problems with this method?</span>
<span class="hljs-comment">// Q: What if tax calculation for Utah is based on county?</span>
<span class="hljs-comment">// Q: What if we need to calculate for other states?</span>

<span class="hljs-comment">// Update the calculateTotal to accept a function</span>
<span class="hljs-comment">// as a parameter that can calculate tax</span>
calculateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">amount, taxCalculator</span>) </span>{
  <span class="hljs-keyword">return</span> amount + taxCalculator(amount);
};


<span class="hljs-comment">// Invoke calculateTotal with both calculateTax functions</span>
orderTotal = calculateTotal(<span class="hljs-number">30</span>, calculateUtahTax);
<span class="hljs-built_in">console</span>.log(orderTotal);

<span class="hljs-comment">// Q: What is better about this approach?</span>


<span class="hljs-comment">// Create a another function called GetTaxCalculator</span>
<span class="hljs-comment">// that takes state as a parameter and returns the</span>
<span class="hljs-comment">// correct tax calculator</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetTaxCalculator</span>(<span class="hljs-params"></span>) </span>{

}

<span class="hljs-comment">// Q: If we add new tax calculators, what code will need to be updated?</span>

<span class="hljs-comment">// Using functions as arguments to other functions is one way we can</span>
<span class="hljs-comment">// get results from an asynchronous function.</span>

<span class="hljs-comment">// Asynchronous &amp; functions as callbacks</span>

<span class="hljs-comment">// Create a function called done, that writes done to the console</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">done</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;done&#39;</span>);
}

<span class="hljs-comment">// Use setTimeout and pass the done function as the callback</span>
setTimeout(done, <span class="hljs-number">2000</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;after setTimeout&#39;</span>);

<span class="hljs-comment">// Q: Why does &#39;after setTimeout&#39; display before &#39;done&#39;?</span>


<span class="hljs-comment">// Create a function called getColors that uses setTimeout to simulate</span>
<span class="hljs-comment">// an asynchronous call to a web server that returns an array of colors</span>
<span class="hljs-keyword">var</span> getColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//console.log(&#39;Returning colors...&#39;);</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#39;Red&#39;</span>,<span class="hljs-string">&#39;Blue&#39;</span>,<span class="hljs-string">&#39;Purple&#39;</span>,<span class="hljs-string">&#39;Black&#39;</span>];
  },<span class="hljs-number">500</span>);
};


<span class="hljs-comment">// Q: What will the value of colors be? Why?</span>
<span class="hljs-keyword">var</span> colors = getColors();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;Colors: &#39;</span> + colors);

<span class="hljs-comment">// Update getColors to solve the problem by using a callback</span>
getColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">displayColors</span>) </span>{

  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    displayColors([<span class="hljs-string">&#39;Red&#39;</span>,<span class="hljs-string">&#39;Blue&#39;</span>,<span class="hljs-string">&#39;Purple&#39;</span>,<span class="hljs-string">&#39;Black&#39;</span>]);
  },<span class="hljs-number">500</span>);

};
<span class="hljs-comment">// Invoke getColors again using the callback</span>
<span class="hljs-keyword">var</span> displayColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">colors</span>) </span>{
  <span class="hljs-built_in">console</span>.log(colors);
};

getColors(displayColors);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;after getColors&#39;</span>);


<span class="hljs-comment">// Q: What challenges does asynchronous code create? How does it affect</span>
<span class="hljs-comment">// code readability?</span>
<span class="hljs-comment">// Q: What advantages does it provide?</span>

<span class="hljs-comment">// Create a function called forEach that takes an array as the first parameter, and a function as the second parameter.  The forEach function should loop over the items in the array and invoke the callback function, passing in each item in the array</span>
<span class="hljs-keyword">var</span> forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items, callback</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) {
    callback(items[i]);
  }
};

<span class="hljs-comment">// Create an array of colors</span>
<span class="hljs-keyword">var</span> colors = [<span class="hljs-string">&#39;Red&#39;</span>, <span class="hljs-string">&#39;Blue&#39;</span>, <span class="hljs-string">&#39;Purple&#39;</span>, <span class="hljs-string">&#39;Pink&#39;</span>];

<span class="hljs-comment">// use forEach to loop over the array of colors.  Pass a callback</span>
<span class="hljs-comment">// to forEach that receives a color as a parameter and outputs the</span>
<span class="hljs-comment">// name of the color to the console.</span>
forEach(colors, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">color</span>) </span>{
  <span class="hljs-keyword">return</span> color;
});

<span class="hljs-comment">// Now create an order object that has a total property, and a property called items that is an array containing item prices. Add a method called updateTotal that uses the forEach function to loop over the items and update the total property</span>
<span class="hljs-keyword">var</span> order = {
  total: <span class="hljs-number">0</span>,
  items: [<span class="hljs-number">1.99</span>,<span class="hljs-number">2.50</span>,<span class="hljs-number">9.99</span>],
  updateTotal: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.total = <span class="hljs-number">0</span>;

    forEach(<span class="hljs-keyword">this</span>.items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
      <span class="hljs-keyword">this</span>.total += item;
    });
  }
};

<span class="hljs-comment">// Invoke the updateTotal method and display the order total</span>
order.updateTotal();
<span class="hljs-built_in">console</span>.log(order.total);

<span class="hljs-comment">// Q: Why is the total zero?</span>

<span class="hljs-comment">// Change the updateTotal method to solve the problem using &#39;self&#39;</span>
order.updateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.total = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  forEach(<span class="hljs-keyword">this</span>.items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
    self.total += item;
  });
};

order.updateTotal();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Total using &#39;self&#39;: &quot;</span> + order.total);

<span class="hljs-comment">// Change the updateTotal method to solve the problem using &#39;bind&#39;</span>
order.updateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.total = <span class="hljs-number">0</span>;

  forEach(<span class="hljs-keyword">this</span>.items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
    <span class="hljs-keyword">this</span>.total += item;
  }.bind(<span class="hljs-keyword">this</span>));
};

order.updateTotal();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Total using &#39;bind&#39;: &quot;</span> + order.total);

<span class="hljs-comment">// Change the updateTotal method to solve problem by passing &#39;this&#39;</span>
<span class="hljs-comment">// to forEach</span>
<span class="hljs-comment">// This solution requires updating our forEach function itself and isn&#39;t</span>
<span class="hljs-comment">// always an option</span>

<span class="hljs-comment">// Update forEach to take a 3rd parameter, which is what &#39;this&#39; should</span>
<span class="hljs-comment">// be bound to</span>
forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items, callback, whatThisShouldBe</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) {
    callback.call(whatThisShouldBe, items[i]);
  }
};

<span class="hljs-comment">// Update updateTotal to pass it the order object</span>
order.updateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.total = <span class="hljs-number">0</span>;

  forEach(<span class="hljs-keyword">this</span>.items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
    <span class="hljs-keyword">this</span>.total += item;
  }, <span class="hljs-keyword">this</span>);
};

order.updateTotal();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;Total using update to forEach: &#39;</span> + order.total);


<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// JQUERY</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// things to keep in mind:</span>
<span class="hljs-comment">// css and images will load up to 6 in parl</span>
<span class="hljs-comment">// js will only load in order, once after another</span>
<span class="hljs-comment">// because obviously some things depend on other things</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
.find <span class="hljs-comment">// finds all below</span>
.children <span class="hljs-comment">// finds only direct immediate descendant</span>
<span class="hljs-comment">// this is like nesting in css selectors, basically</span>


<span class="hljs-comment">// dragndrop in jquery:</span>

.on(<span class="hljs-string">&#39;mousedown&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  isPressed = <span class="hljs-literal">true</span>;
}

.on(<span class="hljs-string">&#39;mouseup&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  isPressed = <span class="hljs-literal">false</span>;
})

.on(<span class="hljs-string">&#39;mouseenter&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">if</span>(isPressed) {
    $(<span class="hljs-keyword">this</span>).addClass(color);
  }
})

<span class="hljs-comment">// assuming we&#39;re using that paint example, obvs.</span>

<span class="hljs-comment">// notes on localstorage:</span>
localStorage.setItem(<span class="hljs-string">&#39;key&#39;</span>, <span class="hljs-string">&#39;value&#39;</span>); ==
localStorage.key = <span class="hljs-string">&#39;value&#39;</span>; ==
localStorage[<span class="hljs-string">&#39;key&#39;</span>] = <span class="hljs-string">&#39;value&#39;</span>;

<span class="hljs-keyword">return</span> localStorage.key; ==
<span class="hljs-keyword">return</span> localStorage.getItem(<span class="hljs-string">&#39;key&#39;</span>); ==
<span class="hljs-keyword">return</span> localStorage[<span class="hljs-string">&#39;key&#39;</span>];

<span class="hljs-keyword">delete</span> localStorage.key also works.
;;;;;;;;

<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// AJAX THINGS</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// make data</span>
<span class="hljs-comment">// change data</span>
<span class="hljs-comment">// check data</span>
<span class="hljs-comment">// move data</span>
<span class="hljs-comment">// delete data</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// is there anything else in an application but these five things?</span>
<span class="hljs-comment">// this is a dare, from jeremy. hmmmmmmmmmmm.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// notes: jeremy says to not store drug money data on PCs xD</span>
<span class="hljs-comment">// (because everything is data, data, data, data, data)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Create - POST</span>
<span class="hljs-comment">// Read    - GET</span>
<span class="hljs-comment">// Update - PUT</span>
<span class="hljs-comment">// Delete - DELETE</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">var</span> ajaxParams = {
  method: <span class="hljs-string">&#39;GET&#39;</span>,
  url: <span class="hljs-string">&#39;<a href="http://zacanger.com/blog/feed.rss">http://zacanger.com/blog/feed.rss</a>&#39;</span>,
}


$.ajax(ajaxParams).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>{

})

<span class="hljs-comment">// cyclomatic complexity</span>
<span class="hljs-comment">// more things you&#39;re doing</span>
<span class="hljs-comment">// more bugs</span>
<span class="hljs-comment">//</span></code></pre>]]></description><link>/2016/05/05/notes-from-devmountain-02.html</link><guid isPermaLink="true">/2016/05/05/notes-from-devmountain-02.html</guid><category><![CDATA[devmtn]]></category><category><![CDATA[js]]></category><category><![CDATA[css]]></category><category><![CDATA[angular]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 06:00:00 GMT</pubDate></item><item><title><![CDATA[Promises]]></title><description><![CDATA[<p>Important things:</p>
<ul>
<li>The actual promise is immutable (nothing can change that)</li>
<li>There&#39;s a guarantee that we&#39;ll get something back</li>
<li>Usually create a promise with a constructor (<code>new Promise</code>)</li>
<li>Usually its two handlers are named <code>resolve</code> and <code>reject</code></li>
<li>A promise will have one of three states:<ul>
<li>Pending (until something happens)</li>
<li>Fulfilled (if the first handler is called)</li>
<li>Rejected (if the second handler is called)</li>
</ul>
</li>
<li>It can only be &#39;settled&#39; (either resolved or rejected) once.</li>
<li>Can&#39;t cancel a promise.</li>
<li>No way to check the status (if pending, fulfilled, or rejected).</li>
<li>An immediately-resolved promise can be created like <code>Promise.resolve(&#39;something&#39;)</code>.</li>
<li>An immediately-rejected promise can be created like <code>Promise.reject(&#39;something&#39;)</code>.</li>
<li>Attach a <code>then()</code> to consume the promise.</li>
<li><code>.then</code> takes a callback that gets passed the resolved value, on fulfillment.</li>
<li>It can actually take a rejection callback too.</li>
<li>You can pass in <code>null</code> instead of the first one, which is the same as just doing a <code>.catch()</code>.</li>
<li>You can chain <code>.then()</code>s.</li>
<li>You SHOULD use <code>.catch()</code> instead of the <code>.then(null, cb)</code> style.</li>
<li>This way you can chain multiple <code>then</code>s and then have a final <code>catch</code>.</li>
<li><code>throw</code>ing will automatically reject that promise.</li>
<li><code>Promise.all()</code> takes arr of promises; once all are fulfilled, it returns arr of fulfilled values.<ul>
<li>Otherwise (if any are rejected) it will reject.</li>
</ul>
</li>
<li><code>Promise.race()</code> is similar, but will fulfill once first promise in the array fulfills.</li>
<li>Don&#39;t program with promises using same patterns as with callbacks.<ul>
<li>(Don&#39;t do a <code>.then(fn(res), fn(err))</code>; use <code>.then().catch()</code>.)</li>
</ul>
</li>
<li>Don&#39;t nest promises. Use a <code>.all</code> instead.</li>
</ul>
<p>Examples:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
  <span class="hljs-keyword">if</span> (something) {
    resolve(value)
  } <span class="hljs-keyword">else</span> {
    reject(reason)
  }
})

<span class="hljs-keyword">const</span> p = Promise.resolve(<span class="hljs-string">&#39;something&#39;</span>)
p.then(res =&gt; console.log(res))
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(<span class="hljs-string">&#39;asdf&#39;</span>), <span class="hljs-number">2000</span>)
})
p2.then(res =&gt; {
  res += <span class="hljs-string">&#39;ghjkl;&#39;</span>
  console.log(res)
})
p2.then(res =&gt; console.log(res)) <span class="hljs-comment">// this is still &#39;asdf&#39;</span>

somePromise.then(
  val =&gt; console.log(<span class="hljs-string">&#39;fulfilled&#39;</span>, val)
, err =&gt; console.error(<span class="hljs-string">&#39;rejected&#39;</span>, err))

pr.then(val =&gt; console.log(<span class="hljs-string">&#39;fulfilled&#39;</span>, val))
  .then(<span class="hljs-keyword">null</span>, err =&gt; console.error(<span class="hljs-string">&#39;rejected&#39;</span>, err))

<span class="hljs-keyword">const</span> throwProm = <span class="hljs-keyword">new</span> Promise((res, rej) =&gt; {
  <span class="hljs-keyword">if</span> (something) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#39;rejected&#39;</span>)
  } <span class="hljs-keyword">else</span> {
  resolve(stuff)
  }
})
throwProm
.then(val =&gt; val + <span class="hljs-number">8</span>)
.then(val =&gt; console.log(<span class="hljs-string">&#39;hey&#39;</span>, val))
.<span class="hljs-keyword">catch</span>(err =&gt; console.error(<span class="hljs-string">&#39;err&#39;</span>, err.message))

<span class="hljs-keyword">const</span> fulProm = <span class="hljs-keyword">new</span> Promise((res, rej) =&gt; res(<span class="hljs-number">8</span>))
fulProm
.then(val =&gt; val + <span class="hljs-number">8</span>)
.then(val =&gt; {<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#39;failure&#39;</span>)})
.then(val =&gt; console.log(<span class="hljs-string">&#39;yay&#39;</span>, val))
.<span class="hljs-keyword">catch</span>(err =&gt; console.error(<span class="hljs-string">&#39;error&#39;</span>, err.message))

one()
.then(res =&gt; Promise.all([res, two(res)]))
  .then(results =&gt; <span class="hljs-comment">/<em> stuff </em>/</span>)
  .<span class="hljs-keyword">catch</span>(err =&gt; <span class="hljs-comment">/<em> handle err </em>/</span>)</code></pre>]]></description><link>/2016/05/05/promises.html</link><guid isPermaLink="true">/2016/05/05/promises.html</guid><category><![CDATA[promises]]></category><category><![CDATA[es6]]></category><category><![CDATA[es2015]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 06:00:00 GMT</pubDate></item></channel></rss>