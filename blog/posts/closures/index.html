<!DOCTYPE html><html><head><meta charset="utf-8"/><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/><title>Closures | Zac Anger&#x27;s Blog</title><meta name="description" content="A closure is a local variable for a function, which sticks around after the function has been returned."/><meta name="author" content="Zac Anger"/><meta name="keywords" content="blog,design,javascript,js,music,programming,vim,web development,writing,js,closures,,notes,,closure"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@zacanger"/><meta name="twitter:creator" content="@zacanger"/><meta name="twitter:title" content="Closures"/><meta name="twitter:description" content="A closure is a local variable for a function, which sticks around after the function has been returned."/><meta name="twitter:image" content="http://zacanger.com/logo.png"/><meta property="og:type" content="article"/><meta property="og:title" content="Closures"/><meta property="og:description" content="A closure is a local variable for a function, which sticks around after the function has been returned."/><meta property="og:site_name" content="http://zacanger.com/blog"/><meta property="og:image" content="http://zacanger.com/logo.png"/><script type="text/javascript" href="/blog/assets/highlight.pack.js"></script><link rel="stylesheet" type="text/css" href="/blog/assets/styles.css"/><link rel="stylesheet" type="text/css" href="/blog/assets/github-gist.css"/></head><body><header><h1><a href="/blog">Zac Anger&#x27;s Blog</a></h1><h2>Closures</h2><div>02 February, 2016</div></header><div><div><p>A closure is a local variable for a function, which sticks around after the function has been returned.</p>
<p>(Or, a closure is a stack-frame which is <em>not deallocated</em> when the function returns [as if a 'stack-frame' were malloc'ed instead of being on the stack!]. Whatever that means.)</p>
<p>Here, let's explain in Javascript.</p>
<pre><code class="hljs">function sayHi(name){
  var text = 'hi ' + name // (local var)
    , say  = function(){
    console.log(text)
    return say
  }
}
var sayIt = sayHi('zac')
sayIt() // returns 'hi zac'
</code></pre>
<p>So here, a function is returned as a variable.</p>
<p>What we're doing here is putting a function inside a function. And we're getting something accessible outside of that enclosing function, right?</p>
<p>Hence <em>closure</em>.</p>
<p>In most descendants of C, after a function returns, its local variables are <em>gone</em>. The stack-frame is gone.</p>
<p>In JS, functions that are inside other functions can still be accessed outside of (after) that parent function. Try using the above code, and then doing <code>sayIt.toString()</code>, and you'll see that the variable <code>say</code> is returned -- which is a function that references <code>text</code>, which is a variable local to <code>sayHi()</code>.</p>
<pre><code class="hljs">function oneMore(){
  var i     = 1
    , logIt = function(){
    console.log(i)
  }
  i++
  return logIt
}
var logStuff = logIt()
oneMore() // 2
</code></pre>
<p>Make sense? Here's a slightly more complex example pulled straight from the interwebs.</p>
<pre><code class="hljs">var logNumber, increaseNumber, setNumber
function setupGlobals(){
  var i = 4
  logNumber = function(){
    console.log(i)
  }
  increaseNumber = function(){
    i++
  }
  setNumber = function(x){
    i = x
  }
}
setupGlobals()
increaseNumber()
logNumber()     // 5
setNumber(8)
logNumber()     // 8
var oldLog = logNumber
setupGlobals()
logNumber()     // 4
oldLog()        // 8
</code></pre>
<p>Local variables from a closure will be overwritten if you call that outer function again. Don't forget this, because you can get some really screwy stuff going on if you do!</p>
<p>There is a closure for <em>every function call</em>, not for every <em>function declaration</em>. This example might help demonstrate this.</p>
<pre><code class="hljs">function newClosure(fooInt, barRef){
  var num     = fooInt
    , quuxArr = [1, 2, 3]
    , ref     = barRef
  return function(x){
    num += x
    quuxArr.push(num)
    console.log('num: ' + num +
      '; quuxArr: ' + quuxArr.toString() +
      '; ref.bazVar: ' + ref.bazVar)
  }
}
obj = {bazVar: 4}
fn1 = newClosure(4, obj)
fn2 = newClosure(8, obj)
fn1(1)     // num:5; quuxArr:1,2,3,4,5; ref.bazVar: 4
fn2(1)     // num:9; quuxArr:1,2,3,8; ref.bazVar: 4
obj.bazVar++ // 4
fn1(2)     // num:7; quuxArr:1,2,3,5,7; ref.bazVar:5
fn2(2)     // num:11; quuxArr:1,2,3,9,11; ref.bazVar:5
</code></pre>
<p>So... a quick recap?</p>
<p>When a function is <em>used</em> inside another function, you've used a <em>closure</em>. This includes <code>eval()</code>. (Note that using a constructor, as in <code>new Function()</code>, does <em>not</em> create a closure.)</p>
<p>Every time you call a function with a closure, it makes a new set of those local variables.</p>
<p>Closures <em>can</em> definitely be nested.</p>
<hr>
<p>And, in a cuter way....</p>
<p>Once upon a time, there was a princess: <code>function princess(){</code>
Who lived in a world full of adventures. There was stuff with unicorns and dragons and a whole range of other wild shenanigans.</p>
<pre><code class="hljs">var adventures = []
function princeCharming(){}
var unicorns   = {}
  , dragons    = {}
  , otherStuff = 'howdy'
</code></pre>
<p>But said princess would eventually always have to <code>return {</code> to the real world, and she'd then talk about all her crazy-awesome princessy adventuring.</p>
<pre><code class="hljs">    story : function(){
      return adventures[adventures.length -1]
    }
  }
}
</code></pre>
<p>Unfortunately all folks would see is some <code>var littleKid = princess()</code> telling a wild <code>littleKid.story()</code>.</p>
<p>Those folks new there were real princesses, but they wouldn't believe in nonsense they couldn't see, and insisted things like <code>unicorns</code> and <code>dragons</code> and <code>otherStuff</code> were all in the <code>littleKid</code>'s head. As it turns out, though, the <code>littleKid</code> with the <code>princess</code> inside...</p>
<p>...is really a <code>princess</code> with a <code>littleKid</code> inside.</p>
</div><p><a href="https://github.com/zacanger/dotcom/issues/new?title=Closures" target="_blank">Submit a bug report</a></p></div><footer>Made by <a href="/">Zac Anger</a><br/><br/><a href="/blog/rss.xml">Feed</a> · <a href="/LICENSE.txt">License</a> · <a href="https://github.com/zacanger">GitHub</a> · <a href="https://twitter.com/zacanger">Twitter</a> · <a href="https://mastodon.social/@zacanger">Mastodon</a></footer></body></html>