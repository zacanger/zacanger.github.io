<!DOCTYPE html>
<html lang="en">

  <head>
    <title>Closures | Zac Anger's Blog</title>
    <meta name="description" content="Closures" />
    <meta name="keywords" content="['js', 'closures,', 'notes,', 'closure']" />
    <meta name="twitter:description" content="Closures" />
    <meta name="twitter:title" content="Closures" />
    <meta property="og:description" content="Closures" />
    <meta property="og:title" content="Closures" />

    <meta charset="utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<meta name="author" content="Zac Anger" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@zacanger" />
<meta name="twitter:creator" content="@zacanger" />
<meta name="twitter:image" content="https://zacanger.com/logo.png" />
<meta property="og:type" content="article" />
<meta property="og:site_name" content="Zac Anger's Blog" />
<meta property="og:image" content="https://zacanger.com/logo.png" />
<link rel="stylesheet" type="text/css" href="/styles.css" />
  </head>

  <body>
    <header>
      <h1><a href="/blog">Zac Anger's Blog</a></h1>
      <h2>Closures</h2>
      <h3>2016-02-02</h3>
      <h4><small>Tags: js, closures,, notes,, closure</small></h4>
    </header>
    <div>
      <p>A closure is a local variable for a function, which sticks around after the
function has been returned.</p>
<p>(Or, a closure is a stack-frame which is <em>not deallocated</em> when the function
returns [as if a 'stack-frame' were malloc'ed instead of being on the stack!].
Whatever that means.)</p>
<p>Here, let's explain in Javascript.</p>
<div class="highlight"><pre><span></span>function sayHi(name){
  var text = &#39;hi &#39; + name // (local var)
    , say  = function(){
    console.log(text)
    return say
  }
}
var sayIt = sayHi(&#39;zac&#39;)
sayIt() // returns &#39;hi zac&#39;
</pre></div>

<p>So here, a function is returned as a variable.</p>
<p>What we're doing here is putting a function inside a function. And we're
getting something accessible outside of that enclosing function, right?</p>
<p>Hence <em>closure</em>.</p>
<p>In most descendants of C, after a function returns, its local variables are
<em>gone</em>. The stack-frame is gone.</p>
<p>In JS, functions that are inside other functions can still be accessed outside
of (after) that parent function. Try using the above code, and then doing
<code>sayIt.toString()</code>, and you'll see that the variable <code>say</code> is returned --
which is a function that references <code>text</code>, which is a variable local to
<code>sayHi()</code>.</p>
<div class="highlight"><pre><span></span>function oneMore(){
  var i     = 1
    , logIt = function(){
    console.log(i)
  }
  i++
  return logIt
}
var logStuff = logIt()
oneMore() // 2
</pre></div>

<p>Make sense? Here's a slightly more complex example pulled straight from the
interwebs.</p>
<div class="highlight"><pre><span></span>var logNumber, increaseNumber, setNumber
function setupGlobals(){
  var i = 4
  logNumber = function(){
    console.log(i)
  }
  increaseNumber = function(){
    i++
  }
  setNumber = function(x){
    i = x
  }
}
setupGlobals()
increaseNumber()
logNumber()     // 5
setNumber(8)
logNumber()     // 8
var oldLog = logNumber
setupGlobals()
logNumber()     // 4
oldLog()        // 8
</pre></div>

<p>Local variables from a closure will be overwritten if you call that outer
function again. Don't forget this, because you can get some really screwy
stuff going on if you do!</p>
<p>There is a closure for <em>every function call</em>, not for every <em>function
declaration</em>. This example might help demonstrate this.</p>
<div class="highlight"><pre><span></span>function newClosure(fooInt, barRef){
  var num     = fooInt
    , quuxArr = [1, 2, 3]
    , ref     = barRef
  return function(x){
    num += x
    quuxArr.push(num)
    console.log(&#39;num: &#39; + num +
      &#39;; quuxArr: &#39; + quuxArr.toString() +
      &#39;; ref.bazVar: &#39; + ref.bazVar)
  }
}
obj = {bazVar: 4}
fn1 = newClosure(4, obj)
fn2 = newClosure(8, obj)
fn1(1)     // num:5; quuxArr:1,2,3,4,5; ref.bazVar: 4
fn2(1)     // num:9; quuxArr:1,2,3,8; ref.bazVar: 4
obj.bazVar++ // 4
fn1(2)     // num:7; quuxArr:1,2,3,5,7; ref.bazVar:5
fn2(2)     // num:11; quuxArr:1,2,3,9,11; ref.bazVar:5
</pre></div>

<p>So... a quick recap?</p>
<p>When a function is <em>used</em> inside another function, you've used a <em>closure</em>.
This includes <code>eval()</code>. (Note that using a constructor, as in <code>new
Function()</code>, does <em>not</em> create a closure.)</p>
<p>Every time you call a function with a closure, it makes a new set of those
local variables.</p>
<p>Closures <em>can</em> definitely be nested.</p>
<hr />
<p>And, in a cuter way....</p>
<p>Once upon a time, there was a princess: <code>function princess(){</code>
Who lived in a world full of adventures. There was stuff with unicorns and
dragons and a whole range of other wild shenanigans.</p>
<div class="highlight"><pre><span></span>var adventures = []
function princeCharming(){}
var unicorns   = {}
  , dragons    = {}
  , otherStuff = &#39;howdy&#39;
</pre></div>

<p>But said princess would eventually always have to <code>return {</code> to the real
world, and she'd then talk about all her crazy-awesome princessy adventuring.</p>
<div class="highlight"><pre><span></span>    story : function(){
      return adventures[adventures.length -1]
    }
  }
}
</pre></div>

<p>Unfortunately all folks would see is some <code>var littleKid = princess()</code> telling
a wild <code>littleKid.story()</code>.</p>
<p>Those folks new there were real princesses, but they wouldn't believe in
nonsense they couldn't see, and insisted things like <code>unicorns</code> and <code>dragons</code>
and <code>otherStuff</code> were all in the <code>littleKid</code>'s head. As it turns out, though,
the <code>littleKid</code> with the <code>princess</code> inside...</p>
<p>...is really a <code>princess</code> with a <code>littleKid</code> inside.</p>
    </div>
    <footer>
  <a href="/">Zac Anger</a>
  &middot; <a href="https://github.com/zacanger/zacanger.github.io">Source</a>
</footer>
  </body>
</html>