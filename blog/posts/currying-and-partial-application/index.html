<!DOCTYPE html>
<html lang="en">

  <head>
    <title>currying and partial application | Zac Anger's Blog</title>
    <meta name="description" content="currying and partial application" />
    <meta name="keywords" content="currying,fp,partial-application,functional-programming,js,blog,zac anger" />
    <meta name="twitter:description" content="currying and partial application" />
    <meta name="twitter:title" content="currying and partial application" />
    <meta property="og:description" content="currying and partial application" />
    <meta property="og:title" content="currying and partial application" />

    <meta charset="utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<meta name="author" content="Zac Anger" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@zacanger" />
<meta name="twitter:creator" content="@zacanger" />
<meta name="twitter:image" content="https://zacanger.com/logo.png" />
<meta property="og:type" content="article" />
<meta property="og:site_name" content="Zac Anger's Blog" />
<meta property="og:image" content="https://zacanger.com/logo.png" />
<link rel="stylesheet" type="text/css" href="/styles.css" />
  </head>

  <body>
    <header>
      <h1><a href="/blog">Zac Anger's Blog</a></h1>
      <h2>currying and partial application</h2>
      <h3>2016-05-05</h3>
      <h4><small>Tags: currying, fp, partial-application, functional-programming, js, blog, zac anger</small></h4>
    </header>
    <hr>
    <div>
      <pre><code class="language-javascript">// Prototype's version?
Function.prototype.curry = function(){
  var fn   = this
    , args = Array.prototype.slice.call(arguments)
  return function(){
    return fn.apply(this, args.concat(Array.prototype.slice.call(arguments)))
  }
}

// Functional's version?
Function.prototype.partial = function(){
  var fn   = this
    , args = Array.prototype.slice.call(arguments)
  return function(){
    var arg = 0
    for (var i = 0; i &lt; args.length &amp;&amp; arg &lt; arguments.length; i++) {
      if (args[i] === undefined) {
        args [i] = arguments[arg++]
      }
      return fn.apply(this, args)
    }
  }
}

// from angus croll's blog
// note, the toArray is because the `arguments` array is actually and object
function toArray(enumm){
  return Array.prototype.slice.call(enumm)
}
// toArray is superfluous now, though, because we can just do
let args = Array.from(arguments)
//
Function.prototype.curry = function(){
  if (arguments.length &lt; 1) {
    return this
  }
  var __ method = this
    , args      = toArray(arguments)
  return function(){
    return __method.apply(this, args.concat(toArray(arguments)))
  }
}
// and an example from his blog, using the above
const
  converter = (ratio, symbol, input) =&gt; [(input * ratio).toFixed(1), symbol].join(' ')
, kgToLb    = converter.curry(2.2, 'lbs')
, liToPi    = converter.curry(1.98, 'pints')
, miToKm    = converter.curry(1.62, 'km')


// note that these are all examples of partial application,
// not true currying as one would have in a purely functional language
// see:
const foo = (a, b) =&gt; a + b
foo.partiallyApply(2) // b =&gt; 2 + b
foo.curry() // a =&gt; b =&gt; a + b
foo.curry()(2) // foo.partiallyApply(2)

Function.prototype.curry = function(){
  var
    method = this
  , i      = 0
  , len    = this.length
  , args   = []

  function f() {
    args.push(arguments[0])
    if (++i &lt; len) {
      return f
    } else {
      method.apply(this, args)
    }
  }
  return f
}

// here's a super simplistic adding thingy
const adder = (a, b) =&gt; typeof(b) !== 'undefined' ? a + b : c =&gt; a + c
// i think the es6 is right for this? in es5 also:
function adder(a, b) {
  if (typeof b !== 'undefined') {
    return a + b
  } else {
    return function(c){
      return a + c
    }
  }
}

// the real difference between partial application and currying:
// a curried function will accept ONLY one argument at a time.
// it will continue accepting one argument each time it's called right
// up until it's got enough, then will finally be executed for realz.

// so: a function that can take a function as input, and an int for
// the max args. should be able to call like so:
curry(fn, n, ...args) // ... that is,
curry(fn, n, 1, 2, 3) // or
curry(fn, n)(1)(2)(3) // or
curry(fn, n)(1, 2, 3) // and we should get the same results each way.
// so
curry(fn, n, 1, 2)(3, 4) == curry(fn, n, 1, 2, 3, 4)

// notes on the below:
// fn.apply(a, [1, 2, 3]) is kinda the same as doing
// fn.call(a, 1, 2, 3), where `a` is `this`
const argsArr = args =&gt; Array.from(args)

const curry = (fn, n) =&gt; {
  const args = argsArr(arguments)
  if (n === args.length -2) {
    return fn.apply(undefined, args.slice(2))
  } else {
    return () =&gt; {
      return curry.apply(undefined, args.concat(arguments))
    }
  }
}
// so try:
const addFour = (a, b, c, d) =&gt; a + b + c + d
curry(addFour, 4, 8, 16)(1, 2)

// modified to use Function.length
const newCurry = (fn, n) =&gt; {
  let args = argsArr(arguments)
  if (typeof(n) == 'undefined') {
    args[1] = fn.length
  }
  if (n === args.length - 2) {
    return fn.apply(undefined, args.slice(2))
  }
  return function(){
    return newCurry.apply(undefined, args.concat(argsArr(arguments)))
  }
}


// okay, so, from some other blog
const objs = [{id : 1}, {id : 2}, {id : 3}, {id : 4}]
objs.map(o =&gt; o.id)
// this is actualy a lot cleaner than his example, because he's doing it like
var objs = [{id : 1}, {id : 2}, {id : 3}, {id : 4}]
objs.map(function(o){return o.id})
// but we'll see where this goes, anyway
const curry = require('curry') // npm i -S curry
const get = curry(function(property, object){return object[property]})
objs.map(get('id'))
// meh.
const getIDs = function(objects){
  return objects.map(get('id'))
}
getIDs(objs)
// double meh.
const map    = curry((fn, val) =&gt; val.map(fn))
    , getIDs = map(get('id'))

// still not sure this is actually cleaner xD
// let's keep going with his examples (translated to ES2015, though)
// some sample data (we'll pretend this is JSON we're getting from somewhere):
const sampleData = {
  &quot;user&quot;  : &quot;z&quot;
  , &quot;posts&quot; : [
    {&quot;title&quot; : &quot;title!&quot;     , &quot;contents&quot; : &quot;asdf&quot;  }
  , {&quot;title&quot; : &quot;something!&quot; , &quot;contents&quot; : &quot;ghjkl;&quot;}
  ]
}
require('http').get('something.whatever/that/data.json')
.then(JSON.parse)
.then(data =&gt; data.posts)
.then(posts =&gt; posts.map(post =&gt; post.title))
// or, using the curry stuff
require('http').get('something.whatever/that/data.json')
.then(JSON.parse)
.then(get('posts'))
.then(map(get('title')))
// uh
// okay
// i don't see that this is any better, here.
// oh wait, he wrote a follow-up!

// shit. i think some of this might be wrong.
// there's no `arguments`! i knew about `this`, but not `arguments`.
// (talking about when using `=&gt;`, i mean.)
// not really a big deal, just in the above, we need to use `...args` instead.
// for example,
let sum = (...nums) =&gt; nums.reduce((a, b) =&gt; a + b)



// examples:
// in es5:
function formatter(tag, text){
  return '&lt;' + tag + '&gt;' + text + '&lt;/' + tag + '&gt;'
}
var p = formatter.bind(undefined, 'p')
p('some content!')
// in es6:
const formatter = (tag, text) =&gt; `&lt;${tag}&gt;${text}&lt;/${tag}&gt;`
const p = text =&gt; formatter('p', text)
// accepting addtional arguments (more text):
const fmt = (tag, text, moar) =&gt; `&lt;${tag}&gt;${text}${moar}&lt;/${tag}&gt;`
const span = ...args =&gt; fmt('span', ...args)

// okay, that's cute because it just lets you specify however many you want, but...
const cur = (fn, ...argsOne) =&gt; (...argsTwo) =&gt; fn(...argsOne, ...argsTwo)
// or, allowing placeholders, as in underscore:
const curMore = (fn, ...argsOne) =&gt; {
  let i = argsOne.indexOf(_)
  let argsOne = (i === -1) ? [] : argsOne.splice(i).slice(1)
  return (...argsTwo) =&gt; fn(...argsOne, ...argsTwo, ...argsThree)
}
// which can then be used like:
const lessTen = curMore(subtract, _, 10) // assuming we've defined a `subtract` somewhere



// from brian lonsdorf's blog/medium, a better `curry` (better in that
// it should be easier to debug).
// note: very definitely es5. and redifines toString().
function curry(fx){
  var arity = fx.length
  function f1(){
    var args = Array.prototype.slice.call(arguments, 0)
    if (args.length &gt;= arity) {
      return fx.apply(null, args)
    }
    function f2(){
      return f1.apply(null, args.concat(Array.prototype.slice.call(arguments, 0)))
    }
    f2.toString = function(){
      return fToString(fx) + '(' + args.join(', ') + ')'
    }
    return f2
  }
  f1.toString = function(){
    return fToString(fx)
  }
  return f1
}
// and a compose from the same:
function compose(){
  var fns = arguments
  function f(result){
    for (var i = fns.length - 1; i &gt; -1; i--) {
      try {
        result = fns[i].call(this, result)
      } catch(e) {
        e.message = f.toString() + ' failed at ' fns[i].toString()
        throw(e)
      }
    }
    f.toString = function(){
      return 'compose('+[].slice.call(fns).map(function(f){ return f.toString() }).join(', ')+')';
    }
    return result
  }
  return f
}



// from reginald braithwaite's blog
// * arity: number of arguments a function accepts
//     * nullary function takes no arguments
//     * unary function accepts one
//     * polyadic function accepts more than one
//     * binary accepts two
//     * ternary function accepts three
//     * variadic function accepts a variable number of arguments

// a map fn
const __ map = [].map
const square = n =&gt; n * n
function map(list, unary){
  return __map.call(list, unaryFn)
}
map([1, 2, 3, 4], square)

// this is fine as long as map gets both arguments (is fully applied)
function mapWrap(unaryFn){
  return function(list){
    return map(list, unaryFn)
  }
}
mapWrap(square)([1, 2, 3, 4])

const squareAll = mapWrap(square)
squareAll([1, 2, 3, 4])

// woot! that's fine, but annoying to write. so, a function to wrap functions:
// const wrapper = unaryFn =&gt; list =&gt; map(list, unaryFn) // can become:
// const wrapper = second =&gt; first =&gt; binaryFn(first, second) // can become:
const rightCurry = binaryFn =&gt; secondArgument =&gt; firstArgument =&gt; binaryFn(firstArgument, secondArgument)
// which can be used like
const rightCurryMap = rightCurry(map)
const squareAll     = rightCurryMap(square)
squareAll([1, 2, 3, 4])
// calling this rightCurry because it takes any binary function and curries into a chain
// of unary functions, starting with the second argument. a curry that starts on the left
// is more common, and it's usually what people mean.
const curry = binaryFn =&gt; firstArg =&gt; secondArg =&gt; binaryFn(firstArg, secondArg)
const cMap  = curry(map)
const twice         = n =&gt; n + n // why did i write this down?
// whether one goes with a leftmost or rightmost curry could depend on which things
// you might need to name and/or reuse

// okay so apparently a pattern like this:
const squareAll = rightCurry(map)(square)
const doubleAll = rightCurry(map)(twice)
// is called a:
// rightmost unary partial application of the map function
// which means it starts from the right, takes one arg, applies not all of the args, and works on the map fn

// the wrong way to build a first-class function to do this would be:
const rightUnPartApp = (binaryFn, secondArg) =&gt; rightCurr(binaryFn)(secondArg)
// and a better way might be
const lastApplication = (binaryFn, secondArg) =&gt; firstArg =&gt; binaryFn(firstArg, secondArg)
// which means we could do
const squareAll = lastApplication(map, square)
const doubleAll = lastApplication(map, twice)
// and so, we could do
const firstApp = (binaryFn, firstArg) =&gt; secondArg =&gt; binaryFn(firstArg, secondArg)

// SO. wat.
// Currying : decomposition of a polyadic function into a chain of nested unary functions. Thus,
// decomposed, you can partially apply one or more arguments, although the curry operation itself
// does not apply any arguments to the function.
// Partial application : conversion of a polyadic function into a function taking fewer arguments
// by providing one or more arguments in advance.




// this is approximately the same as wu.js's .autoCurry() (which has been removed??)
// (es5, obvs. todo: simplify, basically just by making it es6.)
var autoCurry = (function(){

  var
    toArray = function toArray(arr, from){
    return Array.prototype.slice.call(arr, from || 0)
  }

, curry = function curry(fn) {
    var args = toArray(arguments, 1)
    return function curried(){
      return fn.apply(this, args.concat(toArray(arguments)))
    }
  }

  return function autoCurry(fn, numArgs){
    numArgs = numArgs || fn.length
    return function autoCurried(){
      if (arguments.length &lt; numArgs) {
        return numArgs - arguments.length &gt; 0 ?
        autoCurry(curry.apply(this, [fn].concat(toArray(arguments)))
      , numArgs - arguments.length)           :
        curry.apply(this, [fn].concat(toArray(arguments)))
      } else {
        return fn.apply(this, arguments)
      }
    }
  }

}())


// one more
const curry = fn =&gt; {
  const length = fn.length
  const acc = (...args) =&gt; {
    if (args.length === length) return fn(...args)
    return (...args) =&gt; acc(...args.concat(args))
  }
  return acc
}
</code></pre>
    </div>
    <footer>
  <a href="/">Zac Anger</a>
  &middot; <a href="https://github.com/zacanger/zacanger.github.io">Source</a>

  &middot;

  Support on
  <a href="https://ko-fi.com/zacanger" title="Ko-fi" rel="nofollow
  noopener noreferrer" target="_blank">Ko-fi</a>,
  <a href="https://paypal.me/zacanger" title="PayPal" rel="nofollow noopener noreferrer" target="_blank">PayPal</a> or
  <a href="https://www.patreon.com/zacanger" title="Patreon" rel="nofollow noopener noreferrer" target="_blank">Patreon</a>
</footer>
  </body>
</html>