<!DOCTYPE html>
<html lang="en">

  <head>
    <title>ES6 Notes | Zac Anger's Blog</title>
    <meta name="description" content="ES6 Notes" />
    <meta name="keywords" content="['js', 'javascript', 'ecmascript', 'es6', 'es2015']" />
    <meta name="twitter:description" content="ES6 Notes" />
    <meta name="twitter:title" content="ES6 Notes" />
    <meta property="og:description" content="ES6 Notes" />
    <meta property="og:title" content="ES6 Notes" />

    <meta charset="utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<meta name="author" content="Zac Anger" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@zacanger" />
<meta name="twitter:creator" content="@zacanger" />
<meta name="twitter:image" content="https://zacanger.com/logo.png" />
<meta property="og:type" content="article" />
<meta property="og:site_name" content="Zac Anger's Blog" />
<meta property="og:image" content="https://zacanger.com/logo.png" />
<link rel="stylesheet" type="text/css" href="/styles.css" />
  </head>

  <body>
    <header>
      <h1><a href="/blog">Zac Anger's Blog</a></h1>
      <h2>ES6 Notes</h2>
      <h3>2016-01-18</h3>
      <h4><small>Tagged: js, javascript, ecmascript, es6, es2015</small></h4>
    </header>
    <div>
      <p>(These are some random notes from a lecture on ES6.)</p>
<p><code>let</code> = <code>var</code>, but block scoped, <em>finally</em>. this means no leaks. Let can't be
redeclared outside of its block, because it doesn't exist outside of there.</p>
<p><code>const</code> = <code>var</code>, but it's a constant, <em>finally</em>. this means variables you can't
fuck with, man! for simple things, that is. <code>const x = 2; x = 3</code> does <em>not</em>
work. however, parts of a <code>const</code> are mutable; that is, <code>const y = [0, 1, 2, 3];
y[0] = 7</code> <em>does</em> work. Constants can be global or local, that's just up to how
you declare it. Const and let behave the same no matter where you declare them;
the difference is that const can't be <em>defined</em> again, whereas let <em>can</em> be
redefined. <em>Neither</em> of them can be <em>declared</em> again.</p>
<hr />
<p>Structured assignment and destructuring:</p>
<div class="highlight"><pre><span></span>let {name, age} =
{ a: 1,
  name: &#39;zac&#39;,
  age: 26,
  b: false }
</pre></div>

<p>Here, the <code>let</code> is a <em>pattern</em>, looking for <code>age</code> and <code>name</code> in the object. It
ignores the keys that don't match what it's looking for. We can build this
pattern like so, for using 'pretty' keys to access 'ugly' keys:</p>
<div class="highlight"><pre><span></span>let {qzrf: name, kjlpo: age} =
{ a: 1,
  qzrf: &#39;zac&#39;,
  kjlpo: 26,
  b: false
}
</pre></div>

<p>We can dig down there a little bit, too!</p>
<div class="highlight"><pre><span></span>let  {asdf: {ghjkl:name}} =
{asdf: {ghjkl:&#39;zac&#39;}}
</pre></div>

<p>Or even: <code>let {xxx:{yyy:[z:name]}} = {xxx{yyy: [1, 3, 'zac', false]}}</code></p>
<div class="highlight"><pre><span></span>let [x, y] = [1, 2] // PATTERN = ARRAY

let [,x, y] = [1, 2, 3] // will MAKE X=2, y=3!

[x, y] = [y, x] // this sounds familiar ;)

function foo({asdf:ghjkl}){
  // doing things with ghjkl here!
  // because we can destructure **right in the arguments**
}
</pre></div>

<p>Default parameters:</p>
<div class="highlight"><pre><span></span>function bar(x=0){
  // if no argument passed, 0 is the default
}

function quux(y=&#39;baz&#39;){
  return y
}
console.log(quux()) // returns &#39;baz&#39;!
</pre></div>

<p>Rest parameters:</p>
<div class="highlight"><pre><span></span>function hi(...stuff){
  return stuff
}
hi(1, false) // returns 1, false
hi(&#39;me&#39;, &#39;you&#39;, &#39;things&#39;, 4, true) // returns &#39;me&#39;, &#39;you&#39;, &#39;things&#39;, 4, true
// the ...stuff returns a real, manipulable array, so you can map and whatnot on it

function bye(q, ...r){
  // here, we can manipulate q, and _everything else that&#39;s passed in_ will be part of &#39;...r&#39;
}

function what(s, ...t, u){}
// this will _not_ work, because anything passed after &#39;s&#39; will just go straight to &#39;...t&#39;;
// &#39;u&#39; will get _nothing_.
</pre></div>

<p>Spread parameters:</p>
<div class="highlight"><pre><span></span>let a = [1,2,3]
function foo(a,b,c){return a+b+c}
foo(...a)
</pre></div>

<p>So what we're doing is <em>un</em>-packaging that array, and spreading it out to fill
all the space.</p>
<div class="highlight"><pre><span></span>console.log([1, 2, 3, ...a])
// returns [1, 2, 3, 1, 2, 3]
</pre></div>

<p>Template strings. Backticks instead of double-quotes. Dollar sign instead of a
hash. That's about all.</p>
<p>Tag functions can manipulate both variables and template strings inside of
them. Wicked cool.</p>
<div class="highlight"><pre><span></span>function template(strings, ...keys){
  return (function(...values){
    var dict   = values[values.length - 1] || {}
    var result = [strings[0]]
    keys.forEach(function(key, i){
      var value = Number.isInteger(key) ? values[key] : dict[key]
      result.push(value, strings[i + 1])
    })
    return result.join(&#39;&#39;)
  })
}
template`${0} ${&#39;foo&#39;}!`(&#39;Hello&#39;, {foo: &#39;world...&#39;|)} // Hello world....
</pre></div>

<p>Classes: sugar for the Java/Rb/Py kids.</p>
<p>The <code>super()</code> means 'inherit this thingy from what we're extending.' And the
classical inheritance syntax goes <code>class Bar extends Foo { constructor(stuff,
things){} }</code>.</p>
<p><code>this</code> does not have lexical scope, so inside of a method on a class, <code>this</code>
will <em>not</em> have the expected behavior. The <code>this</code> doesn't come to be until its
calling function is ovoked.</p>
<p>For something with no parameters, we can leave out the <code>()</code> in arrow
functions. Like <code>foo =&gt; bar =&gt; bar(asdf){return asdf}</code>. Lets inner function
close over the <code>this</code> of the outer fn.</p>
<p>Iterators:</p>
<div class="highlight"><pre><span></span>let a  = [1, 2, 3]
let it = a.values()
console.log(it.next()) // returns {&quot;value&quot;:1,&quot;done&quot;:false}
console.log(it.next()) // 2, false
console.log(it.next()) // 3, false
console.log(it.next()) // finally, just returns {&quot;done&quot;:true}
</pre></div>

<p>...iterators are sexy. Imagine one that returns pi, gradually. ES6 gives you
strings, arrays, maps, and sets, by default. The <code>.values()</code> and the <code>.next()</code>
are ES6 specific. The <code>.values()</code> is what gives you the next value when
called. Oh my god, this is nice.</p>
<p>forOf:</p>
<div class="highlight"><pre><span></span>let a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
for (let i of a){
  console.log(i)
}
</pre></div>

<p>This only works with structures that give you iterators by default (so the
aforementioned strings, arrays, maps, and sets).</p>
<p>Map:</p>
<div class="highlight"><pre><span></span>let myMap = new Map()
let a = {}
let b = null
let c = 4
myMap.set(a, &#39;hi&#39;)
myMap.set(b, [1, 2, 3])
console.log(myMap.get(c)) // 4
</pre></div>

<p>So, we're just pairing this thing with that thing, without actually storing
those things there for realsies. There are methods for removing, clearing out,
etc., as well.</p>
<p>Sets: these are like arrays, but with no duplication allowed. Great for
finding out if something's already in an array.</p>
<div class="highlight"><pre><span></span>let mySet = new Set()
mySet.add(&#39;hi&#39;)
console.log(mySet.has(&#39;hi&#39;)) // true
mySet.add(&#39;foo&#39;)
console.log(mySet.size) // 2
mySet.add(&#39;hi&#39;)
console.log(mySet.size) // still 2!
</pre></div>

<p>There are a bunch of methods like clearing, removing, providing an iterator,
etc., like in maps.</p>
<p>Modules are a thing.</p>
<p>And there are a bunch of new methods on stuff we already know (strings,
arrays, etc.).</p>
    </div>
    <footer>
  <a href="/">Zac Anger</a>
  &middot; <a href="https://github.com/zacanger/zacanger.github.io">Source</a>
</footer>
  </body>
</html>