<!DOCTYPE html>
<html lang="en">

  <head>
    <title>Front-End Performance Notes | Zac Anger's Blog</title>
    <meta name="description" content="Front-End Performance Notes" />
    <meta name="keywords" content="['performance', 'front-end', 'js', 'browser', 'css']" />
    <meta name="twitter:description" content="Front-End Performance Notes" />
    <meta name="twitter:title" content="Front-End Performance Notes" />
    <meta property="og:description" content="Front-End Performance Notes" />
    <meta property="og:title" content="Front-End Performance Notes" />

    <meta charset="utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<meta name="author" content="Zac Anger" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@zacanger" />
<meta name="twitter:creator" content="@zacanger" />
<meta name="twitter:image" content="https://zacanger.com/logo.png" />
<meta property="og:type" content="article" />
<meta property="og:site_name" content="Zac Anger's Blog" />
<meta property="og:image" content="https://zacanger.com/logo.png" />
<link rel="stylesheet" type="text/css" href="/styles.css" />
  </head>

  <body>
    <header>
      <h1><a href="/blog">Zac Anger's Blog</a></h1>
      <h2>Front-End Performance Notes</h2>
      <h3>2015-12-28</h3>
      <h4><small>Tagged: performance, front-end, js, browser, css</small></h4>
    </header>
    <div>
      <p>Performance matters. That's just a thing. I really don't care all that much<br />
about the browser-side stuff, personally, and I'm a wee bit sick of a lot of the<br />
client-side frameworks that have most of the market, because they mean you<br />
really <em>have</em> to care about using a lot of JS in the browser... because that's<br />
where you're doing most of the work.  Things like Angular really show off this<br />
kind of horrible way of building apps. Putting all the work in every person's<br />
browser sure makes a lot of sense if you've got one tiny SPA and you're serving<br />
it from a home netbook or whatever...  but come on, people. Stop hurting users.<br />
Be realistic. It's not even about doing what's probably actually the <em>right</em><br />
thing to do... it can, if you want, just be about the dollar. Users don't want<br />
to wait. No one wants to wait. Sending out a whole bunch of scripts to a<br />
three-year-old knockoff tablet from China that's running on DSL out in the<br />
country and then figuring that user is okay with waiting while their device<br />
slowly loads it all in and slooowly runs the scripts and then finally starts<br />
showing them the goddamn site they're trying to see... that's how you lose<br />
people.  There are truckloads of studies out there about the negative impact of<br />
every millisecond, so I won't keep rambling, and will start getting down to some<br />
note-taking and summarizing.... Oh, right. I'm reading through <a href="https://browserdiet.com">this little<br />
guide</a>, right now, so that's what sparked this. I know<br />
I've read it before, but I'm really hardcore procrastinating learning Redux<br />
right now, so I figured I'd do something else. This is actually in my school<br />
notes directory, but it may end up as a blog post. Certainly sounds like it. Who<br />
knows?</p>
<hr />
<p>The sort of traditional-ish 'best practice' thing to do is to never use inline<br />
styles/scripts (<code>&lt;div style="stuff:things;" onClick="doThis"&gt;</code>), though there<br />
are use cases for it. For sites with just a very small amount of styles/scripts,<br />
you could embed (<code>&lt;style&gt;</code> and <code>&lt;script&gt;</code> tags). But all-around it's best to<br />
keep everything separated out, at least when you're working. Build tools can<br />
always inline things later for you, if you need this.  Do keep in mind that<br />
latency is <em>far</em> more important that size, so if you can lower the amount of<br />
requests you're making in any way, fucking do it.</p>
<p>Styles in the <code>&lt;head&gt;</code>, traditionally scripts down at the bottom of the body,<br />
although if you're doing all of your rendering in the client, firstly, shame on<br />
you, but also, stick your scripts up top, because otherwise no one will see<br />
<em>anything</em> until your JS is all loaded. We usually throw CSS up top because<br />
designers would hate to for anyone to see the site without their<br />
painstakingly-chosen font pairings, even just for a flash. Use <code>async</code> in your<br />
script tags (<code>&lt;script async src="./foo.js"</code>), when you can (keep in mind that<br />
they'll all be executed in no particular order, so if using <code>async</code> you can't<br />
rely on dependency chains--which you shouldn't be doing anyway).</p>
<p>Minify everything. That's just a given. Also a given, but I'll say it here<br />
anyway: <em><em>don't try to minify your goddamn markup_</em>. Yes, people do that. Yes,<br />
it can be done, a little bit. It's not worth the trouble. It barely works.  It<br />
frequently just _doesn't</em> work. So give up on that. Markup renders super fuckin'<br />
fast. HTML isn't slowing down your page; the two-dozen requests and the<br />
browser-side routing are slowing down your page. Along with<br />
minification/uglification(/obfuscation), obviously you'll want to bundle. Again,<br />
build tools make this really easy.</p>
<p>On that note, don't use <code>@import url('bar.css');</code> in production code. Browsers<br />
can download <code>&lt;style&gt;</code> tags in in parallel, but not <code>@import</code>s (and only so many<br />
tags in in parallel, which is why you should bundle). Build tools, build tools,<br />
build tools.</p>
<p>For third-party code, <em>load asynchronously</em>. Or use iframes like your<br />
grandfather, I don't care. Or you could do something like this:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">script</span><span class="p">,</span>
      <span class="nx">scripts</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="kd">function</span> <span class="nx">load</span><span class="p">(</span><span class="nx">url</span><span class="p">){</span>
    <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">)</span>
    <span class="nx">script</span><span class="p">.</span><span class="nx">async</span> <span class="o">=</span> <span class="kc">true</span>
    <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span>
    <span class="nx">scripts</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">script</span><span class="p">,</span> <span class="nx">scripts</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">load</span><span class="p">(</span><span class="s1">&#39;//example.url/quux.js&#39;</span><span class="p">)</span>
  <span class="nx">load</span><span class="p">(</span><span class="s1">&#39;//another.one/baz.js&#39;</span><span class="p">)</span>
<span class="p">}())</span>
</pre></div>

<p>if you want. Or you could just not be all about them external scripts. Totally up to you.</p>
<p>Oh, and on that note, if you're using jQuery (which you are, admit it, you<br />
goon), do <em>try</em> to get the latest one.  They do actually keep that updated and<br />
worked on and are usually actually optimizing it and making it better. Though<br />
you should keep in mind that there <em>are</em> some breaking changes (especially right<br />
now, what with jQuery 1.x still in use in a lot of places, the 2.1.x being super<br />
common, and 3.0.0-alpha currently out--though they did a <strong>great</strong> job of<br />
breaking as little as they possibly could, that's for sure).</p>
<p>If legacy browsers (read: Safari, IEanything, Mozilla pre-mid-30s) are a<br />
concern, optimize your loops (modern browsers do this automatically). One big<br />
help would be to store the size of arrays, so the JS engine doesn't have to<br />
recalculate this every time it runs through the loop. Here's how that'd be done:</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span>
    <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&amp;</span><span class="nx">lt</span><span class="p">;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
  <span class="c1">// do stuff</span>
<span class="p">}</span>
</pre></div>

<p>This would also help in a situation where, inside your loop, you're working with<br />
a <code>NodeList</code>. It just helps to have a limit set before your for loop, so you<br />
don't wind up doing an infinite loop, for example appending something that<br />
you're maybe also using as the constraint for your loop, or whatever.</p>
<p><code>document.write</code> is really not even worth mentioning, but I will mention it<br />
anyway. Don't do it. Just don't. It's bad.  It's not the worst thing you could<br />
ever do in Javascript, but it's also definitely not a good thing to do.<br />
Especially don't ever do it inside (or after) a <code>window.onload</code>, unless you want<br />
everything on your page replaced.</p>
<p>Repaints: avoid, if you can. That's a non-layout style change (like a colour,<br />
for example). Reflows: avoid even more.  That'd be a layout change (like the<br />
height or width of an element). If you need to change these things, collect all<br />
the data you'll be using <em>before</em> changing anything, that way you can do it all<br />
at once and the browser can just go ahead and re-render it all <em>once</em>.</p>
<p>The DOM is the devil. Okay, no, not really, and even if it was, we'd still have<br />
to mess with it, because we're dealing with Javascript, here, and we're<br />
specifically talking about front-end performance, so...</p>
<p>Really, though, as we did in the example near the top (the array thing), try to<br />
store (cache? whatever, pick a word, I don't care...) the bit you're acting on,<br />
so you don't need to query the DOM constantly (if you're doing something a lot,<br />
I mean). <code>for (var i = 0; i &amp;lt; 100;
i++){document.getElementById("thingy")blahblahblah}</code> is not really okay at all;<br />
<code>var stuff = document.getElementById("thingy"); for (var i = 0; i &amp;lt; 100;
i++){stuff += things or whatever}</code> is a good sight better, don'tcha think?<br />
Javascript isn't a slow language. If it was slow, I probably wouldn't like it<br />
all that much, and as it happens, I'm starting to grow fond of it. The <em>DOM</em> is<br />
slow. There's so much going on up in there, all the time, a truly <em>insane</em><br />
amount of stuff that most people never even have to think about. So think about<br />
that for a minute next time you go to mess with the DOM. It's gonna go all<br />
old-lady-crossing-the-road on yo ass.</p>
<p>Ugh, jQuery. I know, shut up, okay. I use it too. Kinda have to. Everything<br />
depends on it. Like, every framework, basically. And also the stability of the<br />
earth's rotation. And life, and probably death, too. Okay. So when you're using<br />
it (which is right now, I bet), using <code>$("#thing")</code> is gonna be faster than<br />
using classes or elements (or shit like <code>children()</code>). Of course, that means<br />
you're doing things with IDs, which means maybe causing specificity issues down<br />
the road in your CSS, but screw it, there's always <code>!important</code>, or total<br />
refactoring. (I jest. Using IDs is faster, and the specificity issue won't <em>be</em><br />
an issue unless you make it one.)</p>
<p>On the topics of jQuery and loops (which is the topic that we're on now, by the<br />
way), <code>jQuery.each</code> is slow.  <code>for...in</code> is slower. Reverse for and while loops<br />
are actually faster(est? fasterest?), but because they're super-duper<br />
annoying-as-BALLS, don't use them.</p>
<p>And don't be afraid to just use regular old Javascript for things that you might<br />
usually grab jQuery to handle. As it happens, you can do a <em>lot</em> of things in<br />
vanilla JS these days, without needing to reach for the <code>$()</code>. Just know what<br />
tools you should be using, I guess; don't stick with with a tool out of habit<br />
long after there's any need for it, but don't be afraid of using that tool if<br />
nothing else will do the job as efficiently, all around. That's said a lot,<br />
especially in our industry ('Use the right tool for the job'), but definitely<br />
still isn't said enough.</p>
<p>Optimize how you handle images. That doesn't just mean shrinking your photos<br />
down to size--there are other things you can do to speed up image loading. CSS<br />
sprites are kind of obnoxious to work with, but if you have a lot of small items<br />
(say, icons, or toolbar buttons, or something), you'll save yourself a<br />
double-handful or more HTTP requests right there. Another option would be data<br />
URIs. Again, annoying as crap, and you wouldn't want to handle any large images<br />
this way, but for small items you can just do something like <code>.little-tiny-img {
background-image:
url('data:image/png;base64,reallylongassstringofrandomalphanumericcharacters')}</code><br />
and save yourself a request there.</p>
<p>As for your actual images, you're definitely best off using (can you guess what<br />
I'm going to say?) a <em>build tool</em>.  Or just any tool, really. This isn't<br />
something it's at all reasonable to do manually, so find a tool you like that<br />
will remove the metadata, embedded thumbnails, etc., and then figure out if you<br />
want to compress your image as well; that'll bring down the actual image<br />
quality, but as it happens, most screens don't display images at an insanely<br />
high resolution anyway.</p>
<p>That's just about it, I think. Requests matter a lot, probably more than file<br />
size, unless your files are huge. If your files are huge, make them not huge.<br />
Vanilla JS is usually faster than jQuery, but definitely not always.  Messing<br />
with the DOM is slow, especially if you're doing so manually (or with jQuery).<br />
There are good reasons for libraries and frameworks like React, Vue, Riot, and<br />
Mithril. Don't be wary of using a solution, if it's the right solution for the<br />
problem. Don't go looking for a problem, just because you have a solution.</p>
<p>Learn a build tool. Learn more than one. Webpack and Browserify are fantastic<br />
tools for front-end development. Gulp is definitely where you should be, on the<br />
back end (in my personal, sometimes humble opinion). Grunt is a pain, and is<br />
kind of unfashionable these days anyway.</p>
<p>Test things. If there are bottlenecks, find them and fix them. Here are some<br />
links for website performance testing tools:</p>
<ul>
<li><a href="http://www.webpagetest.org/">http://www.webpagetest.org/</a></li>
<li><a href="https://developers.google.com/speed/pagespeed/insights/">https://developers.google.com/speed/pagespeed/insights/</a></li>
<li><a href="http://httparchive.org/">http://httparchive.org/</a></li>
<li><a href="http://yslow.org/">http://yslow.org/</a></li>
</ul>
<p>That's all. Okay. Done.</p>
<p>Go away now.</p>
<p>Byeeee.</p>
    </div>
    <footer>
  <a href="/">Zac Anger</a>
  &middot; <a href="https://github.com/zacanger/zacanger.github.io">Source</a>
</footer>
  </body>
</html>