<!DOCTYPE html>
<html lang="en">

  <head>
    <title>Promises | Zac Anger's Blog</title>
    <meta name="description" content="Promises" />
    <meta name="keywords" content="promises,es6,es2015,js,blog,zac anger" />
    <meta name="twitter:description" content="Promises" />
    <meta name="twitter:title" content="Promises" />
    <meta property="og:description" content="Promises" />
    <meta property="og:title" content="Promises" />

    <meta charset="utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<meta name="author" content="Zac Anger" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@zacanger" />
<meta name="twitter:creator" content="@zacanger" />
<meta name="twitter:image" content="https://zacanger.com/logo.png" />
<meta property="og:type" content="article" />
<meta property="og:site_name" content="Zac Anger's Blog" />
<meta property="og:image" content="https://zacanger.com/logo.png" />
<link rel="stylesheet" type="text/css" href="/styles.css" />
  </head>

  <body>
    <header>
      <h1><a href="/blog">Zac Anger's Blog</a></h1>
      <h2>Promises</h2>
      <h3>2016-05-05</h3>
      <h4><small>Tags: promises, es6, es2015, js, blog, zac anger</small></h4>
    </header>
    <hr>
    <div>
      <p>Important things:
* The actual promise is immutable (nothing can change that)
* There's a guarantee that we'll get something back
* Usually create a promise with a constructor (<code>new Promise</code>)
* Usually its two handlers are named <code>resolve</code> and <code>reject</code>
* A promise will have one of three states:
    * Pending (until something happens)
    * Fulfilled (if the first handler is called)
    * Rejected (if the second handler is called)
* It can only be 'settled' (either resolved or rejected) once.
* Can't cancel a promise.
* No way to check the status (if pending, fulfilled, or rejected).
* An immediately-resolved promise can be created like <code>Promise.resolve('something')</code>.
* An immediately-rejected promise can be created like <code>Promise.reject('something')</code>.
* Attach a <code>then()</code> to consume the promise.
* <code>.then</code> takes a callback that gets passed the resolved value, on fulfillment.
* It can actually take a rejection callback too.
* You can pass in <code>null</code> instead of the first one, which is the same as just doing a <code>.catch()</code>.
* You can chain <code>.then()</code>s.
* You SHOULD use <code>.catch()</code> instead of the <code>.then(null, cb)</code> style.
* This way you can chain multiple <code>then</code>s and then have a final <code>catch</code>.
* <code>throw</code>ing will automatically reject that promise.
* <code>Promise.all()</code> takes arr of promises; once all are fulfilled, it returns arr of fulfilled values.
    * Otherwise (if any are rejected) it will reject.
* <code>Promise.race()</code> is similar, but will fulfill once first promise in the array fulfills.
* Don't program with promises using same patterns as with callbacks.
    * (Don't do a <code>.then(fn(res), fn(err))</code>; use <code>.then().catch()</code>.)
* Don't nest promises. Use a <code>.all</code> instead.</p>
<p>Examples:</p>
<pre><code class="language-javascript">const promise = new Promise((resolve, reject) =&gt; {
  if (something) {
    resolve(value)
  } else {
    reject(reason)
  }
})

const p = Promise.resolve('something')
p.then(res =&gt; console.log(res))
const p2 = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve('asdf'), 2000)
})
p2.then(res =&gt; {
  res += 'ghjkl;'
  console.log(res)
})
p2.then(res =&gt; console.log(res)) // this is still 'asdf'

somePromise.then(
  val =&gt; console.log('fulfilled', val)
, err =&gt; console.error('rejected', err))

pr.then(val =&gt; console.log('fulfilled', val))
  .then(null, err =&gt; console.error('rejected', err))

const throwProm = new Promise((res, rej) =&gt; {
  if (something) {
    throw new Error('rejected')
  } else {
  resolve(stuff)
  }
})
throwProm
.then(val =&gt; val + 8)
.then(val =&gt; console.log('hey', val))
.catch(err =&gt; console.error('err', err.message))

const fulProm = new Promise((res, rej) =&gt; res(8))
fulProm
.then(val =&gt; val + 8)
.then(val =&gt; {throw new Error('failure')})
.then(val =&gt; console.log('yay', val))
.catch(err =&gt; console.error('error', err.message))

one()
.then(res =&gt; Promise.all([res, two(res)]))
  .then(results =&gt; /* stuff */)
  .catch(err =&gt; /* handle err */)

</code></pre>
    </div>
    <footer>
  <a href="/">Zac Anger</a>
  &middot; <a href="https://github.com/zacanger/zacanger.github.io">Source</a>

  &middot;

  Support on
  <a href="https://ko-fi.com/zacanger" title="Ko-fi" rel="nofollow
  noopener noreferrer" target="_blank">Ko-fi</a>,
  <a href="https://paypal.me/zacanger" title="PayPal" rel="nofollow noopener noreferrer" target="_blank">PayPal</a> or
  <a href="https://www.patreon.com/zacanger" title="Patreon" rel="nofollow noopener noreferrer" target="_blank">Patreon</a>
</footer>
  </body>
</html>