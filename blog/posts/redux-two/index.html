<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/><title>redux notes, part two | Zac Anger&#x27;s Blog</title><meta name="description" content="Because the Redux docs say &quot;Redux is actually really simple!&quot; when sometimes
it&#x27;s not, and because those docs themselves are pretty overwhelming when
you&#x27;re first trying out Redux, I&#x27;m going to attempt to distill the docs and
bits of my own (admittedly limited) personal experience with Redux into a
couple of blog posts."/><meta name="author" content="Zac Anger"/><meta name="keywords" content="blog,design,javascript,js,music,programming,vim,web development,writing,redux,react"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@zacanger"/><meta name="twitter:creator" content="@zacanger"/><meta name="twitter:title" content="redux notes, part two"/><meta name="twitter:description" content="Because the Redux docs say &quot;Redux is actually really simple!&quot; when sometimes
it&#x27;s not, and because those docs themselves are pretty overwhelming when
you&#x27;re first trying out Redux, I&#x27;m going to attempt to distill the docs and
bits of my own (admittedly limited) personal experience with Redux into a
couple of blog posts."/><meta name="twitter:image" content="https://zacanger.com/logo.png"/><meta property="og:type" content="article"/><meta property="og:title" content="redux notes, part two"/><meta property="og:description" content="Because the Redux docs say &quot;Redux is actually really simple!&quot; when sometimes
it&#x27;s not, and because those docs themselves are pretty overwhelming when
you&#x27;re first trying out Redux, I&#x27;m going to attempt to distill the docs and
bits of my own (admittedly limited) personal experience with Redux into a
couple of blog posts."/><meta property="og:site_name" content="https://zacanger.com/blog"/><meta property="og:image" content="https://zacanger.com/logo.png"/><script type="text/javascript" href="/blog/assets/highlight.pack.js"></script><link rel="stylesheet" type="text/css" href="/blog/assets/styles.css"/><link rel="stylesheet" type="text/css" href="/blog/assets/github-gist.css"/></head><body><header><h1><a href="/blog">Zac Anger&#x27;s Blog</a></h1><h2>redux notes, part two</h2><div>06 August, 2016</div></header><div><div><p>Because the Redux docs say &quot;Redux is actually really simple!&quot; when sometimes
it's not, and because those docs themselves are pretty overwhelming when
you're first trying out Redux, I'm going to attempt to distill the docs and
bits of my own (admittedly limited) personal experience with Redux into a
couple of blog posts.</p>
<hr>
<p>All your data moves in one direction. This is the same as in Flux. You will
always go through the same steps in redux:</p>
<ul>
<li>Action (call <code>store.dispatch()</code> with an object that describes something
happening)</li>
<li>Reducer (pure function called based on the action that was dispatched that
calculates next state)</li>
<li>Your root reducer combines a bunch of reducers' outputs into one state tree
(assuming you have a root reducer, which you probably do)</li>
<li>The store saves the state tree as returned by the above—now that's your
state (and at this point anything you subscribed with will be invoked)</li>
</ul>
<p>All your state in redux is just an object—just one object. It's probably a
good idea to try to keep that as shallow as possible, and reference things by
keys (IDs), rather than deeply nesting stuff.</p>
<p>Reducers are just functions. They take your existing state (state previous to
acting on it) and an action and output state (new state).</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> someReducer = <span class="hljs-function">(<span class="hljs-params">oldState, action</span>) =&gt;</span> newState
</code></pre>
<p>It's a reducing function just like you'd pass to <code>Array.reduce()</code>, it it should
always be a pure function. Don't mutate arguments, call non-pure functions, make
API calls, or anything like that in a reducer. If you don't know what a pure
function is, it's actually super simple:</p>
<blockquote>
<p>Given the same arguments, a pure function will always have the same output.
This means it's a function who's result relies solely on its arguments.</p>
</blockquote>
<p>One thing you should get in the habit of doing is using 'default arguments.'
This is new in ES2015, and saves you a bit of code. This means you could have
some initial state:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> initState = {
  <span class="hljs-attr">something</span>     : <span class="hljs-string">'a'</span>
, <span class="hljs-attr">somethingElse</span> : <span class="hljs-string">'b'</span>
}
</code></pre>
<p>And instead of needing to write</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state, action</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> state === <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-keyword">return</span> initState
  }
  <span class="hljs-comment">// do stuff</span>
}
</code></pre>
<p>You can just do</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> reducer = <span class="hljs-function">(<span class="hljs-params">state = initState, action</span>) =&gt;</span> <span class="hljs-comment">// do stuff</span>
</code></pre>
<p>Reducers are frequently switch statements. This might seem a little weird at
first, since most JS folks avoid switch statements (I think some linters even
warn about them, saying they're 'confusing'), but it makes sense in reducers
since you can handle various actions in one function. Remember, an action is
just an object: <code>{type: 'do_thing'}</code> with possible other fields: <code>{type: 'do_thing', to: 'stuff'}</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> someReducer = (state = initState, action) {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> do_stuff:
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.assign({}, state, {<span class="hljs-attr">something</span>: action.to})
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}
</code></pre>
<p>Note the <code>Object.assign()</code>—we don't mutate state, we return a new state
based on the old state and the action. You'll probably want to use a polyfill
for <code>.assign()</code>, but chances are you're already using Babel anyway. You could
also use something from Lodash, Underscore, or some other library.</p>
<p>It's always a good idea to return <code>state</code> (which is our old state) as a default,
in case we get sent some unexpected action.</p>
<p>It's also a good idea to split your reducers and compose them:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> firstReducer = <span class="hljs-function">(<span class="hljs-params">state = {}, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> something:
      <span class="hljs-keyword">return</span> stuff
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">return</span> state
  }
}

<span class="hljs-keyword">const</span> secondReducer = <span class="hljs-function">(<span class="hljs-params">state = initState, action</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span> (action.type) {
    <span class="hljs-keyword">case</span> whatever:
      <span class="hljs-keyword">return</span> firstReducer(state.field, action)
    <span class="hljs-keyword">default</span>
      <span class="hljs-keyword">return</span> state
  }
}
</code></pre>
<p>This means that <code>firstReducer</code> only needs to get the state that it actually
cares about, when it needs to do something. Also note that defaut state is an
empty object there. It could be anything you want it to be, just make sure it's
the shape your reducer expects to act on.</p>
<p>When you have a lot of reducers, you can use <code>combineReducers</code>:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { combineReducers } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>

<span class="hljs-keyword">const</span> lotsOfReducers = combineReducers({
  firstReducer
, secondReducer
<span class="hljs-comment">// , etc.</span>
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> lotsOfReducers
</code></pre>
<p>And you can do this as many times as you like, in as many files as you need.</p>
<p>All you're doing with reducers is taking in the state as it exists, taking in an
action, and outputing the new state. What you're operating against is the store.</p>
<p>The Store is a really important bit. It holds all the state of your app. This
is different from Flux, where you'd have a lot of little stores. In Redux
there's only one. It's accessed similiarly—you have <code>getState()</code>, you
dispatch actions, and you can have listeners subscribe to changes. To create a
store in Redux, you just use <code>createStore</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>
<span class="hljs-keyword">import</span> someReducer <span class="hljs-keyword">from</span> <span class="hljs-string">'./someFile'</span>
<span class="hljs-keyword">const</span> store = createStore(someReducer)
<span class="hljs-comment">// createStore can take your initial state, too</span>
<span class="hljs-keyword">const</span> store = createStore(someReducer, initialState)
<span class="hljs-comment">// and for creating a store as simply as possible (mocking in testing, etc.):</span>
<span class="hljs-keyword">const</span> store = createStore(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({})) <span class="hljs-comment">// your store is just an empty object, now</span>
</code></pre>
<p><code>store.subscribe()</code> returns a function for _un_subscribing. So you can do
something like:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> unsubscribe = store.subscribe(someListener)
unsubscribe()
</code></pre>
</div><p><a href="https://github.com/zacanger/dotcom/issues/new?title=redux notes, part two" target="_blank">Submit a bug report</a></p></div><footer>Made by <a href="/">Zac Anger</a><br/><br/><a href="/blog/rss.xml">Feed</a> · <a href="/LICENSE.txt">License</a> · <a href="https://github.com/zacanger">GitHub</a> · <a href="https://twitter.com/zacanger">Twitter</a> · <a href="https://mastodon.social/@zacanger">Mastodon</a></footer></body></html>