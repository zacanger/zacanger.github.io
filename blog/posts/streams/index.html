<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/><title>streams | Zac Anger&#x27;s Blog</title><meta name="description" content="bits and pieces of notes on streams"/><meta name="author" content="Zac Anger"/><meta name="keywords" content="blog,design,javascript,js,music,programming,vim,web development,writing,js,streams"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@zacanger"/><meta name="twitter:creator" content="@zacanger"/><meta name="twitter:title" content="streams"/><meta name="twitter:description" content="bits and pieces of notes on streams"/><meta name="twitter:image" content="https://zacanger.com/logo.png"/><meta property="og:type" content="article"/><meta property="og:title" content="streams"/><meta property="og:description" content="bits and pieces of notes on streams"/><meta property="og:site_name" content="https://zacanger.com/blog"/><meta property="og:image" content="https://zacanger.com/logo.png"/><link rel="stylesheet" type="text/css" href="/blog/assets/styles.min.css"/></head><body><header><h1><a href="/blog">Zac Anger&#x27;s Blog</a></h1><h2>streams</h2><div>15 May, 2016</div></header><div><p>bits and pieces of notes on streams</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> foo = fetch(<span class="hljs-string">'/something'</span>)
.then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.json())
.then(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.thingwewant)

<span class="hljs-keyword">const</span> bar = fetch(<span class="hljs-string">'/otherstuff'</span>)
.then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.body)

<span class="hljs-keyword">const</span> stream = someTaggedFunctionThing<span class="hljs-string">`
  &lt;div&gt;<span class="hljs-subst">${foo}</span>&lt;/div&gt;
  &lt;span&gt;<span class="hljs-subst">${bar}</span>&lt;/span&gt;`</span>
</code></pre>
<ul>
<li>streams can be infinite</li>
<li>you can be aware of the beginning and end of a stream</li>
<li>unread values are buffered (unlike how events pre-listener(s) are just gone)</li>
<li>piping</li>
<li>error-handling (down the pipeline)</li>
<li>cancellation (up the pipeline)</li>
<li>flow control (react to the reader speed)</li>
<li>one reader per stream</li>
<li>untapped stream can be used like <code>tee</code></li>
</ul>
<p>with <code>fetch</code>, <code>result.value</code> is always of type <code>Uint8Array</code> (binary; use <code>TextDecoder</code>
on that if text content expected).</p>
<p>there may be transform streams implemented in the browser at some point (r/w).</p>
<p><code>reader.cancel()</code> (or <code>response.body.cancel()</code> if fetch)</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">new</span> ReadableStream({
  start(controller){} <span class="hljs-comment">// called immediately</span>
, pull(controller){}  <span class="hljs-comment">// called when buffer isn't full; called until buffer is full</span>
, cancel(reason){}    <span class="hljs-comment">// called if stream is cancelled</span>
}, queuingStrategy)   <span class="hljs-comment">// how the stream buffers (default : one item)</span>

</code></pre>
<ul>
<li><code>controller.enqueue(something)</code> queues <code>something</code> in the stream's buffer</li>
<li><code>controller.close()</code> ends</li>
<li><code>controller.error(e)</code> sends <code>e</code> (is a terminal error)</li>
<li><code>controller.desiredSize</code> amount of buffer left (can be negative if overfilled)
<ul>
<li><code>queuingStrategy</code> is used to get this</li>
</ul>
</li>
<li>you could call <code>controller.enqueue()</code> whenever there's data to send (stream as a push source)</li>
<li>you could wait until there's a <code>pull</code> called, then queue up some data (pull source)</li>
<li>you can do whatever you like (basically)</li>
<li>staying within the bounds of <code>controller.desiredSize</code> and having backpressure on the source
is good/efficient. won't break anything if you don't, though, unless you run out of memory.</li>
</ul>
<p>html renders as it's received (no matter how it gets there). so fetching/compiling/whatevering
markup on the fly (aka client-side rendering, aka the devil usually) without streams means
slowness.</p>
<p>here's a thing basically just copied out of jake archibald's blog. it's like this because we
don't have a <code>.pipe()</code> in the browser. we need that.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">new</span> ReadableStream({
  start(controller){
    <span class="hljs-comment">// start and end from cache, middle from network with cache fallback</span>
    <span class="hljs-keyword">const</span>
      start = caches.match(<span class="hljs-string">'/start-cached'</span>)
    , end   = caches.match(<span class="hljs-string">'/end-cached'</span>)
    , mid   = fetch(<span class="hljs-string">'/middle'</span>)
        .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> caches.match(<span class="hljs-string">'/middle-cached'</span>))
      push  = <span class="hljs-function"><span class="hljs-params">stream</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> reader = stream.getReader()
      <span class="hljs-keyword">return</span> reader.read().then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">result</span>)</span>{
        <span class="hljs-keyword">if</span> (result.done) {
          <span class="hljs-keyword">return</span>
        }
        controller.enqueue(result.value)
        <span class="hljs-keyword">return</span> reader.read().then(process)
      })
    }

    start.then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> push(response.body))
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> mid).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> push(response.body))
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> end).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> push(response.body))
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> controller.close())
  }
})
</code></pre>
<p>From here down I'll probably just be taking notes on streams in Node.</p>
<p>Some important things to remember (for me to remember, that is) -- differences between the
proposed Stream and Node's streams:</p>
<ul>
<li>Readable
<ul>
<li><code>.read()</code> instead of <code>.on('readable')</code></li>
<li>Also a sync <code>.read()</code></li>
<li>Cancellation semantics added</li>
<li><code>desiredSize</code></li>
<li><code>tee</code>ing built in</li>
<li><code>data</code> event fully gone (it's only in Node streams in compatability mode, btw)</li>
<li><code>pause</code> and <code>resume</code> aren't a thing</li>
<li>no <code>unshift</code></li>
<li>binary/string/object mode switching isn't a thing</li>
<li>size parameter is gone (use BYOB readers)</li>
</ul>
</li>
<li>Writable
<ul>
<li>No cork/uncork</li>
</ul>
</li>
<li>Transform
<ul>
<li>now just <code>{readable, writable}</code> rly</li>
</ul>
</li>
<li>other
<ul>
<li>promises instead of cbs</li>
<li>no enc/dec built-in</li>
<li><code>pipeTo(writable)</code> and <code>pipeThrough(transform)</code> instead of just <code>pipe()</code>
<ul>
<li>so <code>source.pipeThrough(thing).pipeTo(destination)</code> is syntactic sugar for
<code>source.pipeTo(thing.writable) ; thing.readable.pipeTo(destination)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Okay, so, Node streams.</p>
<ul>
<li><code>req</code> and <code>res</code> are streams</li>
<li><code>.pipe()</code> listens for 'data' and 'end' from fs streams</li>
<li><code>.pipe()</code> handles backpressure for ya</li>
<li>types of streams:
<ul>
<li>readable</li>
<li>writable</li>
<li>transform</li>
<li>duplex</li>
<li>'classic'</li>
</ul>
</li>
<li>chain pipes, don't break crap out
<ul>
<li><code>one.pipe(two).pipe(three)</code>, not <code>one.pipe(two);two.pipe(three);</code></li>
<li>that's basically the same as <code>one | two | three</code></li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//</span>
<span class="hljs-comment">// readable</span>
<span class="hljs-comment">//</span>

<span class="hljs-keyword">const</span> Readable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).Readable
<span class="hljs-keyword">const</span> rs = <span class="hljs-keyword">new</span> Readable
rs.push(<span class="hljs-string">'something, and '</span>)
rs.push(<span class="hljs-string">'something else.'</span>)
rs.push(<span class="hljs-literal">null</span>) <span class="hljs-comment">// this tells data consumers that we're done with rs</span>
rs.pipe(process.stdout)
<span class="hljs-comment">// so the pushes are buffered until a consumer wants them (the pipe to standard out)</span>

<span class="hljs-comment">// instead of buffering:</span>
<span class="hljs-keyword">let</span> c = <span class="hljs-number">100</span>
rs._read = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  rs.push(<span class="hljs-built_in">String</span>.fromCharCode(c++))
  <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-string">'z'</span>.charCodeAt(<span class="hljs-number">0</span>)) {
    rs.push(<span class="hljs-literal">null</span>)
  }
}
rs.pipe(process.stdout)
<span class="hljs-comment">// ._read can take a size param, the amount (in bytes) that the consumer wants</span>
<span class="hljs-comment">// to call it like that, try `node thisfile | head -cN` where `N` is an integer</span>
<span class="hljs-comment">// note that we'd need to set up an error handler here because there'll be a SIGPIPE</span>
<span class="hljs-comment">// after `head` (EPIPE in node). that's not an issue when keeping your business all</span>
<span class="hljs-comment">// in node.</span>
<span class="hljs-comment">// `Readable({objectMode : true})` to be able to push arbitrary stuff (not just</span>
<span class="hljs-comment">// buffers and strings).</span>

process.stdin.on(<span class="hljs-string">'readable'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> buf = process.stdin.read()
  <span class="hljs-built_in">console</span>.dir(buf)
})
<span class="hljs-comment">// echo stuff, pipe it, eg `(echo foo ; echo bar ; sleep 10 ; echo asdfghjkl) | node this-script.js`</span>
<span class="hljs-comment">// usually we'd probably pipe a stream into another stream, maybe using through2 or somesuch</span>
<span class="hljs-comment">// the above will return null at the end of what's being sent, because there's nothing left</span>
<span class="hljs-comment">// we could do `.read(N)` where `N` is bytes. doesn't work for object streams.</span>
process.stdin.on(<span class="hljs-string">'readable'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> buf = process.stdin.read(<span class="hljs-number">2</span>)
  <span class="hljs-built_in">console</span>.dir(buf) <span class="hljs-comment">// so we'd get 2-byte chunks here. adding:</span>
  process.stdin.read(<span class="hljs-number">0</span>) <span class="hljs-comment">// will get the rest and make this actually work.</span>
})

<span class="hljs-comment">// YAY, that's it for readable streams</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// writable</span>
<span class="hljs-comment">//</span>

<span class="hljs-keyword">const</span> Writable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).Writable
<span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> Writable()
ws._write = <span class="hljs-function">(<span class="hljs-params">chunk, encoding, next</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.dir(chunk)
  next()
}
process.stdin.pipe(ws)
<span class="hljs-comment">// chunk is the data written</span>
<span class="hljs-comment">// encoding (string) is only for when `opts.decodeStrings` is false and we've been given a string</span>
<span class="hljs-comment">// the third arg is cb, tells consumer to go ahead and write more. it can take an err obj</span>
<span class="hljs-comment">// if input stream is string, that'll be converted to buf. when creating the stream we can do</span>
<span class="hljs-keyword">const</span> strWs = <span class="hljs-keyword">new</span> Writable({<span class="hljs-attr">decodeStrings</span> : <span class="hljs-literal">false</span>})
<span class="hljs-comment">// and if we're getting in objects</span>
<span class="hljs-keyword">const</span> objWs = <span class="hljs-keyword">new</span> Writable({<span class="hljs-attr">objectMode</span> : <span class="hljs-literal">true</span>})

<span class="hljs-comment">// writing is basically as simple as calling .write (as we do with stdout)</span>
<span class="hljs-comment">// you can do a .end() to say we're done. that can take data to write, right before ending.</span>
<span class="hljs-comment">// write returns false when there's more data in incoming buff than opts.highWaterMark;</span>
<span class="hljs-comment">// listen for drain event to know when it's empty</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// transform</span>
<span class="hljs-comment">// these are duplex streams that do exactly what it sounds like. sometimes called 'through' streams.</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// duplex</span>
<span class="hljs-comment">// r/w where both ends are two-way. example: `x.pipe(y).pipe(x)`</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// classic streams</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// we're on node 6.1.0 as of this writing, and chances are i won't be doing much node stuff</span>
<span class="hljs-comment">// at all in the forseeable future, so i really don't care too too much about the legacy</span>
<span class="hljs-comment">// streams api. just `require('readable-stream')` instead of `'stream'`, if we must support</span>
<span class="hljs-comment">// node or other streams from &lt;=v0.8.</span>

<span class="hljs-comment">// readable example:</span>
<span class="hljs-keyword">const</span> sin = process.stdin
sin.on(<span class="hljs-string">'data'</span>, buf =&gt; <span class="hljs-built_in">console</span>.log(buf))
sin.on(<span class="hljs-string">'end'</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'peace'</span>))
<span class="hljs-comment">// as soon as a data listener is registered, you're using compatability mode, so</span>
<span class="hljs-comment">// basically you lose a lot of functionality.</span>
<span class="hljs-comment">// through (the package) lets you use legacy streams with pipe</span>
<span class="hljs-comment">// these also have pause and resume.</span>

<span class="hljs-comment">// writable:</span>
<span class="hljs-comment">// define write(buf), end(buf), and destroy(). end doesn't HAVE to have (buf), but</span>
<span class="hljs-comment">// it should work so that stream.end(buf) means stream.write(buf) ; stream.end(), so just do that.</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// streams that are built in to node</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// not gonna take really extensive notes here, for the reasons above and also because</span>
<span class="hljs-comment">// it's really easy to just go to the api docs and read all of them.</span>

</code></pre>
</div><footer><a href="/">Zac Anger</a> · <a href="/LICENSE.txt">License</a> · <a href="https://github.com/zacanger/zacanger.github.io">Source</a></footer></body></html>