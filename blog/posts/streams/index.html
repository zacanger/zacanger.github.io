<!DOCTYPE html><html><head><meta charset="utf-8"/><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/><title>streams | Zac Anger&#x27;s Blog</title><meta name="description" content="bits and pieces of notes on streams"/><meta name="author" content="Zac Anger"/><meta name="keywords" content="blog,design,javascript,js,music,programming,vim,web development,writing,js,streams"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@zacanger"/><meta name="twitter:creator" content="@zacanger"/><meta name="twitter:title" content="streams"/><meta name="twitter:description" content="bits and pieces of notes on streams"/><meta name="twitter:image" content="http://zacanger.com/logo.png"/><meta property="og:type" content="article"/><meta property="og:title" content="streams"/><meta property="og:description" content="bits and pieces of notes on streams"/><meta property="og:site_name" content="http://zacanger.com/blog"/><meta property="og:image" content="http://zacanger.com/logo.png"/><style type="text/css">/* base.css */
* { box-sizing: border-box }

html {
  font-size: 20px;
}

body {
  font-family: 'Merriweather', Athelas, Georgia, serif;
  line-height: 1.625;
  margin: 0;
  color: #311;
  background-color: #fff;
}

img {
  max-width: 100%;
  height: auto;
}

a {
  color: inherit;
  text-decoration: none;
  background-repeat: no-repeat;
  background-position: bottom;
  background-size: 100% 6px;
  background-image: linear-gradient(transparent, transparent 5px, #ccc 5px, #ccc);
}

a:hover {
  background-image: linear-gradient(transparent, transparent 4px, #0cf 4px, #0cf);
}

h1 a,
h2 a,
h3 a,
h4 a,
h5 a,
h6 a {
  color: inherit;
  text-decoration: none;
  background: none;
}

h1 a:hover,
h2 a:hover,
h3 a:hover,
h4 a:hover,
h5 a:hover,
h6 a:hover {
  background-repeat: no-repeat;
  background-position: bottom;
  background-size: 100% 6px;
  background-image: linear-gradient(transparent, transparent 4px, #0cf 4px, #0cf);
}

h3,
h4, h5, h6 {
  font-size: 1rem;
}

h1 {
  letter-spacing: .2em;
  font-size: .7rem;
  font-size: .8rem;
  font-style: normal;
  font-weight: 600;
  margin-top: 4rem;
  margin-bottom: 3rem;
}

h2 {
  font-size: 1rem;
  font-weight: normal;
  font-weight: 700;
  text-transform: none;
  letter-spacing: normal;
  margin-top: 3rem;
  margin-bottom: 1rem;
}

h3 {
  font-weight: 400;
  font-style: italic;
}

h3, h4, h5 {
  margin-top: 2rem;
  margin-bottom: 1rem;
}

p, dl, ol, ul, blockquote {
  margin-top: 1rem;
  margin-bottom: 1rem;
}

blockquote {
  font-style: italic;
  margin-left: 2rem;
  margin-right: 2rem;
}

code, pre, samp {
  font-family: 'Hasklig', 'Hack', 'Fira Code', 'Fantasque Sans Mono', monospace;
}

pre {
  font-size: 70%;
  padding-left: 1rem;
  margin-top: 2rem;
  margin-bottom: 2rem;
  overflow-x: scroll;
  border-left: 4px solid rgba(0, 0, 0, .0625);
}

hr {
  border: 0;
  border-bottom: 4px solid rgba(0, 0, 0, .0625);
  margin-top: 2em;
  margin-bottom: 2em;
}

code {
  font-size: 80%;
  background-size: 100% 8px;
  background-repeat: no-repeat;
  background-position: bottom;
  background-image: linear-gradient(transparent 4px, rgba(0, 0, 0, .125) 4px);
}

table {
  width: 100%;
  max-width: 100%;
  margin-top: 2rem;
  margin-bottom: 2rem;
  border-collapse: separate;
  border-spacing: 0;
}

th, td {
  padding: 0;
  line-height: 2rem;
}

th {
  font-size: .7rem;
  font-weight: 600;
  letter-spacing: .2em;
  text-align: left;
  border-bottom: 2px solid;
}

td {
  border-bottom: 1px solid rgba(0, 0, 0, .0625);
}

tr:last-child td {
  border: 0;
}


/* zeess */
@charset "utf-8";
@viewport {
  width: device-width;
}
@at-root {
  width: device-width;
}
@-moz-viewport {
  width: device-width;
}
@-ms-viewport {
  width: device-width;
}
@-o-viewport {
  width: device-width;
}
@-webkit-viewport {
  width: device-width;
}

/** zeess https://github.com/zacanger/zeess license: wtfpl **/

/* a little reset */

html, body {
  height: 100%;
  width: 100%;
}
html, body, ul, ol, li, form, fieldset, legend {
  margin: 0;
  padding: 0;
}
h1, h2, h3, h4, h5, h6, p {
  margin-top: 0;
}
fieldset, img {
  border: 0;
}
legend {
  color: #000;
}
sup {
  vertical-align: text-top;
}
sub {
  vertical-align: text-bottom;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}
caption, th, td {
  text-align: left;
  vertical-align: top;
  font-weight: normal;
}
textarea, select {
  font-size: 110%;
  line-height: 1.1;
}
abbr, acronym {
  border-bottom: .1em dotted;
  cursor: help;
}
img {
  max-width: 100%;
  height: auto;
}
figure {
  margin: 0;
}
svg {
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
mark {
  background: #ff0;
  color: #000;
}
dfn {
  font-style: italic;
}
audio, canvas, video {
  display: inline-block;
}
audio:not([controls]) {
  display: none;
  height: 0;
}

*, *:before, *:after {
  box-sizing: inherit;
  outline: 0 !important;
  border-collapse: separate;
  border-spacing: 0;
  font-stretch: normal;
}

/* 1.5rem = 15px */

html {
  -ms-text-size-adjust: 100%;
  -webkit-font-smoothing: antialiased;
  -webkit-font-smoothing: subpixel-antialiased;
  -webkit-text-size-adjust: 100%;
  box-sizing: border-box;
  font-size: 62.5%;
  height: 100%;
  outline: none;
  text-rendering: optimizeLegibility;
  width: 100%;
}
body {
  font-size: 1.5em;
  line-height: 1.6;
  font-weight: 400;
  font-family: "Merriweather", "Cardo", serif;
  color: #303330;
  background: #fff;
  padding: 1rem;
  max-width: 900px;
  margin-left: 2rem;
}
iframe {
  border: 0;
}

/* semanticky things */

section {
  margin-left: auto;
  margin-right: auto;
  max-width: 100%;
  width: 900px;
}
article {
  border: 1px solid #d9d9d9;
  border-radius: 2px;
  padding: 2rem;
}
header {
  margin-bottom: 2rem;
}
footer {
  margin-top: 2rem;
}
blockquote, q {
  quotes: none;
}

/* Typography */

h1, h2, h3, h4, h5, h6 {
  margin-top: 2rem;
  margin-bottom: 1rem;
  font-weight: 400;
}
h1 {
  font-size: 4.0rem;
  line-height: 1.2;
  letter-spacing: -.1rem;
}
h2 {
  font-size: 3.6rem;
  line-height: 1.25;
  letter-spacing: -.1rem;
}
h3 {
  font-size: 3.2rem;
  line-height: 1.3;
  letter-spacing: -.1rem;
}
h4 {
  font-size: 2.4rem;
  line-height: 1.35;
  letter-spacing: -.08rem;
}
h5 {
  font-size: 1.8rem;
  line-height: 1.5;
  letter-spacing: -.05rem;
}
h6 {
  font-size: 1.6rem;
  line-height: 1.6;
  letter-spacing: 0;
}
small {
  font-size: 1.3rem;
}
em, i {
  font-style: italic;
}
strong, b {
  font-weight: 600;
}

/* Links */

a {
  -webkit-transition: color .4s;
  transition: color .4s;
  color: #265C83;
}
a:link, a:visited {
  color: #265C83;
}
a:hover {
  color: #7FDBFF;
}
a:active {
  -webkit-transition: color .3s;
  transition: color .3s;
  color: #007BE6;
}

/* Lists, nav, and spacing */

p, ul, ol, dl, blockquote, hr, pre, table, form, fieldset, figure, address {
  margin-bottom: 2rem;
}
ul {
  list-style: circle inside;
  padding-left: 1rem;
  margin-top: 0;
}
ol {
  list-style: decimal inside;
}
ul ul {
  margin: 1.5rem 0 1.5rem 3rem;
  font-size: 80%;
}
ol, ul {
  margin-left: 2rem;
}
li ol, li ul {
  margin-bottom: 0;
}
nav {
  text-align: center;
}
nav ul {
  list-style: none;
  margin-left: 0;
  text-align: center;
}
nav ul li {
  display: inline;
  margin-left: .8rem;
  margin-right: .8rem;
}
nav ul li:first-child {
  margin-left: 0;
}
nav ul li:last-child {
  margin-right: 0;
}
p {
  margin-top: 1rem;
}
p, ul {
  margin-bottom: 2.5rem;
}

/* hr is _very important_. */

hr {
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box;
  border-top: 1px solid #ccc;
  border-width: 0;
  box-sizing: content-box;
  height: 0;
  margin-bottom: 0.8rem;
  margin-top: 0.8rem;
}

/* pre, code, etc. */


/* being extra nice to people who have nice typefaces */

code, kbd, samp, var, output {
  font-family: "Fira Code", "Hasklig", "Hack", "Fantasque Sans Mono", Menlo, Monaco, Consolas, monospace;
  font-size: 1.4rem;
}
pre {
  border-left: 1.8px solid #96bbe2;
  line-height: 1.2;
  margin-top: 0.6rem;
  overflow: auto;
  padding-left: 0.6rem;
}
pre code {
  border: 0;
  line-height: 1.2;
  padding: 0;
}
code {
  border: 1.8px solid #ccc;
  border-radius: 2px;
  display: inline-block;
  line-height: 1.2;
  padding: 3px 6px 2px;
}

/* tabley stuff */

th {
  font-weight: 600;
}
td, th {
  border-bottom: 1px solid #ccc;
  padding: 0.8rem;
}
thead th {
  border-bottom-width: 2px;
  padding-bottom: 0.6rem;
}
table {
  display: block;
  max-width: 100%;
  overflow-x: auto;
}

/* inputs and things are really just awful */

[hidden], template {
  display: none;
}
[role="button"] {
  cursor: pointer;
}
label {
  display: block;
  margin-bottom: 0.8rem;
}
input::-moz-focus-inner, button::-moz-focus-inner {
  border: 0;
  padding: 0;
  display: none;
}
input:-webkit-autofill {
  color: #fff !important;
}
textarea {
  overflow: auto;
  resize: vertical;
  vertical-align: top;
}
button, input, textarea, select {
  -webkit-font-smoothing: inherit;
}
a, area, button, [role="button"], input, label, select, summary, textarea {
  -ms-touch-action: manipulation;
  touch-action: manipulation;
}
input, textarea, select, button {
  display: block;
  padding: 0.6rem;
}
input[type="submit"], input[type="reset"], input[type="button"], button {
  background: #f2f2f2;
  border-radius: 2px;
  color: #8c8c8c;
  cursor: pointer;
  display: inline;
  margin-bottom: 1.2rem;
  margin-right: 0.4rem;
  padding: 0.4rem 1.4rem;
  text-align: center;
}
input[type="submit"]:hover, input[type="reset"]:hover, input[type="button"]:hover, button:hover {
  background: #d9d9d9;
  color: #000;
}
input[type="submit"][disabled], input[type="reset"][disabled], button[disabled], html input[disabled] {
  background: #e6e6e6;
  color: #b3b3b3;
  cursor: default;
}
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
input[type="search"] {
  -webkit-appearance: textfield;
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box;
  box-sizing: content-box;
}
input[type="text"], input[type="password"], input[type="email"], input[type="url"], input[type="phone"], input[type="tel"], input[type="number"], input[type="datetime"], input[type="date"], input[type="month"], input[type="color"], input[type="time"], input[type="search"], input[type="range"], input[type="file"], input[type="datetime-local"], select, textarea {
  border: 1px solid #ccc;
  margin-bottom: 1.2rem;
  padding: 0.4rem 0.6rem;
}
input[type="checkbox"], input[type="radio"] {
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  float: left;
  line-height: 1.8;
  margin-right: 0.6rem;
  margin-top: 0.8rem;
  padding: 0;
}
button, [type=submit], input[type="submit"], input[type="button"], input[type="reset"] {
  -moz-appearance: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-appearance: none;
  -webkit-transition: all 60ms ease-in-out;
  -webkit-user-select: none;
  appearance: none;
  background: #333030;
  border-radius: 4px;
  border: 0 none;
  color: #f2f2f2;
  cursor: pointer;
  font-family: inherit;
  font-weight: 500;
  line-height: 1.3;
  margin: 10px;
  overflow: hidden;
  padding: 12px 12px;
  text-align: center;
  text-decoration: none !important;
  text-transform: none;
  transition: all 60ms ease-in-out;
  user-select: none;
  white-space: nowrap;
}
button:hover, input[type="submit"]:hover, input[type="reset"]:hover, [type=submit]:hover {
  -webkit-transition: all 60ms ease;
  transition: all 60ms ease;
  opacity: .85;
}
button:active, [type=submit]:active {
  -webkit-transition: all 60ms ease;
  transition: all 60ms ease;
  -webkit-transform: scale(0.97);
  transform: scale(0.97);
  opacity: .75;
}
button:focus, [type=submit]:focus {
  outline: none;
}

/* img */

img {
  max-width: 100%;
  height: auto;
  vertical-align: middle;
}

/* Media queries? Okay, fine… */

@media (max-width: 767px) {
  body {
    padding: 18px;
  }
  article {
    border-radius: 0;
    margin: -18px;
    padding: 18px;
  }
  textarea, input, select {
    max-width: 100%;
  }
  fieldset {
    min-width: 0;
  }
  section {
    width: auto;
  }
  fieldset, x:-moz-any-link {
    display: table-cell;
  }
}
@media (min-width: 550px) {
  h1 {
    font-size: 4.0rem;
  }
  h2 {
    font-size: 3.6rem;
  }
  h3 {
    font-size: 2.2rem;
  }
  h4 {
    font-size: 2.4rem;
  }
  h5 {
    font-size: 1.8rem;
  }
  h6 {
    font-size: 1.6rem;
  }
}
@media print {
  pre, blockquote {
    border: 1px solid #999 !important;
    page-break-inside: avoid !important;
  }
  tr, img {
    page-break-inside: avoid !important;
  }
  img {
    max-width: 100% !important;
  }
  @page {
    margin: .5cm !important;
  }
  p, h2, h3 {
    orphans: 3 !important;
    widows: 3 !important;
  }
  h2, h3 {
    page-break-after: avoid !important;
  }
  thead {
    display: table-header-group !important;
  }
  * {
    background: transparent !important;
    color: #000 !important;
    text-shadow: none !important;
    -webkit-filter: none !important;
    filter: none !important;
  }
  p a[href]:after {
    content: " (" attr(href) ")" !important;
  }
  p abbr[title]:after {
    content: " (" attr(title) ")" !important;
  }
  p a[href^="javascript:"]:after, p a[href^="#"]:after {
    content: "" !important;
  }
  p a, p abbr {
    word-wrap: break-word !important;
    text-decoration: underline !important;
  }
}


/* screen.css */
/* general */
html {
  height: 100%;
  max-height: 100%;
  font-size: 62.5%;
}

body {
  height: 100%;
  max-height: 100%;
  font-family: "Merriweather", serif;
  font-weight: 300;
  font-size: 1.6rem;
  line-height: 1.3em;
}

::-moz-selection {
  color: #222;
  background: #D6EDFF;
  text-shadow: none;
}

::selection {
  color: #222;
  background: #D6EDFF;
  text-shadow: none;
}

h1, h2, h3, h4, h5, h6 {
  text-rendering: optimizeLegibility;
  line-height: 1;
  margin-top: 0;
}

h1 {
  font-size: 3rem;
  line-height: 1.2em;
  letter-spacing: -2px;
  text-indent: -3px;
  font-weight: 700;
  font-family: "Cardo", serif;
}

h2 {
  font-size: 2.1rem;
  line-height: 1.2em;
  letter-spacing: -1px;
  text-indent: -2px;
  font-weight: 400;
}

h3 { font-size: 1.6rem; font-weight: 400; }
h4 { font-size: 1.4rem; font-weight: 400; }
h5 { font-size: 1.2rem; font-weight: 400; }
h6 { font-size: 1.1rem; font-weight: 400; }
a { color: #94c498; text-decoration: none; }
a:hover { color: #64dbbb; text-decoration: underline; }
h1 a, h2 a, h3 a, h4 a, h5 a, h6 a { color: #94c498; }
p, ul, ol { margin: 1.6em 0; }
ol ol, ul ul, ul ol, ol ul { margin: 0.4em 0; }
blockquote p { margin: 0.8em 0; font-style: italic; }
blockquote small:before { content: '\2014   \A0'; }
blockquote cite { font-weight:bold; }
blockquote cite a { font-weight: normal; }
dl { margin: 1.6em 0; }
dl dd { margin-left: 200px; margin-bottom: 1em }
mark { background-color: #ffc336; }

hr {
  display: block;
  height: 1px;
  border: 0;
  border-top: 1px solid #483f62;
  margin: 3.2em 0;
  padding: 0;
}

blockquote {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1.6em 0;
  padding: 0 0 0 1.6em;
  border-left: #666666 0.4em solid;
  color: #666666;
  font-family: "Cardo", serif;
  font-style: italic;
}

blockquote small {
  display: inline-block;
  margin: 0.8em 0 0.8em 1.5em;;
  font-size:0.9em;
  color: #ccc;
}

dl dt {
  float: left;
  width: 180px;
  overflow: hidden;
  clear: left;
  text-align: right;
  text-overflow: ellipsis;
  white-space: nowrap;
  font-weight: bold;
  margin-bottom: 1em
}

code, tt {
  padding: 1px 3px;
  font-family: 'Hasklig', 'Fira Code', 'Fantasque Sans Mono', 'Hack', monospace;
  font-size: 0.85em;
  white-space: pre;
  border: 1px solid #444;
  border-radius: 2px;
}

pre {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1.6em 0;
  border: 1px solid #444444;
  width: 100%;
  padding: 10px;
  font-family: 'Hasklig', 'Fira Code', 'Fantasque Sans Mono', 'Hack', monospace;
  font-size: 0.9em;
  white-space: pre;
  overflow: auto;
  border-radius: 3px;
}

pre code, tt {
  font-size: inherit;
  white-space: -moz-pre-wrap;
  white-space: pre-wrap;
  background: transparent;
  border: none;
  padding: 0;
}

kbd {
  display: inline-block;
  margin-bottom: 0.4em;
  padding: 1px 8px;
  border: #ccc 1px solid;
  color: #666;
  text-shadow: #fff 0 1px 0;
  font-size: 0.9em;
  font-weight: bold;
  background: #f4f4f4;
  border-radius: 4px;
  box-shadow:
  0 1px 0 rgba(0, 0, 0, 0.2),
  0 1px 0 0 #fff inset;
}

table {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1.6em 0;
  width:100%;
  max-width: 100%;
  background-color: transparent;
}

table th, table td {
  padding: 8px;
  line-height: 20px;
  text-align: left;
  vertical-align: top;
  border-top: 1px solid #efefef;
}

table th { color: #000; }
table tbody + tbody { border-top: 2px solid #efefef; }
table table table { background-color: #fff; }

table caption + thead tr:first-child th,
table caption + thead tr:first-child td,
table colgroup + thead tr:first-child th,
table colgroup + thead tr:first-child td,
table thead:first-child tr:first-child th,
table thead:first-child tr:first-child td {
  border-top: 0;
}

table tbody > tr:nth-child(odd) > td,
table tbody > tr:nth-child(odd) > th {
  background-color: #f6f6f6;
}

table.plain {
  tbody > tr:nth-child(odd) > td,
  tbody > tr:nth-child(odd) > th {
    background: transparent;
  }
}


/* classes */
.post-card {
  margin-bottom: 3em;
}
</style><script type="text/javascript" href="/assets/highlight.pack.js"></script><link rel="stylesheet" type="text/css" href="/assets/github-gist.css"/></head><body><header><h1><a href="/blog">Zac Anger&#x27;s Blog</a></h1><h2>streams</h2><div>Saturday, May 14, 2016</div></header><div><div><p>bits and pieces of notes on streams</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> foo = fetch(<span class="hljs-string">'/something'</span>)
.then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.json())
.then(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> d.thingwewant)

<span class="hljs-keyword">const</span> bar = fetch(<span class="hljs-string">'/otherstuff'</span>)
.then(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.body)

<span class="hljs-keyword">const</span> stream = someTaggedFunctionThing<span class="hljs-string">`
  &lt;div&gt;<span class="hljs-subst">${foo}</span>&lt;/div&gt;
  &lt;span&gt;<span class="hljs-subst">${bar}</span>&lt;/span&gt;`</span>
</code></pre>
<ul>
<li>streams can be infinite</li>
<li>you can be aware of the beginning and end of a stream</li>
<li>unread values are buffered (unlike how events pre-listener(s) are just gone)</li>
<li>piping</li>
<li>error-handling (down the pipeline)</li>
<li>cancellation (up the pipeline)</li>
<li>flow control (react to the reader speed)</li>
<li>one reader per stream</li>
<li>untapped stream can be used like <code>tee</code></li>
</ul>
<p>with <code>fetch</code>, <code>result.value</code> is always of type <code>Uint8Array</code> (binary; use <code>TextDecoder</code>
on that if text content expected).</p>
<p>there may be transform streams implemented in the browser at some point (r/w).</p>
<p><code>reader.cancel()</code> (or <code>response.body.cancel()</code> if fetch)</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">new</span> ReadableStream({
  start(controller){} <span class="hljs-comment">// called immediately</span>
, pull(controller){}  <span class="hljs-comment">// called when buffer isn't full; called until buffer is full</span>
, cancel(reason){}    <span class="hljs-comment">// called if stream is cancelled</span>
}, queuingStrategy)   <span class="hljs-comment">// how the stream buffers (default : one item)</span>

</code></pre>
<ul>
<li><code>controller.enqueue(something)</code> queues <code>something</code> in the stream's buffer</li>
<li><code>controller.close()</code> ends</li>
<li><code>controller.error(e)</code> sends <code>e</code> (is a terminal error)</li>
<li><code>controller.desiredSize</code> amount of buffer left (can be negative if overfilled)
<ul>
<li><code>queuingStrategy</code> is used to get this</li>
</ul>
</li>
<li>you could call <code>controller.enqueue()</code> whenever there's data to send (stream as a push source)</li>
<li>you could wait until there's a <code>pull</code> called, then queue up some data (pull source)</li>
<li>you can do whatever you like (basically)</li>
<li>staying within the bounds of <code>controller.desiredSize</code> and having backpressure on the source
is good/efficient. won't break anything if you don't, though, unless you run out of memory.</li>
</ul>
<p>html renders as it's received (no matter how it gets there). so fetching/compiling/whatevering
markup on the fly (aka client-side rendering, aka the devil usually) without streams means
slowness.</p>
<p>here's a thing basically just copied out of jake archibald's blog. it's like this because we
don't have a <code>.pipe()</code> in the browser. we need that.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> stream = <span class="hljs-keyword">new</span> ReadableStream({
  start(controller){
    <span class="hljs-comment">// start and end from cache, middle from network with cache fallback</span>
    <span class="hljs-keyword">const</span>
      start = caches.match(<span class="hljs-string">'/start-cached'</span>)
    , end   = caches.match(<span class="hljs-string">'/end-cached'</span>)
    , mid   = fetch(<span class="hljs-string">'/middle'</span>)
        .catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> caches.match(<span class="hljs-string">'/middle-cached'</span>))
      push  = <span class="hljs-function"><span class="hljs-params">stream</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> reader = stream.getReader()
      <span class="hljs-keyword">return</span> reader.read().then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">process</span>(<span class="hljs-params">result</span>)</span>{
        <span class="hljs-keyword">if</span> (result.done) {
          <span class="hljs-keyword">return</span>
        }
        controller.enqueue(result.value)
        <span class="hljs-keyword">return</span> reader.read().then(process)
      })
    }

    start.then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> push(response.body))
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> mid).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> push(response.body))
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> end).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> push(response.body))
    .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> controller.close())
  }
})
</code></pre>
<p>From here down I'll probably just be taking notes on streams in Node.</p>
<p>Some important things to remember (for me to remember, that is) -- differences between the
proposed Stream and Node's streams:</p>
<ul>
<li>Readable
<ul>
<li><code>.read()</code> instead of <code>.on('readable')</code></li>
<li>Also a sync <code>.read()</code></li>
<li>Cancellation semantics added</li>
<li><code>desiredSize</code></li>
<li><code>tee</code>ing built in</li>
<li><code>data</code> event fully gone (it's only in Node streams in compatability mode, btw)</li>
<li><code>pause</code> and <code>resume</code> aren't a thing</li>
<li>no <code>unshift</code></li>
<li>binary/string/object mode switching isn't a thing</li>
<li>size parameter is gone (use BYOB readers)</li>
</ul>
</li>
<li>Writable
<ul>
<li>No cork/uncork</li>
</ul>
</li>
<li>Transform
<ul>
<li>now just <code>{readable, writable}</code> rly</li>
</ul>
</li>
<li>other
<ul>
<li>promises instead of cbs</li>
<li>no enc/dec built-in</li>
<li><code>pipeTo(writable)</code> and <code>pipeThrough(transform)</code> instead of just <code>pipe()</code>
<ul>
<li>so <code>source.pipeThrough(thing).pipeTo(destination)</code> is syntactic sugar for
<code>source.pipeTo(thing.writable) ; thing.readable.pipeTo(destination)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Okay, so, Node streams.</p>
<ul>
<li><code>req</code> and <code>res</code> are streams</li>
<li><code>.pipe()</code> listens for 'data' and 'end' from fs streams</li>
<li><code>.pipe()</code> handles backpressure for ya</li>
<li>types of streams:
<ul>
<li>readable</li>
<li>writable</li>
<li>transform</li>
<li>duplex</li>
<li>'classic'</li>
</ul>
</li>
<li>chain pipes, don't break crap out
<ul>
<li><code>one.pipe(two).pipe(three)</code>, not <code>one.pipe(two);two.pipe(three);</code></li>
<li>that's basically the same as <code>one | two | three</code></li>
</ul>
</li>
</ul>
<pre><code class="hljs language-javascript"><span class="hljs-comment">//</span>
<span class="hljs-comment">// readable</span>
<span class="hljs-comment">//</span>

<span class="hljs-keyword">const</span> Readable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).Readable
<span class="hljs-keyword">const</span> rs = <span class="hljs-keyword">new</span> Readable
rs.push(<span class="hljs-string">'something, and '</span>)
rs.push(<span class="hljs-string">'something else.'</span>)
rs.push(<span class="hljs-literal">null</span>) <span class="hljs-comment">// this tells data consumers that we're done with rs</span>
rs.pipe(process.stdout)
<span class="hljs-comment">// so the pushes are buffered until a consumer wants them (the pipe to standard out)</span>

<span class="hljs-comment">// instead of buffering:</span>
<span class="hljs-keyword">let</span> c = <span class="hljs-number">100</span>
rs._read = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  rs.push(<span class="hljs-built_in">String</span>.fromCharCode(c++))
  <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-string">'z'</span>.charCodeAt(<span class="hljs-number">0</span>)) {
    rs.push(<span class="hljs-literal">null</span>)
  }
}
rs.pipe(process.stdout)
<span class="hljs-comment">// ._read can take a size param, the amount (in bytes) that the consumer wants</span>
<span class="hljs-comment">// to call it like that, try `node thisfile | head -cN` where `N` is an integer</span>
<span class="hljs-comment">// note that we'd need to set up an error handler here because there'll be a SIGPIPE</span>
<span class="hljs-comment">// after `head` (EPIPE in node). that's not an issue when keeping your business all</span>
<span class="hljs-comment">// in node.</span>
<span class="hljs-comment">// `Readable({objectMode : true})` to be able to push arbitrary stuff (not just</span>
<span class="hljs-comment">// buffers and strings).</span>

process.stdin.on(<span class="hljs-string">'readable'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> buf = process.stdin.read()
  <span class="hljs-built_in">console</span>.dir(buf)
})
<span class="hljs-comment">// echo stuff, pipe it, eg `(echo foo ; echo bar ; sleep 10 ; echo asdfghjkl) | node this-script.js`</span>
<span class="hljs-comment">// usually we'd probably pipe a stream into another stream, maybe using through2 or somesuch</span>
<span class="hljs-comment">// the above will return null at the end of what's being sent, because there's nothing left</span>
<span class="hljs-comment">// we could do `.read(N)` where `N` is bytes. doesn't work for object streams.</span>
process.stdin.on(<span class="hljs-string">'readable'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> buf = process.stdin.read(<span class="hljs-number">2</span>)
  <span class="hljs-built_in">console</span>.dir(buf) <span class="hljs-comment">// so we'd get 2-byte chunks here. adding:</span>
  process.stdin.read(<span class="hljs-number">0</span>) <span class="hljs-comment">// will get the rest and make this actually work.</span>
})

<span class="hljs-comment">// YAY, that's it for readable streams</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// writable</span>
<span class="hljs-comment">//</span>

<span class="hljs-keyword">const</span> Writable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>).Writable
<span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> Writable()
ws._write = <span class="hljs-function">(<span class="hljs-params">chunk, encoding, next</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.dir(chunk)
  next()
}
process.stdin.pipe(ws)
<span class="hljs-comment">// chunk is the data written</span>
<span class="hljs-comment">// encoding (string) is only for when `opts.decodeStrings` is false and we've been given a string</span>
<span class="hljs-comment">// the third arg is cb, tells consumer to go ahead and write more. it can take an err obj</span>
<span class="hljs-comment">// if input stream is string, that'll be converted to buf. when creating the stream we can do</span>
<span class="hljs-keyword">const</span> strWs = <span class="hljs-keyword">new</span> Writable({<span class="hljs-attr">decodeStrings</span> : <span class="hljs-literal">false</span>})
<span class="hljs-comment">// and if we're getting in objects</span>
<span class="hljs-keyword">const</span> objWs = <span class="hljs-keyword">new</span> Writable({<span class="hljs-attr">objectMode</span> : <span class="hljs-literal">true</span>})

<span class="hljs-comment">// writing is basically as simple as calling .write (as we do with stdout)</span>
<span class="hljs-comment">// you can do a .end() to say we're done. that can take data to write, right before ending.</span>
<span class="hljs-comment">// write returns false when there's more data in incoming buff than opts.highWaterMark;</span>
<span class="hljs-comment">// listen for drain event to know when it's empty</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// transform</span>
<span class="hljs-comment">// these are duplex streams that do exactly what it sounds like. sometimes called 'through' streams.</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// duplex</span>
<span class="hljs-comment">// r/w where both ends are two-way. example: `x.pipe(y).pipe(x)`</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// classic streams</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// we're on node 6.1.0 as of this writing, and chances are i won't be doing much node stuff</span>
<span class="hljs-comment">// at all in the forseeable future, so i really don't care too too much about the legacy</span>
<span class="hljs-comment">// streams api. just `require('readable-stream')` instead of `'stream'`, if we must support</span>
<span class="hljs-comment">// node or other streams from &lt;=v0.8.</span>

<span class="hljs-comment">// readable example:</span>
<span class="hljs-keyword">const</span> sin = process.stdin
sin.on(<span class="hljs-string">'data'</span>, buf =&gt; <span class="hljs-built_in">console</span>.log(buf))
sin.on(<span class="hljs-string">'end'</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'peace'</span>))
<span class="hljs-comment">// as soon as a data listener is registered, you're using compatability mode, so</span>
<span class="hljs-comment">// basically you lose a lot of functionality.</span>
<span class="hljs-comment">// through (the package) lets you use legacy streams with pipe</span>
<span class="hljs-comment">// these also have pause and resume.</span>

<span class="hljs-comment">// writable:</span>
<span class="hljs-comment">// define write(buf), end(buf), and destroy(). end doesn't HAVE to have (buf), but</span>
<span class="hljs-comment">// it should work so that stream.end(buf) means stream.write(buf) ; stream.end(), so just do that.</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// streams that are built in to node</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// not gonna take really extensive notes here, for the reasons above and also because</span>
<span class="hljs-comment">// it's really easy to just go to the api docs and read all of them.</span>

</code></pre>
</div><p><a href="https://github.com/zacanger/dotcom/issues/new?title=streams" target="_blank">Submit a bug report</a></p></div><footer>Made by <a href="/">Zac Anger</a><br/><br/><a href="/blog/rss.xml">Feed</a> · <a href="/LICENSE.txt">License</a> · <a href="https://github.com/zacanger">GitHub</a> · <a href="https://twitter.com/zacanger">Twitter</a> · <a href="https://mastodon.social/@zacanger">Mastodon</a></footer></body></html>