<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[zac anger - angr]]></title><description><![CDATA[writings from zac anger]]></description><link>http://blog.zacanger.com/</link><generator>Ghost</generator><lastBuildDate>Fri, 07 Jul 2017 03:38:55 GMT</lastBuildDate><atom:link href="http://blog.zacanger.com/author/blog/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[2017 todo list]]></title><description><![CDATA[<p>I&#39;m re-posting NY resolutions as a checklist, post-dated for the end of this year.</p>
<p>Some things will be ongoing tasks, and won&#39;t be checked off until I feel like
I&#39;ve been consistent with them for several months at the least.</p>
<p>I may add things to this list, but won&#39;t delete any.</p>
<p>The checklist is using GFM, which this blog generator doesn&#39;t understand. (That&#39;s on the list.)</p>
<h2 id="things-i-hope-to-maybe-do-in-2017">things i hope to maybe do in 2017</h2>
<ul>
<li>[ ] Work less at work<ul>
<li>[ ] Mainly, stop working on weekends and in the middle of the night and stuff</li>
</ul>
</li>
<li>[ ] Get familiar these languages to write real-world stuff<ul>
<li>[ ] Racket</li>
<li>[x] ClojureScript</li>
<li>[ ] Haskell</li>
</ul>
</li>
<li>[x] Learn more about <code>sh</code> and POSIX compat in general<ul>
<li>[ ] Also convert as much of my dotfiles as possible to use <code>sh</code> instead of <code>bash</code></li>
<li>[x] Also weed out my dotfiles, they&#39;re ridiculous</li>
</ul>
</li>
<li>[ ] At least record the acoustic album that&#39;s been written and sitting there for ages</li>
<li>[ ] Maybe get Windows working enough to finish up the electro album thing</li>
<li>[ ] Be healther<ul>
<li>[ ] Switch to vaping, for real this time</li>
<li>[x] Maybe eat better?<ul>
<li>[x] Less pizza, at least</li>
</ul>
</li>
</ul>
</li>
<li>[x] Finish paying off debts, so close<ul>
<li>[x] Also try not to tap into savings so much for stupid things</li>
</ul>
</li>
<li>[ ] Change how this blog is built, so it&#39;s more flexible, and maybe using something fun like Frog (using GFM).<ul>
<li>[ ] Also, blog more (at least, clear out my <code>drafts</code> dir).</li>
</ul>
</li>
<li>[x] Be making more money<ul>
<li>[x] Preferably where I am now, but somewhere else if that doesn&#39;t work out</li>
<li>[x] Also start actually emailing recruiters back</li>
</ul>
</li>
<li>[ ] Actually finish anything ever<ul>
<li>[x] Various unfinished small projects</li>
<li>[ ] Finish Pharaoh rewrite early on</li>
</ul>
</li>
<li>[x] Make progress on learning Korean, for real this time</li>
<li>[x] Try really hard to not write any untested code</li>
<li>[x] Make a real effort to talk to real humans in real life</li>
<li>[x] Take the time to move all things using Facebook auth away from this</li>
<li>[x] Delete Facebook</li>
<li>[x] Get more tattoos</li>
</ul>
]]></description><link>/2017/new-years-resolutions.html</link><guid isPermaLink="true">/2017/new-years-resolutions.html</guid><category><![CDATA[personal]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sun, 31 Dec 2017 06:59:59 GMT</pubDate></item><item><title><![CDATA[a short rant about languages and people]]></title><description><![CDATA[<p>I wrote this on <a href="https://mastodon.social/@zacanger">Mastodon</a> but decided
to cross-post for whatever reason.</p>
<p>One of my biggest pet peeves is when people talk about how great foo-lang is as
an alernative to bar-lang, &amp; it turns out they&#39;re just shit at bar-lang, or
write deliberately bad bar-lang in examples to try to make foo-lang look better.
Don&#39;t do that. If you can&#39;t write decent, idiomatic bar-lang, you don&#39;t get to
hate it yet. If you <em>can</em> and are writing it like someone who&#39;s never read a
tutorial on it intentionally, you&#39;re just making foo-lang&#39;s community look like
assholes.  Chances are foo-lang is pretty great, &amp; can stand up on its own
merits. Talk about those, not how bad your half-assed bar-lang is in comparison.
I see this a lot with functional languages that compile to JS, especially, &amp;
it&#39;s sad, because most of those languages are actually really neat &amp; there are a
lot of good reasons to try them, but people saying &#39;look how horrible this JS is
compared to this other thing&#39; when the JS looks like it was written by someone
who skimmed a jQuery tutorial once <em>really</em> doesn&#39;t present the community very
well. So don&#39;t do that.</p>
<p>Also: a fun vim/Twitter trick (I also cross-posted this to
<a href="https://twitter.com/zacanger">Twitter</a> ): <code>:set textwidth=140</code>, then <code>gq</code>.
You&#39;re welcome.</p>
]]></description><link>/2017/short-rant-on-languages.html</link><guid isPermaLink="true">/2017/short-rant-on-languages.html</guid><category><![CDATA[lang]]></category><category><![CDATA[community]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 20 May 2017 03:13:00 GMT</pubDate></item><item><title><![CDATA[WTF is Set?]]></title><description><![CDATA[<h1 id="wtf-is-set-">WTF is Set?</h1>
<p>Please excuse the funky syntax highlighting in this post. Apparently
the thing my blog uses for that doesn&#39;t know what to do about template strings.</p>
<p>So, someone asked in a Slack channel how they might clean up the following code:</p>
<pre class="hljs"><code>getNames (contacts) {
  <span class="hljs-built_in">let</span> contacts_<span class="hljs-built_in">set</span> = []

  contacts.forEach((contact) =&gt; {
    <span class="hljs-built_in">let</span> firstName = get(contact, <span class="hljs-string">&#39;contactInfo.firstName&#39;</span>)
    <span class="hljs-built_in">let</span> lastName  = get(contact, <span class="hljs-string">&#39;contactInfo.lastName&#39;</span>)
    <span class="hljs-built_in">let</span> fullName = `<span class="hljs-variable">${firstName}</span> <span class="hljs-variable">${lastName}</span>`

    <span class="hljs-keyword">if</span> (contacts_set.includes(fullName)) {
      <span class="hljs-built_in">return</span>
    } <span class="hljs-keyword">else</span> {
      contacts_set.push(fullName)
    }

    <span class="hljs-built_in">set</span>(this, <span class="hljs-string">&#39;contactsSet&#39;</span>, contactsSet)
  })
}</code></pre><p>Note that the <code>get</code> and <code>set</code> going on here seemed to be Ember-specific. I don&#39;t
know Ember so don&#39;t ask me.</p>
<p>And I said, how about this?</p>
<pre class="hljs"><code><span class="hljs-attribute">getNames</span>: <span class="hljs-function"><span class="hljs-params">(contacts)</span> =&gt;</span>
  [...<span class="hljs-keyword">new</span> Set(
    contacts.map(<span class="hljs-function"><span class="hljs-params">({ contactInfo: { firstName, lastName }})</span> =&gt;</span>
      `<span class="javascript">${firstName} ${lastName}</span>`))]</code></pre><p>I like this version because it&#39;s very concise and still readable (to me).
It also doesn&#39;t do mutation-y stuff, which is a good thing.</p>
<p>And then someone else asked:</p>
<blockquote>
<p>Can some one eli5 what <code>Set</code> is that&#39;s referenced above?</p>
</blockquote>
<p>Which made me realise that a lot of folks still aren&#39;t using a lot of the nice
new things from ES2015, so I explained a bit. Here&#39;s how I understand it.</p>
<p>Set is a new (in ES2015) iterable builtin (like Array, String, TypedArray). Map
is also new in 2015. Set is to Array as Map is to Object, kinda.</p>
<p>For practical usage Set is basically Array but unique, and with different
methods. <code>add</code>, <code>has</code>, <code>delete</code>, <code>size</code>, and some others. There&#39;s a lot more
info <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">on MDN</a>.</p>
<p>You can pass <code>Set</code> an iterable, which is why the thing I have above works
(because thing inside <code>new Set()</code> results in an array).</p>
<p>In that case <code>Set</code> isn&#39;t being used for too much besides just the fact that it&#39;s
<code>Set</code> (so it only holds unique values). Someone else pointed out in the same
channel that maybe it&#39;s not the best idea if you have a lot of values, because
then you&#39;re creating another thing, which is totally true.</p>
<p>There&#39;s a bit more background
<a href="https://en.wikipedia.org/wiki/Set_(mathematics">here</a>) on what JS&#39;s <code>Set</code> is
suppose to be kind of like.</p>
<p>And underneath it sorta looks vaguely like this:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> Set {
  <span class="hljs-constructor"><span class="hljs-keyword">constructor</span> () </span>{
    <span class="hljs-keyword">this</span>.storage = []
  }
  add (a) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.storage.includes(a)) {
      <span class="hljs-keyword">this</span>.storage.push(a)
    }
  }
  has (a) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.storage.includes(a)
  }
  remove (a) {
    <span class="hljs-keyword">this</span>.storage.splice(<span class="hljs-keyword">this</span>.storage.indexOf(a), <span class="hljs-number">1</span>)
  }
}</code></pre><p>That&#39;s a lot of stuff, but mostly you can think of <code>Set</code> as a thing that&#39;s like
<code>Array</code> but it only holds unique things.</p>
<p>There&#39;s also a <code>WeakSet</code> which can only hold objects. I haven&#39;t really found a
valid use case for <code>WeakSet</code> and <code>WeakMap</code> yet, personally.</p>
<p><code>Set</code> turns out to be pretty useful. I&#39;ve used it a few times <a href="https://jane.com">at
work</a> (with appropriate polyfills) without any problems, and I
use it in a few places in <a href="https://github.com/zacanger/zeelib">zeelib</a>, my
sort-of-sometimes-popular utility library. Definitely play around with it!</p>
]]></description><link>/2017/wtf-is-set.html</link><guid isPermaLink="true">/2017/wtf-is-set.html</guid><category><![CDATA[js]]></category><category><![CDATA[es2015]]></category><category><![CDATA[set]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Wed, 26 Apr 2017 05:00:00 GMT</pubDate></item><item><title><![CDATA[Recommendations For New Web Devs]]></title><description><![CDATA[<h1 id="some-recommendations-for-new-web-developers">Some Recommendations for New (Web) Developers</h1>
<p>Some of these thoughts probably apply to all developers. Some don&#39;t.</p>
<ol>
<li>Learn an editor. It doesn&#39;t matter which editor. Just learn one. Be good at
it. I don&#39;t care if you use Visual Studio or Emacs or whatever. Be really
good at the thing you pick, though.</li>
<li>Learn enough <code>vi</code> to get by. You <em>will</em> need to know it, at some point. At
the very least, learn how to enter text, move around, save, quit, and quit
without saving.</li>
<li>Install <code>jq</code> (build it from source if you want the newest hotness; otherwise
install it with your package manager). Don&#39;t install the <code>jq</code> clones written
in other languages (not C) &mdash; most of them are slow and/or only
half-finished.</li>
<li>Get comfortable with Bash. You don&#39;t have to be great with it, just know
enough to get by. It doesn&#39;t matter what shell you actually use (Zsh, Ksh,
Bash, Sh, Dash, Ash, PowerShell &mdash; I don&#39;t care, whatever). If you&#39;re
writing stuff that&#39;s going to be run by other people, ever, write it in Bash.
If you&#39;re writing stuff that may or may not be run on a server, write it in
POSIX-compliant <code>sh</code>.</li>
<li>Spend some time on Twitter. Facebook is for finding out how your
middle-school best friend&#39;s back surgery went. LinkedIn is for collecting
recruiter spam just in case. Twitter is for following people who say things
that matter, so get on Twitter.</li>
<li>No one cares if you can&#39;t afford a Mac. Macs aren&#39;t great computers, they&#39;re
okay computers that are very expensive. If you can&#39;t afford a Mac, try Linux
(I recommend Debian with the XFCE desktop environment, but try other things
too if you want!). If you don&#39;t have time for that, Windows is also okay
(just remember to tell your editor and Git to use UNIX-style line-endings).</li>
<li>Don&#39;t work (for your employer) on the weekends. Work on side projects, if you
want. Or do other things. Go out to brunch. Climb a mountain. Learn a Primus
song on bass. Get drunk. Just don&#39;t work for the person who pays you to work
during the week. If they seem to expect you to be working when you&#39;re not at
work, start looking for another job.</li>
<li>Learn other languages. HTML and CSS are not programming languages, so they
don&#39;t count. JS is actually a really great language (so don&#39;t take shit from
Java or C# developers who bitch about it!), but it&#39;s only one language. Learn
another language that helps you think about what you do in a different way.
Scheme (specifically, Racket) is a really nice one to start with. Haskell is
interesting (or some other ML-type language, like OCaml or Purescript). C is
also really useful to know, even if you only ever learn enough to write a
basic shell or something.</li>
<li>Figure out your own method for managing tasks. Chances are, you&#39;ll work for
more than one company over the next few years. Your employer might be really
into Jira, or Trello, or whatever, or they might change their mind four times
a year, but either way, getting heavily invested in one tool is not a great
idea. Use their thing, but also figure out what works for you. I keep track
of tasks for work in plain Markdown files, and I use
<a href="http://npm.im/lilnote">lilnote</a> for personal tasks. Just find a thing you
like and stick with it.</li>
<li>Make time for personal development. Including on the clock. If your employer
doesn&#39;t like that you spend a half hour every morning catching up on what new
flags Chromium shipped, or competing on Codewars, or whatever other technical
thing happens to really interest you but might also benefit your company,
start looking for another job.</li>
</ol>
]]></description><link>/2017/recommendations-for-new-web-devs.html</link><guid isPermaLink="true">/2017/recommendations-for-new-web-devs.html</guid><category><![CDATA[devmtn]]></category><category><![CDATA[thoughts]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sun, 26 Mar 2017 22:00:00 GMT</pubDate></item><item><title><![CDATA[PropTypes for Classnames]]></title><description><![CDATA[<p>The <a href="https://npmjs.com/package/classnames">classnames</a> library is nice.
It lets you do stuff like</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> cn <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;classnames&#39;</span>
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./styles.css&#39;</span>

<span class="hljs-keyword">const</span> Thing = ({ foo }) =&gt;
  &lt;Stuff className={cn(styles.thing, { [styles.foo]: foo !== <span class="hljs-number">2</span> })} /&gt;</code></pre><p>And a whole bunch of other stuff, and it just works. If you write your CSS
in CSS, you should check it out.</p>
<p>There is one sort of pain point with it, though. If you have components that
can take anything that&#39;s <code>classnames</code>-compatible, PropTypes get a little annoying.</p>
<pre class="hljs"><code><span class="hljs-constant">Stuff.propTypes</span> = { className: <span class="hljs-built_in">string</span>.isRequired }</code></pre><p>This doesn&#39;t work, because you&#39;re passing all sorts of stuff in, possibly.</p>
<p>A solution is to make your own custom PropTypes. You don&#39;t even need to
get into fancy stuff involving validation, just combine a bunch of other
PropTypes into your own.</p>
<p>Let&#39;s say you have a <code>propTypes.js</code> file somewhere where you define custom
PropTypes.</p>
<pre class="hljs"><code>import { PropTypes } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>

export <span class="hljs-keyword">const</span> classname = PropTypes.oneOfType([
  PropTypes.<span class="hljs-keyword">object</span>,
  PropTypes.<span class="hljs-keyword">string</span>,
  PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.array,
      PropTypes.<span class="hljs-keyword">bool</span>,
      PropTypes.<span class="hljs-keyword">object</span>,
      PropTypes.<span class="hljs-keyword">string</span>
    ])
  )
])</code></pre><p>That&#39;s all you need! Then you can do:</p>
<pre class="hljs"><code>import { <span class="hljs-built_in">classname</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./propTypes&#39;</span>
import cn <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;classnames&#39;</span>

const Stuff = ({ <span class="hljs-built_in">className</span> }) =&gt;
  &lt;span <span class="hljs-built_in">className</span>={cn(<span class="hljs-built_in">className</span>)}&gt;

Stuff.propTypes = {
  <span class="hljs-built_in">className</span>: <span class="hljs-built_in">classname</span> <span class="hljs-comment">// this is your custom thing</span>
}</code></pre><p>That should solve all PropTypes warnings and let you throw anything the
<code>classnames</code> library can handle at your components.</p>
]]></description><link>/2017/proptypes-for-classnames.html</link><guid isPermaLink="true">/2017/proptypes-for-classnames.html</guid><category><![CDATA[react]]></category><category><![CDATA[proptypes]]></category><category><![CDATA[classnames]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 11 Feb 2017 17:30:00 GMT</pubDate></item><item><title><![CDATA[new years resolutions]]></title><description><![CDATA[<h2 id="things-i-hope-to-maybe-do-in-2017">things i hope to maybe do in 2017</h2>
<ul>
<li>Work less at work<ul>
<li>Mainly, stop working on weekends and in the middle of the night and stuff</li>
</ul>
</li>
<li>Get familiar enough with Racket, ClojureScript, and Haskell to write real-world stuff</li>
<li>Learn more about <code>sh</code> and POSIX compat in general<ul>
<li>Also convert as much of my dotfiles as possible to use <code>sh</code> instead of <code>bash</code></li>
<li>Also weed out my dotfiles, they&#39;re ridiculous</li>
</ul>
</li>
<li>At least record the acoustic album that&#39;s been written and sitting there for ages<ul>
<li>Maybe get Windows working enough to finish up the electro album thing</li>
</ul>
</li>
<li>Be slightly healther, at least<ul>
<li>Switch to vaping, for real this time</li>
<li>Maybe eat better?<ul>
<li>Less pizza, at least</li>
</ul>
</li>
</ul>
</li>
<li>Buy a car</li>
<li>Finish paying off debts, so close<ul>
<li>Also try not to tap into savings so much for stupid things</li>
</ul>
</li>
<li>Actually finish anything ever<ul>
<li>Various unfinished small projects</li>
<li>Finish Pharaoh rewrite early on</li>
</ul>
</li>
<li>Make progress on learning Korean, for real this time</li>
<li>Try really hard to not write any untested code</li>
<li>Make a real effort to talk to real humans in real life</li>
<li>Take the time to move all things using Facebook auth away from this, so I can finally delete my Facebook</li>
<li>Change how this blog is built, so it&#39;s more flexible, and maybe using something fun like Frog<ul>
<li>Also, blog more (at least, clear out my <code>drafts</code> dir).</li>
</ul>
</li>
<li>Be making more money<ul>
<li>Preferably where I am now, but somewhere else if that doesn&#39;t work out</li>
<li>Also start actually emailing recruiters back</li>
</ul>
</li>
<li>Switch to Mutt or some other purely text-based email client</li>
</ul>
]]></description><link>/2016/new-years-resolutions.html</link><guid isPermaLink="true">/2016/new-years-resolutions.html</guid><category><![CDATA[personal]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 31 Dec 2016 20:25:00 GMT</pubDate></item><item><title><![CDATA[Category Theory Notes]]></title><description><![CDATA[<h1 id="category-theory-for-js-devs">Category Theory for JS Devs</h1>
<p>Notes taken while watching <a href="https://www.youtube.com/playlist?list=PLwuUlC2HlHGe7vmItFmrdBLn6p0AS8ALX">this series</a>.</p>
<h2 id="contracts">Contracts</h2>
<p>Basics of type checking.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> str = a =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string">&#39;string&#39;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#39;Expected a string&#39;</span>)
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a
}</code></pre><h2 id="guarded-functions-and-categories">Guarded Functions and Categories</h2>
<p>Functions that have contracts on input or output are called <em>guarded</em> functions.</p>
<p>An <em>any</em> function might just look like an identity function (<code>const any = a =&gt; a</code>).</p>
<p>Maps between categories are functors.</p>
<p>The <em>objects</em> of categories are the <em>contracts</em>. <em>Morphisms</em> are the (guarded) functions.</p>
<p>Function that returns a contract:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> typeOf = type =&gt; a =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a !== <span class="hljs-string"><code>&lt;span class=&quot;hljs-subst&quot;&gt;${type}&lt;/span&gt;</code></span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string"><code>Expected &lt;span class=&quot;hljs-subst&quot;&gt;${type}&lt;/span&gt;!</code></span>)
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a
}</code></pre><p>And basic usage:</p>
<pre class="hljs"><code>const bool = <span class="hljs-function"><span class="hljs-title">typeOf</span><span class="hljs-params">(<span class="hljs-string">&#39;boolean&#39;</span>)</span></span>
const num  = <span class="hljs-function"><span class="hljs-title">typeOf</span><span class="hljs-params">(<span class="hljs-string">&#39;number&#39;</span>)</span></span>
<span class="hljs-comment">// etc.</span>
<span class="hljs-comment">// Obviously, for arrays you&#39;d need to use Array.isArray()</span></code></pre><p>Then we could do something like</p>
<pre class="hljs"><code>const increment = <span class="hljs-operator">a</span> =&gt; {
  <span class="hljs-operator">a</span> = <span class="hljs-built_in">num</span>(<span class="hljs-operator">a</span>)
  <span class="hljs-constant">return</span> <span class="hljs-operator">a</span> + <span class="hljs-number">1</span>
}</code></pre><p>Before I go further I should mention that yes, I have heard of Flow and TypeScript.</p>
<pre class="hljs"><code>const increment = (<span class="hljs-tag">a</span>: number) =&gt; <span class="hljs-tag">a</span> + <span class="hljs-number">1</span></code></pre><p>I assume this video series will get to actual type systems at some point, though
it was made before TypeScript and Flow were written, so it won&#39;t be mentioning those.</p>
<h2 id="array-contracts">Array Contracts</h2>
<p>Not using <code>isArray</code> or <code>instance of</code>. Using <code>toString</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> arr = a =&gt; {
  <span class="hljs-keyword">if</span> ({}.toString.call(a) !== <span class="hljs-string">&#39;[object Array]&#39;</span>) <span class="hljs-keyword">throw</span> TypeError(<span class="hljs-string">&#39;Expected array!&#39;</span>)
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a
}</code></pre><p>The same thing could be done for <code>Date</code>, <code>RegExp</code>, etc.</p>
<h2 id="functors">Functors</h2>
<p>Takes a maps the contract over the things array. Will throw if they&#39;re not all
correct. Ensure that your array is, for example, all Strings, or whatever.</p>
<pre class="hljs"><code>const arrayOf = contract =&gt; things =&gt; <span class="hljs-function"><span class="hljs-title">arr</span><span class="hljs-params">(things)</span></span>.<span class="hljs-function"><span class="hljs-title">map</span><span class="hljs-params">(c)</span></span></code></pre><p>This acts on the category&#39;s <em>objects</em> and <em>morphisms</em> both, and produces new
objects and new morphisms.</p>
<h2 id="maybe">Maybe</h2>
<p>The <em>Maybe</em> functor.</p>
<p><code>Maybe</code> is a Monad, but I guess we&#39;re only thinking of its Functor-ness for this
video?</p>
<p>Anyway here&#39;s some code.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> Maybe = () =&gt; {}
Maybe.prototype.getOrElse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Some) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a
}
<span class="hljs-comment">// the above: maybe something getOrElse what to do if none</span>

<span class="hljs-keyword">const</span> None = () =&gt; {}
None.prototype = <span class="hljs-built_in">Object</span>.create(Maybe.prototype) <span class="hljs-comment">// all instances of None are an instance of Maybe</span>
None.prototype.toString = () =&gt; <span class="hljs-string">&#39;None&#39;</span>
<span class="hljs-keyword">const</span> none = <span class="hljs-keyword">new</span> None()

<span class="hljs-keyword">const</span> Some = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{ <span class="hljs-keyword">this</span>.a = a }
Some.prototype = <span class="hljs-built_in">Object</span>.create(Maybe.prototype)
Some.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string"><code>Some(thisa)</code></span> }
<span class="hljs-keyword">const</span> some = a =&gt; <span class="hljs-keyword">new</span> Some(a)

<span class="hljs-keyword">const</span> maybe = c =&gt; m =&gt; {
  <span class="hljs-keyword">if</span> (m <span class="hljs-keyword">instanceof</span> None) <span class="hljs-keyword">return</span> m
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m instance <span class="hljs-keyword">of</span> Some) <span class="hljs-keyword">return</span> some((m.a))
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#39;Expected None or Some a!&#39;</span>)
}</code></pre><h2 id="unit-and-flatten">Unit and Flatten</h2>
<pre class="hljs"><code>const arrayOfUnit = contract =&gt; <span class="hljs-list">(
  <span class="hljs-keyword">a</span> =&gt; {
    a = contract<span class="hljs-list">(<span class="hljs-keyword">a</span>)</span>
    return arrayOf<span class="hljs-list">(<span class="hljs-keyword">contract</span>)</span><span class="hljs-list">([a])</span>
  }
)</span>

const maybeUnit = contract =&gt; <span class="hljs-list">(
  <span class="hljs-keyword">a</span> =&gt; {
    a = contract<span class="hljs-list">(<span class="hljs-keyword">a</span>)</span>
    return maybe<span class="hljs-list">(<span class="hljs-keyword">contract</span>)</span><span class="hljs-list">(<span class="hljs-keyword">some</span><span class="hljs-list">(<span class="hljs-keyword">a</span>)</span>)</span>
  }
)</span>

const arrayOfFlatten = c =&gt; <span class="hljs-list">(
  <span class="hljs-keyword">a</span> =&gt; {
    a = arrayOf<span class="hljs-list">(<span class="hljs-keyword">arrayOf</span><span class="hljs-list">(<span class="hljs-keyword">c</span>)</span>)</span><span class="hljs-list">(<span class="hljs-keyword">a</span>)</span>
    const r = []
    const l = a.length
    for <span class="hljs-list">(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; l; ++i) {</span>
      r = r.concat<span class="hljs-list">(<span class="hljs-keyword">a</span>[i])</span> // ew wtf is this guy doing?
    }
  }
)</span>

const maybeFlatten = c =&gt; <span class="hljs-list">(
  <span class="hljs-keyword">a</span> =&gt; {
    a = maybe<span class="hljs-list">(<span class="hljs-keyword">maybe</span><span class="hljs-list">(<span class="hljs-keyword">c</span>)</span>)</span><span class="hljs-list">(<span class="hljs-keyword">a</span>)</span>
    if <span class="hljs-list">(<span class="hljs-keyword">a</span> instanceof Some)</span> {
      a = a.x
    } else if <span class="hljs-list">(<span class="hljs-keyword">a</span> instanceof None)</span> {
      a = a // why? if it<span class="hljs-quoted">&#39;s</span> not Some, it <em>must</em> be None.
    }
    return maybe<span class="hljs-list">(<span class="hljs-keyword">c</span>)</span><span class="hljs-list">(<span class="hljs-keyword">a</span>)</span>
  }
)</span>

// oh god what is even happening right now
Array.unit = a =&gt; [a]
Maybe.unit = some
Array.prototype.flatten = function <span class="hljs-list">(<span class="hljs-keyword">c</span> = any)</span> { return arrayOfFlatten<span class="hljs-list">(<span class="hljs-keyword">c</span>)</span><span class="hljs-list">(<span class="hljs-keyword">this</span>)</span> }
// he literally has if <span class="hljs-list">(<span class="hljs-keyword">c</span> === void <span class="hljs-number">0</span>)</span> c = any
// but this isn<span class="hljs-quoted">&#39;t</span> the <span class="hljs-number">90</span>s so

// apply given functor twice to a contract
const twice = f =&gt; c =&gt; f<span class="hljs-list">(<span class="hljs-keyword">f</span><span class="hljs-list">(<span class="hljs-keyword">c</span>)</span>
const once = f =&gt; f // what the actual fuck, this is id..</span></span></code></pre><p>Okay, I&#39;m done, I tried. there are like 20 more videos in this series but it&#39;s
so badly done and there are so many mistakes and the guy talks so slowly that
I just can&#39;t do this anymore.</p>
<p>If anyone knows of a decent intro to category theory for JS devs, please let
me know.</p>
]]></description><link>/2016/category-theory-for-js-devs.html</link><guid isPermaLink="true">/2016/category-theory-for-js-devs.html</guid><category><![CDATA[fp]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 26 Nov 2016 22:00:00 GMT</pubDate></item><item><title><![CDATA[advice for new devs]]></title><description><![CDATA[<p>So, I went to one of those code bootcamps. I started there just over a year ago,
and when I finished the course I worked there as a mentor for a cohort (three
months). Immediately after that, I got what I think is a pretty swell job doing
development full time, working mostly in technologies that I really like.</p>
<p>It&#39;s hard to find non-success stories from bootcamps, since generally the people
who go to these things are people who are really determined to do very well. You
don&#39;t go and pay $10k-$20k to lock yourself up in a building with a bunch of
other nerds for twelve or moure hours every day for three months straight unless
you really want to get something out of it. I think I&#39;m a good example of
someone who did really well through a bootcamp, though, and the reason I did so
well comes down to really just one thing, which I think everyone going into
computing (whether it&#39;s web development, databases, hardware, whatever) really
should be aware of.</p>
<blockquote>
<p>KNOW COMPUTERS</p>
</blockquote>
<p>That seems really obvious, right? But as a mentor it was amazing to me how many
people would come into a course that&#39;s just about making things happen with
computers, not knowing a lot of the basics of how to <em>use</em> a computer, and
knowing virtually nothing about how computers actually <em>work</em>. They&#39;re not just
a thing with a keyboard and a screen and a logo on the back. They&#39;re not just a
status symbol, though Mac users would like you to think they are. They&#39;re not
magical, and it&#39;s important to know what they do and how they do it, at least in
vague terms.</p>
<p>No junior web dev should really be expected to be familiar with what a page
cache is, or maybe even how domain names are resolved, but you should at least
know what a kernel is, what userland actually means, what the implications of
using your particular filesystem are, what the internet infrastructure kind of
looks like (at least in vague terms), and how to do some basic things that will
save you a lot of time later on (general terminal usage is a good place to
start).</p>
<p>This is the number one thing that can help you get, and stay, ahead as a student
and junior dev, in my opinion. And it&#39;s stuff you&#39;ll absolutely <em>have</em> to know
at some point, and probably mostly won&#39;t be taught, so it&#39;s a good idea to just
pick up this stuff as early as possible.</p>
]]></description><link>/2016/advice-for-new-devs.html</link><guid isPermaLink="true">/2016/advice-for-new-devs.html</guid><category><![CDATA[devmtn]]></category><category><![CDATA[tips]]></category><category><![CDATA[dev]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 12 Nov 2016 18:26:00 GMT</pubDate></item><item><title><![CDATA[shitshow]]></title><description><![CDATA[<p>This is an elaboration on a
<a href="https://twitter.com/zacanger/status/796205243474157569">tweet</a> from last night.</p>
<p>I was born male, and I identify as male. That&#39;s pretty convenient for me.
I&#39;m white, which is probably very convenient for me.
I make a conscious effort to be aware of my privilege, but I probably fuck up
sometimes. I hope that whenever that happens, someone will call me out on it.</p>
<p>I was born in Baltimore, and went to a public school that I think was less than
half white. That turned out to be a nice thing, because I never really
understood what the big deal was about skin colour. My parents tell me I
literally didn&#39;t understand that some people might think there was a difference
between people with different coloured skin. And why would I? I was a kid,
that&#39;s not a thing I should have to know.</p>
<p>My family moved to southern Pennsylvania when I was 11. South-Central PA is
overwhemingly white, and has a large boomer population. One could easily go
months at a time without seeing a black person, especially if one was
homeschooled (which I was, because the local schools were some of the worst in
the state).</p>
<p>When I was 19, I was working in the coffee shop in a local grocery store. I had
just voted for the first time. Obama became President. The next morning, I went
to work around 6:30, sold a newspaper to an older guy around 7. He sat down on a
nearby bench and said to me &quot;Can you believe they put a n----- in the White
House?&quot; This wasn&#39;t my first time encountering racism, but it was the first time
I realised just how open people in that area were about it.</p>
<p>I worked at a guitar shop for a while. The guy who owned it was a stereotypical
redneck, something straight out of a Far Side comic. To him, anyone non-white
was nothing but an epithet, women existed to be objectified, and if he got a
hint that someone wasn&#39;t straight, they wouldn&#39;t be allowed in his shop. Most of
his days were spent smoking pot and looking at pictures of girls on the computer
in his office.</p>
<p>I moved to Utah about a year ago. I didn&#39;t intend to stay here, because Utah is
all of the bad things people say about it. It&#39;s also all of the good things
people say about it&mdash;there are mountains and things, and if you&#39;re into
that that&#39;s pretty nice&mdash;but it&#39;s extremely white, extremely Mormon,
extremely dry, and extremely boring. It&#39;s a lot of the things I hated about
Pennsylvania, except drier and with Mormons instead of Evangelicals.</p>
<p>I kind of thought, though, that being out here would be a bit of an escape from
the &#39;culture&#39; in Pennsylvania. James Carville
<a href="https://en.wikipedia.org/wiki/Pennsyltucky">described PA</a> as being Philadelphia
and Pittsburgh with Alabama in between, and that&#39;s pretty accurate. Utah&#39;s more
like Salt Lake City and then a bunch of nothing mixed with Mormons, which isn&#39;t
actually any better. Mormons are a little more laid-back about their racism and
mysogyny, but it&#39;s still there. They&#39;re just encouraged not to show it off,
because the LDS church doesn&#39;t want that public image. It&#39;s pretty clear based
on their politics, though.</p>
<p>This election was not about anything except for hatred. A common statement is
that Trump just &#39;tells it like it is,&#39; but that&#39;s known to be bullshit. He&#39;s
been the most dishonest Presidential candidate in the history of fact-checking,
and Clinton has been one of the most factually accurate, ever, period. Straight
talk has nothing to do with anything. There have also been numbers that say that
Trump supports think the economy will do better under Trump, but generally folks
actually worried about the economy will vote Democrat, probably because the
economy tends to do better under Democrats.</p>
<p>Trump winning the electoral vote last night has nothing to do with policy. It
was a message from the worst kind of people in this country that they want to be
heard and want to be taken seriously. That they&#39;re afraid of people who don&#39;t
look like them or have the same beliefs as them. People like that old man at the
coffee shop, or Randy from the guitar shop, or Carmine, my boss at my last job
in Pennsylvania. People who think they should have the right to openly
discriminate against other people, people who are so unconcerned with facts that
they sound exactly like characters in Idiocracy (link), calling people &#39;faggot&#39;
for being educated on a topic.</p>
<p>I&#39;m a cis white male, and I&#39;m sorry that a bunch of cis white males did this to
this country. It&#39;s going to be really rough, especially at first when we have a
red house and senate. We, collectively, all the people that have fought for
LGBTQA rights and less discrimination and tried to defend against ignorance and
won Clinton the popular vote, we need to hold on and survive this and support
each other. We need to call each other out on our biases and abuse of
privilege We need to not give up. We need to show each other, the country, and
the world that America is not a country of hate.</p>
<p>There are folks on Twitter saying that this will be easy, that love and
happiness and just get through it, and that&#39;s bullshit. This won&#39;t be easy. This
is serious and dangerous and terrifying. This is bad news all around. But let&#39;s
try, because we can&#39;t all just leave.</p>
]]></description><link>/2016/shitshow.html</link><guid isPermaLink="true">/2016/shitshow.html</guid><category><![CDATA[politics]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Wed, 09 Nov 2016 16:04:00 GMT</pubDate></item><item><title><![CDATA[Two Things That Might Be Fun]]></title><description><![CDATA[<p>Two things that I think might be fun to play around with, at some point.</p>
<p>First: a less intrusive type annotation thing for JS. It&#39;d be similar to ML or
Haskell style annotations, but maybe use Flow as a sort of backend to actually
do the type checking? It could look something like this:</p>
<pre class="hljs"><code>//<span class="hljs-type-annotation">::</span> <span class="hljs-built_in">Int</span> -&gt; <span class="hljs-built_in">Int</span> -&gt; [<span class="hljs-built_in">Int</span>]
<span class="hljs-keyword">const</span> putIntsInList = (a, b) =&gt; [ a,  b ]

//<span class="hljs-type-annotation">::</span>Str -&gt; Str -&gt; Str // or
//<span class="hljs-type-annotation">::</span>[<span class="hljs-built_in">Char</span>] -&gt; [<span class="hljs-built_in">Char</span>] -&gt; [<span class="hljs-built_in">Char</span>]
<span class="hljs-keyword">const</span> doThingsWithStrings = (a, b) =&gt; <span class="hljs-string"><code>${a} ${b}</code></span></code></pre><p>It could use some sort of regexy thing to basically just detect anywhere there&#39;s
<code>//::</code>, see what the next thing is, and see if they go together. I don&#39;t know
much about ASTs or type systems, though. I just think that&#39;d be a lot less
in-the-way than how TypeScript and Flow currently work. Also, my syntax
highlighting doesn&#39;t know what template strings are, so. That&#39;s gross.</p>
<p>Another thing:</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> React, { PropTypes } from &#39;react&#39;
<span class="hljs-keyword">import</span> AnotherComponent from &#39;./AnotherComponent&#39;

const <span class="hljs-type">Something</span> = ({ a, b, <span class="hljs-built_in">c</span> }) =&gt; {
  <span class="hljs-keyword">if</span> (!a) <span class="hljs-keyword">return</span> null

  <span class="hljs-keyword">return</span> (
    (div
      (another-component (whatever &#39;a))
        (not (null? b)
          (span (b))
        (not (null? <span class="hljs-built_in">c</span>)
          (<span class="hljs-built_in">map</span> (p (<span class="hljs-built_in">c</span>)))))))
  <span class="hljs-comment">// which would be like</span>
  <span class="hljs-keyword">return</span> (
    &lt;div&gt;
      &lt;<span class="hljs-type">AnotherComponent</span> whatever={a} /&gt;
      {b &amp;&amp; &lt;span&gt;{b}&lt;/span&gt;}
      {<span class="hljs-built_in">c</span> &amp;&amp; <span class="hljs-built_in">c</span>.length &amp;&amp;
        <span class="hljs-built_in">c</span>.<span class="hljs-built_in">map</span>((a, i) =&gt; &lt;p key={i}&gt;{a}&lt;/p&gt;)
      }
    &lt;/div&gt;
  )
}

export <span class="hljs-keyword">default</span> <span class="hljs-type">Something</span></code></pre><p>This a totally made-up syntax for a thing that doesn&#39;t exactly exist, and I
don&#39;t know how useful this would actually be, since there are already great
React libraries for ClojureScript out there. Just think it&#39;d be neat to be able
to to JSX in Scheme. I dunno, just a thought.</p>
]]></description><link>/2016/two-things-that-might-be-fun.html</link><guid isPermaLink="true">/2016/two-things-that-might-be-fun.html</guid><category><![CDATA[cljs]]></category><category><![CDATA[scheme]]></category><category><![CDATA[types]]></category><category><![CDATA[hs]]></category><category><![CDATA[jsx]]></category><category><![CDATA[js]]></category><category><![CDATA[react]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Fri, 04 Nov 2016 03:40:00 GMT</pubDate></item><item><title><![CDATA[pm tools kill productivity]]></title><description><![CDATA[<p>Project management tools kill productivity. This isn&#39;t news. They <em>can</em> help
other people be more aware of what you&#39;re doing, which is generally a good thing
(collaborating on projects, managers keeping track of progress, whatever), but
overdoing it with the tools can be seriously detrimental to actually getting
anything done.</p>
<p>I was going to write a much longer post about this, but let me just give you a
list of all things I check several times a day (in the case of Slack, several
times an hour), instead.</p>
<ul>
<li>Wrike (a task/project management thing with the worst UI of any like tool on
the market)</li>
<li>Trello (not so much anymore, but some people still use it at work, apparently)</li>
<li>Quip (a weird combination of Trello and Excel)</li>
<li>Github Issues/PRs (Issues not so much anymore, though that would be the most
sensible place to keep track of repo-specific todos)</li>
<li>And of course, Slack</li>
</ul>
<p>Personally I keep track of what I need to do in two places: for personal items,
a JSON file (yes, a JSON file). This means I can use it with my little
<a href="http://npmjs.com/package/lilnote">command-line note-taking app</a>, easily work
with it in any language, whatever. For work tasks, I just keep a giant Markdown
file, using GFM-style task lists. I end up copying things over from one or more
of the above tools into Markdown, where I keep track of them for hours or days
or weeks, then as things are fleshed out, completed, nixed, or whatever, going
back to those tools (usually more than one) to update them.</p>
<p>This is not an efficient workflow. Some of these tools (Quip and Wrike
especially) are so lacking in all the things that make a good project management
app (mainly, simplicity and ease of use) that using them ends up taking more
than half as much time as many of the small tasks.</p>
<p>The last place I worked, we switched to this thing called Droptask. It was so
bad, such a ridiculously complicated UI mess, that myself and some co-workers
just ended up not using it at all, and relied solely on Slack. Picking a (one,
singular) decent tool really makes a difference. Trello&#39;s popular because it&#39;s
simple and easy. For devs, same goes for Issues.</p>
<p>I meant to write a good bit more about this but I probably don&#39;t need to.
Everyone complains about using too many tools all the time, especially devs
using businessy tools. And it&#39;s late. So.</p>
]]></description><link>/2016/pm-tools-kill-productivity.html</link><guid isPermaLink="true">/2016/pm-tools-kill-productivity.html</guid><category><![CDATA[tools]]></category><category><![CDATA[work]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Wed, 19 Oct 2016 05:00:00 GMT</pubDate></item><item><title><![CDATA[Thoughts On Learning Functional Programming]]></title><description><![CDATA[<p>Functional programming is the new hotness these days. It&#39;s also the old hotness.
It&#39;s just pretty hot, really. Everyone wants to have a more functional codebase,
and that&#39;s a good thing. Less side-effecty, easier to hold in your head, etc.;
the benefits of FP have been thoroughly espoused elsewhere. I just have a couple
of things to add about learning functional programming, especially if you&#39;re
coming from another paradigm or a mixed-paradigm language (like JS).</p>
<h2 id="you-probably-don-t-need-to-learn-another-language">You (Probably) Don&#39;t Need To Learn Another Language</h2>
<p>Languages like Haskell are really neat. They&#39;ll change the way you think about
writing code. But you don&#39;t need to learn a classically functional language to
learn functional programming.</p>
<pre class="hljs"><code><span class="hljs-module"><span class="hljs-keyword">module</span> Main <span class="hljs-keyword">where</span></span>
<span class="hljs-import"><span class="hljs-keyword">import</span> System.Environment</span>

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
  args &lt;- getArgs
  putStrLn (<span class="hljs-string">&quot;Hello &quot;</span> ++ args !! <span class="hljs-number">0</span>)</code></pre><p>If a block of code like that looks pretty foreign, that&#39;s okay. <em>You can program
functionally in whatever language is most familiar to you</em>. Probably. If you&#39;re
a C# dev or Rubyist or something, maybe you should look into something a little
less strictly OO, but if you already write JS (for example), you don&#39;t need to
go learn about abstract algebra and what stuff like <code>Foo :: [Bar] -&gt; Baz Quux</code>
means. Which leads into thought number two:</p>
<h2 id="a-better-type-system-doesn-t-make-a-language-functional">A Better Type System Doesn&#39;t Make A Language Functional</h2>
<p>Yeah, languages like Idris and Haskell and other super mathy things are great
for functional programming, but you don&#39;t <em>need</em> super complex type systems to
program functionally. They&#39;re just, y&#39;know, pretty nice. Look at
<a href="https://racket-lang.org/">Racket</a>, for example. You can have static typing
(with <code>#lang typed/racket</code>) but you don&#39;t <em>have</em> to. Similarly, you can program
functionally just fine in plain old JS, and you can write super imperative code
in TypeScript. My point is, type systems don&#39;t make a language more functional,
they make a language have a different type system.</p>
<h2 id="lots-of-languages-have-a-repl">Lots Of Languages Have A REPL</h2>
<p>LISP people like to talk about their REPL a lot. Same with Haskell folks,
they&#39;ll tell you to go experient in GHCI. That&#39;s great, it really is. The REPL,
for any given language, should be one of the primary tools you use to figure
things out. But most languages have one. If you do Python, you&#39;re probably
familiar with it. Same with Ruby (irb or pry). Node&#39;s REPL, while a little
limited compared to GHCI, is still pretty fantastic. Racket&#39;s is very basic, but
if you <code>(require xrepl)</code> it ends up being very pleasant. Having a decent REPL
isn&#39;t a functional language feature, it&#39;s just a language ecosystem feature.</p>
<h2 id="scheme-is-really-nice">Scheme Is Really Nice</h2>
<p>I&#39;m not a LISPer. I&#39;ve just started learning Racket, which I chose because it&#39;s
very compact compared to, say, ClojureScript (which also looks fantastic, by the
way). But coming primarily from JavaScript, Scheme (Racket is a Scheme) is a
really good way to get into FP in another language. Haskell, ML, Idris, etc.,
are all awesome languages, but Scheme might be a better way to break into
functional languages for a lot of folks. Give it a shot sometime.</p>
<h2 id="if-you-re-brand-new-to-fp">If You&#39;re Brand New To FP</h2>
<p>Check out these links.</p>
<ul>
<li><a href="https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q">FunFunFunction</a> is
a great YouTube channel with videos that cover the basics of FP in JS.</li>
<li><a href="https://medium.com/@cscalfani">Charles Scalfani</a> has a series of posts on
Medium that talk about a lot of the same things.</li>
<li><a href="https://www.youtube.com/channel/UCKjVLbSDoM-8-eEM7A30igA">Brian Lonsdorf</a> has
a bunch of videos and talks that will convince you that FP is the Right Way.</li>
</ul>
]]></description><link>/2016/on-learning-fp.html</link><guid isPermaLink="true">/2016/on-learning-fp.html</guid><category><![CDATA[fp]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sun, 16 Oct 2016 18:30:00 GMT</pubDate></item><item><title><![CDATA[html2text in node tutorial]]></title><description><![CDATA[<p>Okay, ready to build another command-line app in Node?</p>
<p>If you haven&#39;t seen my last two posts, you should check them out, since I&#39;m not
going to cover a lot of the basics again. They&#39;re both on writing small cli apps
in Node, with no dependencies.</p>
<ul>
<li><a href="http://blog.zacanger.com/2016/a-basic-cli-app-in-node.html">React component generator</a></li>
<li><a href="http://blog.zacanger.com/2016/note-taking-app.html">JSON Note-taking app</a></li>
</ul>
<p>And here&#39;s the finished product from the latter:</p>
<pre class="hljs"><code>#!/usr/bin/env node

&#39;<span class="hljs-keyword">use</span> strict&#39;

<span class="hljs-keyword">const</span> {
  readFileSync
, writeFile
}       = require(&#39;fs&#39;)
, <span class="hljs-keyword">log</span>   = console.<span class="hljs-literal">log</span>
, arg   = process.argv[2]
, <span class="hljs-keyword">n</span>     = &#39;./<span class="hljs-keyword">notes</span>.json&#39;
, <span class="hljs-keyword">file</span>  = readFileSync(<span class="hljs-keyword">n</span>)
, <span class="hljs-keyword">notes</span> = JSON.<span class="hljs-keyword">parse</span>(<span class="hljs-keyword">file</span>)

<span class="hljs-keyword">const</span> writeTheFile = () =&gt; {
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}

<span class="hljs-keyword">const</span> takeNote = (<span class="hljs-keyword">notes</span>, <span class="hljs-keyword">note</span>) =&gt; {
  <span class="hljs-keyword">notes</span>.push(<span class="hljs-keyword">note</span>)
  writeTheFile()
}

<span class="hljs-keyword">const</span> removeNote = (<span class="hljs-keyword">notes</span>, noteIndex) =&gt; {
  <span class="hljs-keyword">notes</span>.splice(noteIndex -1, 1)
  writeTheFile()
}

<span class="hljs-keyword">const</span> runApp = () =&gt; {
  <span class="hljs-keyword">if</span> (arg) {
    switch (arg) {
      case &#39;-s&#39;:
        <span class="hljs-literal">log</span>(<span class="hljs-keyword">notes</span>)
        <span class="hljs-keyword">break</span>
      case &#39;-r&#39;:
        <span class="hljs-keyword">const</span> noteIndex = process.argv[3]
        removeNote(<span class="hljs-keyword">notes</span>, noteIndex)
        <span class="hljs-keyword">break</span>
      default:
        takeNote(<span class="hljs-keyword">notes</span>, arg)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(&#39;Please pass <span class="hljs-keyword">an</span> argument&#39;)
  }
}

<span class="hljs-keyword">if</span> (!module.parent) {
  runApp()
}</code></pre><hr>
<p>What we&#39;re going to build this time is going to be a little more complex. We&#39;re
going to write a program that downloads a website and turns it into Markdown for
easy offline reading. This isn&#39;t a new concept, and I actually use a Python script
called <a href="https://github.com/aaronsw/html2text">html2text</a> for this on an
almost-daily basis, but just for fun, we&#39;ll do something similar in Node.</p>
<p>This will also be the first time we&#39;ll be working with external modules, which
is really the most exciting and awesome thing about Node.</p>
<p>Our goal here is to have a small tool we can use like this:</p>
<pre class="hljs"><code>./index<span class="hljs-class">.js</span> zacanger.com</code></pre><p>And it&#39;ll give us back the contents of <code>zacanger.com</code>, in Markdown, ready to
read in the terminal, pipe to an editor, or whatever.</p>
<p>First things first: we&#39;ll need a project. Make a new directory and get into it,
and <code>npm init</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">mkdir</span> html2txt
<span class="hljs-keyword">cd</span> html2xt
npm init -<span class="hljs-literal">y</span></code></pre><p>The <code>-y</code> flag just means &quot;don&#39;t ask me questions.&quot; You can skip that flag and
fill in the info for your <code>package.json</code> if you&#39;d like, or just go back and edit
it later.</p>
<p>We&#39;re going to be using a couple of things built-in to Node, so we can go ahead
and require them now. We&#39;ll need <code>http</code>&#39;s <code>get</code> method, and also a way to work
with an argument. If you&#39;ve done either of my previous tutorials, you&#39;ll already
be familiar with Node&#39;s <code>process.argv</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { <span class="hljs-keyword">get</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>)
<span class="hljs-keyword">const</span> url = process.argv[<span class="hljs-number">2</span>]</code></pre><p>Let&#39;s see if we can&#39;t get some HTML, just as a starting point.</p>
<pre class="hljs"><code>get<span class="hljs-list">(<span class="hljs-keyword">url</span>, res =&gt; {
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;data</span>&#39;, d =&gt; {
    console.log<span class="hljs-list">(<span class="hljs-keyword">d</span>)</span>
  })</span>
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;end</span>&#39;, <span class="hljs-list">()</span> =&gt; {
    console.log<span class="hljs-list">(<span class="hljs-quoted">&#39;done</span>&#39;)</span>
  })</span>
})</span></code></pre><p>Try that out with something like <code>node index.js http://google.com</code>.</p>
<p>You should see something like <code>&lt;Buffer 3c 21 64 6f 63 74 7</code> (and so on).
<a href="https://nodejs.org/api/buffer.html">Buffers</a> are great and all, but that&#39;s
pretty useless for actual reading. Try calling <code>toString</code> on that data and you
should see some actual HTML (<code>console.log(d.toString())</code>).</p>
<p>(Note: you may see a 301 page here.)</p>
<p>Awesome! We now have all the functionality of prepending <code>view-source:</code> to a URL
in the browser. Let&#39;s do something with that HTML, since it&#39;s probably not how
you prefer to read stuff.</p>
<p>There are a lot of great modules out there for working with Markdown. For this
post, I&#39;ve decided to go with a super simple one without a whole lot of options,
<a href="https://www.npmjs.com/package/to-markdown">to-markdown</a>. If you&#39;re not super
familiar with npm, you&#39;re about to learn just about all you need to know to get
started.</p>
<p>In your terminal, <code>npm i -S to-markdown</code>. This is a shorthand for the command
<code>npm install --save to-markdown</code>; most npm commands have shorter versions, and
it can really save you a lot of time if you get used to using them.</p>
<p>You should see a bunch of stuff happen in the terminal. If you check your
<code>package.json</code>, you&#39;ll now see <code>to-markdown</code> in there. It should like something
like this:</p>
<pre class="hljs"><code><span class="hljs-collection">{
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;something&quot;</span>,
  // probably some other stuff
  <span class="hljs-string">&quot;dependencies&quot;</span>: <span class="hljs-collection">{
    <span class="hljs-string">&quot;to-markdown&quot;</span>: <span class="hljs-string">&quot;^3.0.1&quot;</span>
  }</span>
}</span></code></pre><p>(Yes, I know you can&#39;t have comments in JSON.)</p>
<p>Next we&#39;ll need to get that into the program. If you&#39;re using Babel, you can use
<code>import</code>, but to keep things simple we&#39;ll stick with <code>require</code>.</p>
<pre class="hljs"><code>const toMarkdown = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">&#39;to-markdown&#39;</span>)</span></span></code></pre><p>Now try running the HTML through this before logging it out.</p>
<pre class="hljs"><code><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> toMarkdown = require(&#39;to-markdown&#39;)
<span class="hljs-comment">// ...</span>
  res.<span class="hljs-keyword">on</span>(&#39;data&#39;, <span class="hljs-keyword">d</span> =&gt; {
    console.<span class="hljs-literal">log</span>(toMarkdown(<span class="hljs-keyword">d</span>.<span class="hljs-keyword">toString</span>()))
  })
<span class="hljs-comment">// ...</span></code></pre><p>If you run the script again, you should see beautiful, super-readable Markdown!
All done!</p>
<hr>
<p>Well, mostly. This is nice and all, but there are definitely some things we can
do to make this script a bit better. Firstly, it&#39;s annoying to have to always
type <code>http://</code> before a URL, so maybe we should automatically add that on.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> url = process.argv[<span class="hljs-number">2</span>]
<span class="hljs-keyword">const</span> src = (url.includes(<span class="hljs-string">&#39;http://&#39;</span>) url.includes(<span class="hljs-string">&#39;https://&#39;</span>)) ? url : `http:<span class="hljs-comment">//${url}`</span></code></pre><p>All this extra bit is doing is checking if the passed in argument aleady has a
scheme, and if it doesn&#39;t, just sticking on on the beginning. If you&#39;re not
familiar with template literals, check out the previous tutorials and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">docs
on
MDN</a>.</p>
<p>If you&#39;re not familiar with <code>Array.prototype.includes()</code>, it&#39;s basically a
shorthand for <code>.indexOf(foo !== -1)</code>.</p>
<p>Make sure you change the <code>get</code> call to use <code>src</code> instead of <code>url</code>.</p>
<p>And, as in the previous tutorials, we&#39;ll want to just be able to execute this
script, without needing to type in <code>node</code> each time, so add a shebang and make
it exectuable.</p>
<pre class="hljs"><code><span class="hljs-keyword">chmod</span> +<span class="hljs-keyword">x</span> <span class="hljs-keyword">index</span>.js</code></pre><pre class="hljs"><code>#!<span class="hljs-regexp">/usr/</span>bin/env node

<span class="hljs-keyword">const</span> { <span class="hljs-keyword">get</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>)
<span class="hljs-comment">// ...</span></code></pre><p>Now you should be able to just do something like <code>./index.js zacanger.com</code> and
see some results.</p>
<p><code>to-markdown</code> can handle take some options. One of them is to use
<a href="https://help.github.com/categories/writing-on-github">GitHub-Flavored
Markdown</a>, which is
pretty nice since that&#39;s probably what most of us are used to using. To enable
this, just pass <code>{ gfm: true }</code> in the call to <code>toMarkdown</code>:</p>
<pre class="hljs"><code><span class="hljs-comment">// ...</span>
<span class="hljs-tag">console</span><span class="hljs-class">.log</span>(<span class="hljs-function">toMarkdown</span>(d.<span class="hljs-function">toString</span>(), { <span class="hljs-attribute">gfm</span>: true }))
<span class="hljs-comment">// ...</span></code></pre><p>You may notice some tags are making it through the conversion (<code>script</code>, <code>span</code>,
<code>div</code>, and probably a few others); I&#39;m not going to go over all of the options
that <code>to-markdown</code> can take, but you should check out the docs and learn how to
write filters, if you&#39;re interested. You could also write your own function to
strip out unwanted elements, and run the Markdown through this:</p>
<pre class="hljs"><code>const cleanOutStuff = <span class="hljs-keyword">string</span> =&gt;
  <span class="hljs-keyword">string</span>.<span class="hljs-built_in">replace</span>(/(<span class="hljs-operator">div</span>|script|span)/g, <span class="hljs-string">&#39;&#39;</span>)

console.<span class="hljs-built_in">log</span>(cleanOutStuff(toMarkdown(d.toString(), { gfm: <span class="hljs-constant">true</span> })))</code></pre><p>But it&#39;d probably be easier to just learn the options rather that spinning
something custom like this.</p>
<p>One thing that really irks me when I&#39;m reading in the terminal is text that
doesn&#39;t wrap. Sometimes I&#39;m on a very large screen, and it can get difficult to
keep track of where I am when the text is too wide. 80 characters is a pretty
reasonable limit, so why don&#39;t we get this text to wrap there? We&#39;re going to
use another module for this:
<a href="https://github.com/substack/node-wordwrap">wordwrap</a>.</p>
<pre class="hljs"><code>npm <span class="hljs-tag">i</span> -S wordwrap</code></pre><pre class="hljs"><code>const wordwrap = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">&#39;wordwrap&#39;</span>)</span></span></code></pre><p>This module needs to know how many characters it can put in a line. We could
just pass it <code>80</code>, but I think maybe we should handle cases where the terminal
is resized very small but maybe won&#39;t stay that way, so we&#39;re going to find out
how big the terminal currently is and base our decision on that.
<code>process.stdout</code> has a way for us to find this out.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> wordwrap = require(<span class="hljs-string">&#39;wordwrap&#39;</span>)
<span class="hljs-keyword">const</span> { rows } = process.stdout
<span class="hljs-keyword">const</span> wraplength = (rows &lt; <span class="hljs-number">80</span> ? <span class="hljs-number">80</span> : rows)
<span class="hljs-keyword">const</span> wrapper = wordwrap(wraplength)</code></pre><p>All we&#39;re doing here is wrapping to either the width of the terminal or 80
characters, whichever happens to be greater.</p>
<p>Now we can use that <code>wrapper</code> when we log out the results.</p>
<pre class="hljs"><code><span class="hljs-tag">console</span><span class="hljs-class">.log</span>(<span class="hljs-tag">wrapper</span>(<span class="hljs-tag">toMarkdown</span>(<span class="hljs-tag">d</span><span class="hljs-class">.toString</span>(), <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">gfm</span>:<span class="hljs-value"> true </span></span></span>})))</code></pre><hr>
<p>So, awesome! Your script should now do just about everything you want it to do.
There&#39;s really only one big thing left to do: make it less ugly. That
<code>console.log</code> is really getting gross, don&#39;t you think? I like to handle this by
just defining a bunch of functions I can throw together, so I don&#39;t have to have
all this junk cluttering up my space.</p>
<pre class="hljs"><code>const opts = { gfm: <span class="hljs-constant">true</span> }
const <span class="hljs-built_in">convert</span> = <span class="hljs-operator">a</span> =&gt; toMarkdown(<span class="hljs-operator">a</span>, opts)
const <span class="hljs-operator">wrap</span> = <span class="hljs-operator">a</span> =&gt; wrapper(<span class="hljs-operator">a</span>)
const <span class="hljs-built_in">log</span> = <span class="hljs-operator">a</span> =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-operator">a</span>)</code></pre><p>I&#39;m using <code>a</code> as a parameter here. You can use something more descriptive if
you&#39;d like, it really doesn&#39;t matter.</p>
<p>And I think we should also just wait until we have all the data before logging
anything, so let&#39;s adjust our HTTP call (and stick it in a function):</p>
<pre class="hljs"><code>const main = arg =&gt; get<span class="hljs-list">(<span class="hljs-keyword">arg</span>, res =&gt; {
  let b = &#39;&#39; // <code>b</code> for <code>body</code>
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;data</span>&#39;, d =&gt; b += d.toString)</span>
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;end</span>&#39;, <span class="hljs-list">()</span> =&gt; log<span class="hljs-list">(<span class="hljs-keyword">wrap</span><span class="hljs-list">(<span class="hljs-keyword">convert</span><span class="hljs-list">(<span class="hljs-keyword">b</span>)</span>)</span>)</span>)</span>
})</span></code></pre><p>Your linter might yell at you saying you can&#39;t return assignment. It&#39;s probably
right, but nothing&#39;s going to break. If you&#39;re concerned about it, just wrap
that <code>b += d.toString()</code> in some braces.</p>
<p>Obviously, this is a function, so we need to call it somewhere.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(src)</span></span></code></pre><p>We&#39;re just passing it our URL that may or may not have <code>http://</code> stuck on to it.</p>
<hr>
<p>Now you&#39;re really done! I suggest you go check out <code>to-markdown</code>, play around
with <code>process</code>, and see what else you can do with this thing. If you make
something pretty neat, you should consider releasing it! Check out <code>npm help
adduser</code> and <code>npm help publish</code> to see how you could go about this. (There are
probably similar modules out there, though, so make sure you&#39;re not stepping on
anyone&#39;s toes first!)</p>
<p>I&#39;d also suggest you do some basic error handling, but that&#39;s totally up to you.</p>
<p>For the previous two tutorials I waited until the following post to show a
finished version of the script; since this is the last tutorial on writing CLI
apps in Node that I intend to write, the full script is below, as well as my
manifest file (<code>package.json</code>).</p>
<p>Note: I tend to prefer shorter (but hopefully still readable) names for things,
and a somewhat opinionated code style, so the full script below may differ
a bit from your results, and that&#39;s totally fine.</p>
<pre class="hljs"><code>{
  &quot;<span class="hljs-attribute">name</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;html2txt&quot;</span></span>,
  &quot;<span class="hljs-attribute">description</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;html2text sorta thing for blog post&quot;</span></span>,
  &quot;<span class="hljs-attribute">version</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;0.0.1&quot;</span></span>,
  &quot;<span class="hljs-attribute">author</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">name</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;Zac Anger&quot;</span></span>,
    &quot;<span class="hljs-attribute">email</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;zac@zacanger.com&quot;</span></span>,
    &quot;<span class="hljs-attribute">url</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="http://zacanger.com">http://zacanger.com</a>&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">license</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;WTFPL&quot;</span></span>,
  &quot;<span class="hljs-attribute">main</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;index.js&quot;</span></span>,
  &quot;<span class="hljs-attribute">scripts</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">start</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;node index&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">homepage</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="https://github.com/zacanger/blog#readme">https://github.com/zacanger/blog#readme</a>&quot;</span></span>,
  &quot;<span class="hljs-attribute">repository</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">type</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;git&quot;</span></span>,
    &quot;<span class="hljs-attribute">url</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="https://github.com/zacanger/blog.git">https://github.com/zacanger/blog.git</a>&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">bugs</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="https://github.com/zacanger/blog/issues">https://github.com/zacanger/blog/issues</a>&quot;</span></span>,
  &quot;<span class="hljs-attribute">keywords</span>&quot;: <span class="hljs-value">[
    <span class="hljs-string">&quot;html&quot;</span>,
    <span class="hljs-string">&quot;markdown&quot;</span>
  ]</span>,
  &quot;<span class="hljs-attribute">dependencies</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">to-markdown</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;^3.0.1&quot;</span></span>,
    &quot;<span class="hljs-attribute">wordwrap</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;^1.0.0&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">devDependencies</span>&quot;: <span class="hljs-value">{}
</span>}</code></pre><pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env node</span>

const
  url      = <span class="hljs-built_in">process</span>.argv[<span class="hljs-number">2</span>] || <span class="hljs-string">&#39;zacanger.com&#39;</span>
, { <span class="hljs-built_in">get</span> }  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>)
, { rows } = <span class="hljs-built_in">process</span>.<span class="hljs-keyword">stdout</span>
, <span class="hljs-built_in">len</span>      = (rows &lt; <span class="hljs-number">80</span> ? <span class="hljs-number">80</span> : rows)
, toMd     = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;to-markdown&#39;</span>)
, ww       = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;wordwrap&#39;</span>)
, wrapper  = ww(<span class="hljs-built_in">len</span>)
, opts     = { gfm: <span class="hljs-constant">true</span> }
, conv     = <span class="hljs-operator">a</span> =&gt; toMd(<span class="hljs-operator">a</span>, opts)
, <span class="hljs-operator">wrap</span>     = <span class="hljs-operator">a</span> =&gt; wrapper(<span class="hljs-operator">a</span>)
, <span class="hljs-built_in">log</span>      = <span class="hljs-operator">a</span> =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-operator">a</span>)
, src      = url.includes((<span class="hljs-string">&#39;http://&#39;</span>) || url.includes(<span class="hljs-string">&#39;https://&#39;</span>)) ? url : `<span class="hljs-keyword">http</span>://${url}`

const main = <span class="hljs-operator">a</span> =&gt; <span class="hljs-built_in">get</span>(<span class="hljs-operator">a</span>, res =&gt; {
  let b = <span class="hljs-string">&#39;&#39;</span>
  res.on(<span class="hljs-string">&#39;data&#39;</span>, d =&gt; {b += d.toString()})
  res.on(<span class="hljs-string">&#39;end&#39;</span>, () =&gt; <span class="hljs-built_in">log</span>(<span class="hljs-operator">wrap</span>(conv(b))))
})

<span class="hljs-keyword">if</span> (!module.parent) main(src)</code></pre><p>Thanks for reading! If you note any problems, please hit me up <a href="https://twitter.com/zacanger">on
Twitter</a> or put in an issue <a href="https://github.com/zacanger/blog/issues">on
Github</a>.</p>
<p>The full version of this module has been published at
<a href="http://npm.im/html2txt">html2txt</a>.</p>
]]></description><link>/2016/cli-apps-part-three.html</link><guid isPermaLink="true">/2016/cli-apps-part-three.html</guid><category><![CDATA[node]]></category><category><![CDATA[cli]]></category><category><![CDATA[terminal]]></category><category><![CDATA[html]]></category><category><![CDATA[markdown]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Wed, 28 Sep 2016 02:36:00 GMT</pubDate></item><item><title><![CDATA[haskell meetup, 1 sept 2016]]></title><description><![CDATA[<p>just a few random notes. most of this was way over my head.</p>
<p><a href="https://github.com/pinealservo/mamedb">https://github.com/pinealservo/mamedb</a></p>
<p>xml-conduit -- xml parsing</p>
<p>hasql - postgres lib</p>
<p>maybe keep all types etc in own file</p>
<p>cabal files: main-is Main.hs, list other of <em>our</em> modules.</p>
<p>build-depends are dependencies. install with stack.</p>
<p>stack build is like npm i</p>
<p>$$ -- ?
$= -- ?</p>
<p>combinators from conduit</p>
<p>conduit is a streaming library thing</p>
<p>better than lazy io</p>
<p>there&#39;s also pipes, another group of streaming abstractions</p>
<p>also iostreams -- uses io</p>
<p>in:</p>
<pre class="hljs"><code>parseMame :: MonadThrow m =&gt; ConduitM Event Machine m ()
parseMame = <span class="hljs-keyword">void</span> $ tagIgnoreAttrs <span class="hljs-string">&quot;mame&quot;</span> $ manyYield parseMachine</code></pre><p>void is explicitly discarding the value</p>
<p>you can use the -&gt; typeclass to build things, and use them as arrows,
including in type signatures.</p>
<p>in <code>rId &lt;- insertRom -&lt; rom</code>,
rom is input to insertrom ; insertrom&#39;s output is romid</p>
<p>stack ghci: ghci but for project</p>
<p>:r -- reload loaded module</p>
<p>11 -- oom</p>
]]></description><link>/2016/hs-meetup-9-1.html</link><guid isPermaLink="true">/2016/hs-meetup-9-1.html</guid><category><![CDATA[haskell]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Fri, 02 Sep 2016 03:45:00 GMT</pubDate></item><item><title><![CDATA[building command-line apps in node (a note-taking app)]]></title><description><![CDATA[<h1 id="build-a-note-taking-app-for-the-terminal-in-node">Build a Note-Taking App for the Terminal, in Node</h1>
<p>This is a follow-up to my <a href="blog.zacanger.com/2016/a-basic-cli-app-in-node.html">first
post</a> on writing
command-line apps in Node. I suggest you read that first, but this post should
stand on its own if you don&#39;t want to. Below is the little React component
generator that you&#39;d get if you follow that tutorial.</p>
<pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env node</span>

<span class="hljs-keyword">const</span> type = process.argv[<span class="hljs-number">2</span>]
<span class="hljs-keyword">const</span> component = process.argv[<span class="hljs-number">3</span>]
<span class="hljs-keyword">const</span> { writeFile } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;fs&#39;</span>)

<span class="hljs-keyword">const</span> help = () =&gt;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`</span>
  please pass component type <span class="hljs-keyword">and</span> component name
  <span class="hljs-attribute">example</span>: ./rcg.js <span class="hljs-keyword">function</span> Foo
<span class="hljs-string">`)</span>

<span class="hljs-keyword">if</span> (!component || !type) {
  <span class="hljs-keyword">return</span> help()
}

<span class="hljs-keyword">const</span> pureComponent = <span class="hljs-string">`</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>

<span class="hljs-keyword">const</span> ${component} = () =&gt; &lt;div&gt;${component}&lt;/div&gt;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ${component}
<span class="hljs-string">`.trim()</span>

<span class="hljs-keyword">const</span> classComponent = <span class="hljs-string">`</span>
<span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">$</span>{<span class="hljs-title">component</span>} <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> {</span>
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;${component}&lt;/div&gt;
    )
  }
}
<span class="hljs-string">`.trim()</span>

<span class="hljs-keyword">const</span> doTheThing = kind =&gt; (
  writeFile(<span class="hljs-string">`${component}.js`,</span> kind, <span class="hljs-string">&#39;utf8&#39;</span>, err =&gt; {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.log(err)
  })
)

<span class="hljs-keyword">switch</span> (type) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">&#39;function&#39;</span>:
    doTheThing(pureComponent)
    <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">&#39;class&#39;</span>:
    doTheThing(classComponent)
    <span class="hljs-keyword">break</span>
  <span class="hljs-attribute">default</span>:
    <span class="hljs-keyword">return</span> help()
}</code></pre><hr>
<h2 id="introduction">Introduction</h2>
<p>I really love writing little command-line utilities in Node. There are other
languages that may be better for this (Bash, Ruby, Perl), but Node is just more
<em>fun</em> than those (at least to me). I especially love trying to do simple little
tools with no dependencies, or wrapping up awesome modules to be used in your
terminal. The majority of <a href="https://www.npmjs.com/~zacanger">my published modules</a>
are little tools like this. A lot of folks only think of Node as the thing that
runs Express, or the thing that lets them test their code without a browser, or
whatever, though. So, this will be a short tutorial on writing a command-line
app in Node. At the end of it, you&#39;ll have a totally awesome little app for
taking notes in JSON. The full version of this app (with a few adjustments and
additions) is <a href="https://www.npmjs.com/package/lilnote">here</a>, and you can
install it to use in your terminal with <code>npm i -g lilnote</code>.</p>
<p>Okay, so, let&#39;s do stuff!</p>
<h2 id="update-node">Update Node</h2>
<p>First things first&mdash;make sure Node and npm are up to date. If you&#39;re
already using at least versions 6 of node and 3 of npm (<code>node -v</code> and <code>npm -v</code>
to find out), you&#39;re fine. Otherwise, you really should update.</p>
<p>I recommend using <a href="https://www.npmjs.com/package/n">n</a> for this. If you already
use NVM, go with that; if you&#39;re on Windows, you&#39;ll likely have to go download
the new version and manually install it. Otherwise, just <code>npm i -g n &amp;&amp; n latest
&amp;&amp; npm i -g npm@next</code> (you can leave out the last bit, but it&#39;s nice to have the
newest version of the coolest tools).</p>
<h2 id="start-a-project">Start a Project</h2>
<p>Make a new directory and start a project (<code>mkdir note-taking-app</code>, <code>cd
note-taking-app</code>, <code>npm init</code>, <code>touch index.js</code>, and <code>chmod +x index.js</code> to make
it executable).</p>
<p>You won&#39;t need any dependencies here; the <code>npm init</code> isn&#39;t vital, but if you
later wanted to add dependencies, publish this (please don&#39;t unless it&#39;s
significantly different from <a href="https://npmjs.com/package/lilnote">lilnote</a>!), or
something, it&#39;d be nice to just have this already set up.</p>
<p>If you want, you can add some fields to your <code>package.json</code> to specifiy that
it&#39;s a global, command-line sort of app. Add <code>&quot;preferGlobal&quot;: true</code> and <code>&quot;bin&quot;:
&quot;./index.js&quot;</code> for this.</p>
<h2 id="write-some-code">Write Some Code</h2>
<p>Open the <code>index.js</code> in your editor.</p>
<p>The first thing you&#39;ll need to write is the shebang. This is to let your shell
know how to execute this file. For a Node script, it should read <code>#!/usr/bin/env
node</code>. Any time you&#39;re writing an executable script, this goes on the first
line. You&#39;ll use a similar thing for any language you&#39;d use (for example,
<code>#!/bin/bash</code> for a Bash script, or <code>#!/usr/bin/ruby</code> for a Ruby script&mdash;
the <code>env</code> bit says &#39;find out what my computer thinks Node is, and execute that
script with that thing&#39;&mdash;it&#39;s the same idea as doing <code>which node index.js</code>).</p>
<p>We&#39;re going to require some stuff. If you happen to be using <code>babel-node</code> or
using <code>babel-register</code> you could use <code>import</code>s here, but we&#39;ll go with
<code>require</code>s because this means we can keep our app dependency-free.</p>
<p>Add <code>&#39;use strict&#39;</code> to the next line. You don&#39;t <em>have</em> to do this, <a href="https://www.nczonline.net/blog/2012/03/13/its-time-to-start-using-javascript-strict-mode">but you
should</a>.</p>
<p>We&#39;ll require just one thing to start with: <code>fs</code>, which is built in to Node.</p>
<p>Our file should currently look like this:</p>
<pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env node</span>

<span class="hljs-string">&#39;use strict&#39;</span>

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;fs&#39;</span>)</code></pre><p>Our app is going to read input from the terminal, so we&#39;ll need to use the
built-in <code>process</code>. This provides an <code>argv</code>, which is an &#39;argument
vector&#39;&mdash;an array of all things entered on the command-line, which will
always start with <code>node</code> and the file that&#39;s being run. So, we&#39;ll use
<code>process.argv[2]</code>, which will be the first manually entered argument. Sidenote:
<code>process</code> is an awesome piece of Node, and if you&#39;re not familiar with it, open
a REPL (just enter <code>node</code> in the terminal) and type in <code>process</code>, and skim
through that gigantic object.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> arg = process.argv[<span class="hljs-number">2</span>]</code></pre><p>Parsing arguments is tedious and sometimes difficult. There are a
<a href="https://github.com/tj/commander.js">lot</a> of
<a href="https://github.com/substack/minimist">awesome</a>
<a href="https://www.npmjs.com/package/yargs">modules</a> that exist for this, and if you
keep building cli apps in Node you should definitely investigate these, but for
this tutorial we&#39;ll parse options manually. In the same way that you should know
how HTTP works and then maybe use <a href="http://koajs.com">Koa</a> or
<a href="http://hapijs.com">hapi</a>, you should know how arguments work before deciding on
a library to handle them.</p>
<p>We&#39;ll need a couple of other things before we can really get going. We should
probably do something with that <code>fs</code> module&mdash;let&#39;s use it to specify a
piece of JSON we&#39;ll work against. I won&#39;t get into how to handle what happens if
that file doesn&#39;t already exist here, but you can check out <a href="https://github.com/zacanger/lilnote/blob/master/check-file.js#L10">lilnote&#39;s source
code</a> if
you&#39;re curious. For our purposes, you should <code>touch notes.json</code> in the same
directory as your app, and put an empty array (<code>[]</code>) in there. (Note: <code>lilnote</code>
uses a file under the user&#39;s home directory; that&#39;s another thing we won&#39;t worry
about right now, but it&#39;s <a href="https://github.com/zacanger/lilnote/blob/master/check-file.js#L10">pretty
easy</a> to do.)</p>
<p>Let&#39;s add another couple of declarations:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">n</span> = &#39;./<span class="hljs-keyword">notes</span>.json&#39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">file</span> = fs.readFileSync(<span class="hljs-keyword">n</span>)</code></pre><p>We&#39;ll also have a variable here for our read-in notes.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">notes</span> = JSON.<span class="hljs-keyword">parse</span>(<span class="hljs-keyword">file</span>)</code></pre><p>And since we&#39;ll be using <code>console.log</code> in a few places, let&#39;s just make that a
little shorter:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-built_in">log</span> = console.<span class="hljs-built_in">log</span></code></pre><p>Your file should now look something like this:</p>
<pre class="hljs"><code>#!/usr/bin/env node

&#39;<span class="hljs-keyword">use</span> strict&#39;

<span class="hljs-keyword">const</span> fs = require(&#39;fs&#39;)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">log</span> = console.<span class="hljs-literal">log</span>
<span class="hljs-keyword">const</span> arg = process.argv[2]
<span class="hljs-keyword">const</span> <span class="hljs-keyword">n</span> = &#39;./<span class="hljs-keyword">notes</span>.json&#39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">file</span> = fs.readFileSync(<span class="hljs-keyword">n</span>)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">notes</span> = JSON.<span class="hljs-keyword">parse</span>(<span class="hljs-keyword">file</span>)</code></pre><p>And your file structure should look something like:</p>
<pre class="hljs"><code>project-root
  package<span class="hljs-class">.json</span>
  index<span class="hljs-class">.js</span>
  notes.json</code></pre><h2 id="make-it-do-things">Make It Do Things</h2>
<p>So let&#39;s do stuff! First let&#39;s make a way to record notes taken. This will work
by just calling your script and treating the first argument as a note.</p>
<pre class="hljs"><code>./index<span class="hljs-class">.js</span> <span class="hljs-string">&quot;go to the grocery store&quot;</span>
./index<span class="hljs-class">.js</span> cook
./index<span class="hljs-class">.js</span> eat
./index<span class="hljs-class">.js</span> <span class="hljs-string">&quot;wash dishes&quot;</span></code></pre><p>Let&#39;s write a function for this.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> takeNote = (<span class="hljs-keyword">notes</span>, <span class="hljs-keyword">note</span>) =&gt; {
  <span class="hljs-keyword">notes</span>.push(<span class="hljs-keyword">note</span>)
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}</code></pre><p>Note that we&#39;re using function expressions, not function declarations. This
could also be written as:</p>
<pre class="hljs"><code>function takeNote (<span class="hljs-keyword">notes</span>, <span class="hljs-keyword">note</span>) {
  <span class="hljs-keyword">notes</span>.push(<span class="hljs-keyword">note</span>)
  <span class="hljs-keyword">var</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">file</span>, taken, &#39;utf8&#39;, function(<span class="hljs-keyword">err</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
    }
  })
}</code></pre><p>These extra parameters to <code>JSON.stringify()</code> make our JSON look decent. Check
out the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">docs on
MDN</a>
if you&#39;re not familiar with them.</p>
<p>We&#39;re taking in the array of notes and a note, and pushing that note to the
array of notes. Then we&#39;re using <code>writeFile()</code> from <code>fs</code> to write to the <code>file</code>
we declared earlier, using the <code>taken</code> we declared earlier, with the encoding
<code>UTF-8</code>. The callback here is in case there&#39;s an error&mdash;if the file doesn&#39;t
already exist, for example.</p>
<p>We should handle this function where we process our command-line arguments,
which we&#39;ll get to in a little bit.</p>
<p>Let&#39;s also write a function for removing a note by its index in the array.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> removeNote = (<span class="hljs-keyword">notes</span>, noteIndex) =&gt; {
  <span class="hljs-keyword">notes</span>.splice(noteIndex -1, 1)
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}</code></pre><p>Awesome! That&#39;s like 90% of our app right there.</p>
<p>We should probably handle some arguments so we can actually use this thing.</p>
<h2 id="make-it-all-work">Make It All Work</h2>
<p>We&#39;re going to do this with a series of <code>if</code> statements. We could also use a
<code>switch</code> here, but for a lot of people that&#39;ll seem a little unfamiliar. Let&#39;s
assume that you&#39;ll use <code>-s</code> to show all notes, and <code>-r</code> to remove a note. We
should also handle a case where there are no arguments passed.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (!arg) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(&#39;Please pass <span class="hljs-keyword">an</span> argument&#39;)
}
<span class="hljs-keyword">if</span> (arg &amp;&amp; arg === &#39;-r&#39;) {
  <span class="hljs-keyword">const</span> noteIndex = process.argv[3]
  <span class="hljs-keyword">return</span> removeNote(<span class="hljs-keyword">notes</span>, noteIndex)
}
<span class="hljs-keyword">if</span> (arg &amp;&amp; arg === &#39;-s&#39;) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">notes</span>)
}
<span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">return</span> takeNote(<span class="hljs-keyword">notes</span>, arg)
}</code></pre><p>So, that&#39;s a basic way to handle command-line options. Let&#39;s just wrap that last
bit in a function and call it at the end. It&#39;s not beautiful, but if you put a
little bit of work into this, you could have a decent app! Here&#39;s how your whole
file should look, now:</p>
<pre class="hljs"><code>#!/usr/bin/env node

&#39;<span class="hljs-keyword">use</span> strict&#39;

<span class="hljs-keyword">const</span> fs = require(&#39;fs&#39;)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">log</span> = console.<span class="hljs-literal">log</span>
<span class="hljs-keyword">const</span> arg = process.argv[2]
<span class="hljs-keyword">const</span> <span class="hljs-keyword">n</span> = &#39;./<span class="hljs-keyword">notes</span>.json&#39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">file</span> = fs.readFileSync(<span class="hljs-keyword">n</span>)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">notes</span> = JSON.<span class="hljs-keyword">parse</span>(<span class="hljs-keyword">file</span>)

<span class="hljs-keyword">const</span> takeNote = (<span class="hljs-keyword">notes</span>, <span class="hljs-keyword">note</span>) =&gt; {
  <span class="hljs-keyword">notes</span>.push(<span class="hljs-keyword">note</span>)
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}

<span class="hljs-keyword">const</span> removeNote = (<span class="hljs-keyword">notes</span>, noteIndex) =&gt; {
  <span class="hljs-keyword">notes</span>.splice(noteIndex -1, 1)
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}

<span class="hljs-keyword">const</span> runTheApp = () =&gt; {
  <span class="hljs-keyword">if</span> (!arg) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(&#39;Please pass <span class="hljs-keyword">an</span> argument&#39;)
  }
  <span class="hljs-keyword">if</span> (arg &amp;&amp; arg === &#39;-r&#39;) {
    <span class="hljs-keyword">const</span> noteIndex = process.argv[3]
    <span class="hljs-keyword">return</span> removeNote(<span class="hljs-keyword">notes</span>, noteIndex)
  }
  <span class="hljs-keyword">if</span> (arg &amp;&amp; arg === &#39;-s&#39;) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">notes</span>)
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> takeNote(<span class="hljs-keyword">notes</span>, arg)
  }
}

runTheApp()</code></pre><p>This isn&#39;t beautiful, but as with the last post, I&#39;ll leave it to you to clean
it up, handle funky cases, and whatnot. If you&#39;re having fun with this, check
back for my next post! Also, if you have any thoughts on fun command-line
projects in Node but aren&#39;t sure how to get started, hit me up <a href="https://twitter.com/zacanger">on
Twitter</a> and I&#39;ll see about writing something up!</p>
]]></description><link>/2016/note-taking-app.html</link><guid isPermaLink="true">/2016/note-taking-app.html</guid><category><![CDATA[node]]></category><category><![CDATA[cli]]></category><category><![CDATA[terminal]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 27 Aug 2016 02:45:00 GMT</pubDate></item></channel></rss>