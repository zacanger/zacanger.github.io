<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[angr]]></title><description><![CDATA[writings from zac anger]]></description><link>http://blog.zacanger.com/</link><generator>Ghost</generator><lastBuildDate>Wed, 01 Jun 2016 09:26:22 GMT</lastBuildDate><atom:link href="http://blog.zacanger.com/rss/index.xml" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[api design notes]]></title><description><![CDATA[<p>think in terms of positives, not negatives</p>
<p>for example &#39;ishidden(true)&#39; is confusing.
instead to &#39;isvisible&#39;.</p>
<p>think about ng-show/hide ng-disabled what? this is confusing.</p>
<p>instead of this, think in terms of enabled/showing</p>
<p>this is both for myself (because i get confused) and for other people</p>
<p>evidently it&#39;s not always clear especially to non-native english speakers what the hell is going on</p>
<p>example from ariya hidayat&#39;s blog:
if you asked him if <code>A</code> equals <code>a</code> if <code>caseInsensitive</code> is <code>false</code>, that&#39;d
take a minute of thinking to even understand. instead, why not just <code>caseSensitive</code>?</p>
]]></description><link>/2016/api-design-notes.html</link><guid isPermaLink="true">/2016/api-design-notes.html</guid><category><![CDATA[api]]></category><category><![CDATA[design]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 14 May 2016 21:09:28 GMT</pubDate></item><item><title><![CDATA[React Performance]]></title><description><![CDATA[<ul>
<li>Take a baseline measurement.<ul>
<li>There&#39;s no way to measure improvements without something to measure against.</li>
<li>Chrome&#39;s Timeline thing works well for this.</li>
<li>Try measuring total elapsed time between the initial paint and the final rendering.</li>
<li>Make sure the &#39;Paint&#39; and &#39;Screenshot&#39; options are checked.</li>
</ul>
</li>
<li>Obviously the first big one is to just make your production code production code.<ul>
<li><code>NODE_ENV=production</code>, <code>webpack -p</code>, etc.</li>
<li>You can do something like this in your Webpack config:</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// stuff</span>
<span class="hljs-string">plugins :</span> [
  <span class="hljs-keyword">new</span> webpack.DefinePlugin({
    <span class="hljs-string">&#39;process.env.NODE_ENV&#39;</span> : JSON.stringify(<span class="hljs-string">&#39;production&#39;</span>)
  })
, <span class="hljs-keyword">new</span> webpack.optimize.UglifyJsPlugin({
    <span class="hljs-string">compress :</span> {
      <span class="hljs-string">warnings :</span> <span class="hljs-literal">false</span>
    }
  })
]
<span class="hljs-comment">// stuff</span></code></pre><ul>
<li>Reduce calls to <code>React.createClass</code> (if we&#39;re still doing that).<ul>
<li>Try using React Inline Elements for this.</li>
<li>We could configure Babel for this like so (this example would go directly in your package.json):</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><span class="hljs-string">&quot;babel&quot;</span>: { <span class="hljs-string">&quot;env&quot;</span>: { <span class="hljs-string">&quot;production&quot;</span>: { <span class="hljs-string">&quot;plugins&quot;</span>: [
  <span class="hljs-string">&quot;transform-react-constant-elements&quot;</span>,
  <span class="hljs-string">&quot;transform-react-inline-elements&quot;</span>
] } } }</code></pre><ul>
<li>Keep checking against the initial benchmark.</li>
<li>&#39;babel-plugin-transform-react-remove-prop-types&#39; might also be useful. It removes unwanted/unused React.PropTypes.</li>
<li>There&#39;s also &#39;babel-preset-react-optimize&#39;</li>
</ul>
]]></description><link>/2016/react-performance.html</link><guid isPermaLink="true">/2016/react-performance.html</guid><category><![CDATA[react]]></category><category><![CDATA[performance]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 14 May 2016 21:06:37 GMT</pubDate></item><item><title><![CDATA[fetch]]></title><description><![CDATA[<p>fetch is a thing</p>
<p>uses promises</p>
<p>here&#39;s doing stuff with xhr:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()
xhr.open(<span class="hljs-string">&#39;GET&#39;</span>, url)
xhr.responseType = <span class="hljs-string">&#39;json&#39;</span>

xhr.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-comment">// do stuff with xhr.response</span>
}

xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#39;crap&#39;</span>)
}

xhr.send()</code></pre><p>and the equivalent with fetch:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-title">fetch</span><span class="hljs-params">(url)</span></span>
.<span class="hljs-function"><span class="hljs-title">then</span><span class="hljs-params">(res =&gt; res.json()</span></span>)
.<span class="hljs-function"><span class="hljs-title">then</span><span class="hljs-params">(data =&gt; /<em> do stuff with data </em>/)</span></span>
.<span class="hljs-function"><span class="hljs-title">catch</span><span class="hljs-params">(e =&gt; console.error(e)</span></span>)</code></pre><p>granted i&#39;m also using es2015 in the fetch example, which makes it even nicer-looking,
but whatever.</p>
<p>using esnext async functions:</p>
<pre class="hljs"><code><span class="hljs-list">(<span class="hljs-keyword">async</span><span class="hljs-list">()</span> =&gt; <span class="hljs-collection">{
  try <span class="hljs-collection">{
    let res = await fetch<span class="hljs-list">(<span class="hljs-keyword">url</span>)</span>
    let data = awat res.json<span class="hljs-list">()</span>
    // do stuff with data
  }</span> catch<span class="hljs-list">(<span class="hljs-keyword">e</span>)</span> <span class="hljs-collection">{
    console.error<span class="hljs-list">(<span class="hljs-keyword">e</span>)</span>
  }</span>
}</span>)</span><span class="hljs-list">()</span></code></pre><p>xhr is kinda gross. i mean, everyone&#39;s used to it, and it basically works, but... yech.</p>
<p>fetch is basically complete i think? i mean, evidently it&#39;s even in safari&#39;s dev preview version.</p>
<p>if it&#39;s made it to safari, it&#39;s probably safe to use.</p>
<p>fetch keeps req and res separate (they&#39;re constructors).</p>
<p>request.context lets you tell where the req actually came from (eg link vs loaded asset vs whatever).</p>
<p>you can throw a <code>no-cors</code> in your request so stuff doesn&#39;t fail (like it would with XHR) without CORS headers.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-string">&#39;//foo.com&#39;</span>, {mode : <span class="hljs-string">&#39;no-cors&#39;</span>})</span></span>.<span class="hljs-function"><span class="hljs-title">then</span><span class="hljs-params">(response =&gt; console.log(response.type)</span></span>) <span class="hljs-comment">// opaque</span></code></pre><p>can&#39;t actually read the content of response here, but it could be used by something else (add an event listener
for when it comes back, for example).</p>
<p>other modes: <code>same-origin</code>, <code>cors</code>, and <code>cors-with-forced-preflight</code>.</p>
<p>you could also cache that stuff, which is nice.</p>
<p>xhr buffers the entire response into memory. with fetch you can access the stream. actually with XHR you can access
it sort of, with <code>responseText</code> while it&#39;s still going on, but it&#39;s going to put it all in mem anyway.</p>
<pre class="hljs"><code>fetch(url)
.then(response =&gt; {
  <span class="hljs-keyword">let</span> foo = &#39;some <span class="hljs-type">string</span>, <span class="hljs-keyword">for</span> example&#39;
  <span class="hljs-keyword">let</span> reader = response.body.getReader()
  reader.read().then(<span class="hljs-literal">result</span>) =&gt; {
    // okay there&#39;s actually a little more to this, but the idea <span class="hljs-keyword">is</span>,
    // we can have an <span class="hljs-keyword">if</span> <span class="hljs-keyword">in</span> here to check <span class="hljs-keyword">if</span> this bit <span class="hljs-keyword">of</span> the stream
    // <span class="hljs-keyword">is</span> equal to the thing we want. <span class="hljs-keyword">and</span> then, say
    reader.cancel(&#39;i guess we\&#39;re done, here&#39;)
  }
})
.then(<span class="hljs-literal">result</span> =&gt; /<em> <span class="hljs-keyword">do</span> stuff </em>/)
.catch(e =&gt; console.error(e))</code></pre><p><code>response.body</code> is a <code>ReadableStream</code>.</p>
<p>How cool is this? Think about it. You have a stream of data from somewhere. You can generate
content on the go, using that, with fetch. You can feed that to the view as you get it.</p>
<p>I guess fetch didn&#39;t have streams when it first started to be implemented, so they have some
other readers they stuck in there. So, <code>response</code> (or <code>request</code> actually, too), then</p>
<ul>
<li><code>.arrayBuffer()</code></li>
<li><code>.blob()</code></li>
<li><code>.formData()</code></li>
<li><code>.json()</code></li>
<li>and <code>.text()</code></li>
</ul>
<p>Once they&#39;ve been called, you can&#39;t call another one on that same stream (they &#39;drain&#39; the stream). What we could
do instead is <code>.clone()</code>: <code>fetch(url).then(response =&gt; respone.clone().json().catch() =&gt; response.text())</code>.</p>
<p>You can check <code>response.headers</code> to decide what you need to do with it.</p>
<pre class="hljs"><code>fetch(url)
.<span class="hljs-keyword">then</span>(response =&gt; {
  <span class="hljs-keyword">if</span> (response.headers.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#39;Content-Type&#39;</span>) === <span class="hljs-string">&#39;application/json&#39;</span>) {
    <span class="hljs-constant">return</span> response.json()
  }
  <span class="hljs-constant">return</span> response.<span class="hljs-keyword">text</span>()
})</code></pre><p><code>headers</code> can be used for reading and writing, has <code>Headers.prototype[Symbol.iterator]</code>. You get better
control over cache, and same-origin requests without credentials (no credentials is fetch&#39;s default).</p>
<p>You <em>can&#39;t</em> abort a request with fetch before at least the headers come back (yet).</p>
<p>You can&#39;t track progress (yet), but you can do stuff to do that on your own (by working with <code>Content-Length</code>).</p>
<p>Sync is in the spec, but doesn&#39;t look like anyone will implement that in the API.</p>
<p>Oh right, thre are other verbs here. Or just POST?</p>
<pre class="hljs"><code>fetch(url, {
  <span class="hljs-keyword">method</span>  : &#39;post&#39;
, headers : {&#39;<span class="hljs-type">Content</span>-<span class="hljs-type">Type</span>&#39; : &#39;application/x-www-form-urlencoded; charset=<span class="hljs-type">UTF</span>-<span class="hljs-number">8</span>&#39;}
, body    : &#39;stuff=things&amp;hello=world&#39;
})
.then(/<em> etc. </em>/)</code></pre><p>And credentials (like cookies, for example): <code>fetch(url, {credentials : &#39;include&#39;})</code></p>
<p>There&#39;s a node module called <code>fetch-it</code> which is basically like (and is based on <code>axios</code>), but using fetch
instead of XHR. Looks pretty nice.</p>
<p>There are a bunch of other fetch implementations. But it&#39;s already basically in browsers, so Node can&#39;t be
<em>too</em> far behind... right?</p>
]]></description><link>/2016/fetch.html</link><guid isPermaLink="true">/2016/fetch.html</guid><category><![CDATA[js]]></category><category><![CDATA[fetch]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 12 May 2016 16:23:31 GMT</pubDate></item><item><title><![CDATA[cs notes]]></title><description><![CDATA[<p>notes on a bunch of stuff</p>
<h2 id="big-o-">Big O:</h2>
<ul>
<li>analyzing the efficiency of algorithms (or code).</li>
<li>One could figure how much time fn will take given n input(s).</li>
<li>But really more interested in orders of magnitude than precise differences
(eg 100ms vs 10000ms, not 100ms vs 110ms).</li>
</ul>
<pre class="hljs"><code><span class="hljs-comment">// this is <code>O(n)</code>. we go through the input(s) once, in a loop.</span>
<span class="hljs-keyword">const</span> crossAdd = input =&gt; {
  <span class="hljs-keyword">let</span> answer = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++) {
    <span class="hljs-keyword">let</span>
      up = input[i]
    , dn = input[input.length - <span class="hljs-number">1</span> - i]
    answer.push(up + dn)
  }
  <span class="hljs-keyword">return</span> answer
}

<span class="hljs-comment">// also <code>O(n)</code>.</span>
<span class="hljs-comment">// we assume the worst, here. and the worst is that</span>
<span class="hljs-comment">// the last element of <code>haystack</code> would match <code>needle</code>.</span>
<span class="hljs-keyword">const</span> find = (needle, haystack) =&gt; {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; haystack.length; i++) {
    <span class="hljs-keyword">if</span> (haystack[i] === needle) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
    }
  }
}

<span class="hljs-comment">// this is <code>O(n2)</code> (imagine that <code>2</code> is superscript, please).</span>
<span class="hljs-comment">// we have to basically go through an extra loop every time we need</span>
<span class="hljs-comment">// to go through one loop.. this is bad.</span>
<span class="hljs-keyword">const</span> makeTuples = input =&gt; {
  <span class="hljs-keyword">let</span> answer = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; input.length; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; i &lt; input.length; j++) {
      answer.push([input[i], input[j]])
    }
  }
  <span class="hljs-keyword">return</span> answer
}

<span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#39;stuff&#39;</span> <span class="hljs-comment">// this would be called <code>O(1)</code>, meaning &#39;constant time&#39;</span>

<span class="hljs-comment">// <code>O(log n)</code> is a good. recursion, for example, can be helpful here.</span>
<span class="hljs-comment">// this is tough to understand without having any real background in math</span>
<span class="hljs-comment">// i think what this mens is, so, <code>log n</code> means something like, what you&#39;d need</span>
<span class="hljs-comment">// to raise 2 by (exponentially) to get to <code>n</code>. so if <code>n = 1024</code>, <code>O(n)</code> is like</span>
<span class="hljs-comment">// saying <code>fn(1024)</code>, and <code>O(log n)</code> would be like saying <code>fn(32)</code>... or something</span>
<span class="hljs-comment">// ... sort of? whatever, not gonna stress about it too much right this minute.</span></code></pre><h2 id="sorts">Sorts</h2>
<ul>
<li>A bubble sort is <code>O(n2)</code>, because there are two loops:<ul>
<li>One to check if the indices of two elements ought to be swapped, and</li>
<li>An outer loop to see if the swap took place</li>
</ul>
</li>
<li>An insertion sort is slightly better.<ul>
<li>It&#39;d be useful if you&#39;re reasonably confident that what you&#39;re sorting is already
somewhat close to being sorted.</li>
<li>This could be anywhere from <code>O(n2)</code> to <code>O(n)</code>.</li>
</ul>
</li>
<li>Merge sort is recursive.<ul>
<li>The way this works is to take your list, split it, and then call itself (the sort)
on each half.</li>
<li>Then that repeats for each smaller bit. Once the list gets down to one, that&#39;s returned.</li>
<li>Then I guess you&#39;d have another merge going on that&#39;s going over each pair (or set?) of
lists and merging that, and then on back up, until it&#39;s done.</li>
<li><code>Array.sort()</code> is usually a merge sort.</li>
<li>A merge sort will also keep equivalent elements at their original indicies.<ul>
<li>Apparenty we call that being <em>stable</em>.</li>
</ul>
</li>
<li><code>O(n log n)</code>. Wat.</li>
</ul>
</li>
<li>Quicksort is also recursive.<ul>
<li>It&#39;s the other one some engines use for <code>Array.prototype.sort</code>.</li>
<li>Take the last el, and call it your pivot.<ul>
<li>Everything smaller goes to the &#39;left&#39; of that, everything larger to the right.</li>
<li>Then the same sort is called on each half.</li>
<li>Each returns, and then the left, pivot, and right are catenated (in that order).</li>
<li>When you get to a list of one or zero, it just returns.</li>
</ul>
</li>
<li>This is also <code>O(n log n)</code>.<ul>
<li>Uses less memory than a merge sort (doesn&#39;t have to create new lists all over the place).</li>
<li>Performs like crap on an already-sorted list, since it&#39;d be starting with a pivot of the
largest element, already.<ul>
<li>You can get around that by doing stuff like checking the 0, length -1, and in the middle,
and swapping if need be to get a better pivot.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="data-structures">Data Structures</h2>
<h3 id="interfaces">Interfaces</h3>
<ul>
<li>Interfaces?<ul>
<li>Meaning, we just want to consume that data structure.</li>
<li>We don&#39;t need to know how it works, just that it acts some specific, expected way.</li>
</ul>
</li>
<li>Sets are nice. We have these in ES6 now.<ul>
<li>Sets will always at least let you:<ul>
<li><strong>add</strong> items,</li>
<li>check if the set <strong>contains</strong> them,</li>
<li><strong>remove</strong> items,</li>
<li>and call <strong>toList</strong> (or similar; JS sets have <code>.values()</code> but for an Array you&#39;d want to do
something like <code>const arr = Array.from(someSet)</code> or <code>const arr = [...someSet]</code>.<ul>
<li>This won&#39;t come back in any particular order -- sets don&#39;t keep track of that.</li>
</ul>
</li>
</ul>
</li>
<li>What I can really see useful about them is that they don&#39;t allow duplicate values.<ul>
<li>If you do something like <code>const s = new Set ; s.add(&#39;foo&#39;) ; s.add(&#39;foo&#39;)</code> it won&#39;t yell at you,
but if you then do <code>s.values()</code> you&#39;ll just see <code>SetIterator { &#39;foo&#39; }</code>.</li>
</ul>
</li>
</ul>
</li>
<li>Maps are basically the same sort of concept as a hash/dictionary/JS object, except without all the
extra bits that JS objects have (methods, inheritance, etc.).<ul>
<li>Basically just a collection of key-value pairs, except:<ul>
<li>Really more like a <em>set</em> of keys, with values associated with them, so</li>
<li>Again, no duplicates!</li>
<li>You could have duplicate <em>values</em> though. Just not duplicate keys.</li>
</ul>
</li>
</ul>
</li>
<li>Stacks are kinda like what they sound like.<ul>
<li>Only <code>push</code> and <code>pop</code> type of things.</li>
<li>LIFO</li>
<li>So if you have a stack that&#39;s like <code>a b c</code> and you push <code>d</code>, then pop, you&#39;ll get <code>d</code> returned
(and removed from the stack).</li>
<li>Frequently have a &#39;peek&#39;-like method for looking at the top of the stack without actualy doing
anything.</li>
<li>Easiest way to visualize this is probably just thinking about the order of execution of something
trivial, like a function that calls two functions, one of which maybe calls another funciton or two.</li>
</ul>
</li>
<li>Queues are FIFO.<ul>
<li>These would have methods like <code>enqueue</code> (push) and <code>dequeue</code> (pop), and probably a &#39;peek&#39; type of
thing too.</li>
<li>With priority queues, things that have a higher priority can be sort of rushed through the line,
basically, and dequeued earlier.</li>
</ul>
</li>
</ul>
<h3 id="implementations">Implementations</h3>
<ul>
<li>An ArrayList (it&#39;s a Java thing, I guess -- JS has arrays, and we don&#39;t really need to think all that
much about how they actually do their job because we have GC--wait, does Java not? Oh. Huh. Poor them.)
addresses specific indices like normal, but when you remove items from the array, you have to, like,
shrink it back down because you have to think about that bit of memory.<ul>
<li>So I guess, say you do the equivalent of <code>.splice()</code> or something, you have to actually say &#39;okay, get rid of element [2], then move everything from [3] to the end back one, then get rid of the last one, please&#39; or something.</li>
</ul>
</li>
<li>So, I hear a lot about linked lists. Apparently they&#39;re super important because it&#39;s one of like three
things any CS grad knows. Almost definitely in Java.<ul>
<li>A linked list is just a list where each element is aware of the next element.</li>
<li>So basically it&#39;s a list where each item has two properties:<ul>
<li>Its actual value, and</li>
<li>A pointer (or reference) to the next node (element)</li>
</ul>
</li>
<li>A linked list&#39;s <code>add</code> and <code>remove</code> would be <code>O(1)</code>, then, because all you need to do is change the
pointer on the previous node.<ul>
<li>Its <code>get</code> would be <code>O(n)</code> though because you need to loop through up &#39;til you get to the right node.</li>
<li>The ArrayList would be the other way around, it&#39;d have a <code>delete</code> and <code>add</code> of <code>O(n)</code> and a <code>get</code> of <code>O(1)</code>.</li>
</ul>
</li>
</ul>
</li>
<li>BST!<ul>
<li>Each node will have either 0, 1, or 2 subtrees.<ul>
<li>Every el in the left subtree will be less than the value of the node.</li>
<li>Every el in the right will be greater.</li>
</ul>
</li>
<li>Just have to change pointers, then, to add.<ul>
<li>Basically just walk down the tree and find the right spot.</li>
</ul>
</li>
<li>Roughly <code>O(log n)</code> on <code>get</code>, <code>add</code>, and <code>delete</code>.<ul>
<li>Can be as bad as <code>O(n)</code> if a sorted list is stuck in there.</li>
</ul>
</li>
</ul>
</li>
<li>Solution to some of the problems of a BST? AVL tree.<ul>
<li>(It&#39;s got some long name, so we&#39;ll stick with the abbreviation.)<ul>
<li>This is a &#39;self-balancing binary search tree.&#39;</li>
</ul>
</li>
<li>BSTs can get out of whack.</li>
<li>An AVL tree is always a valid BST (but not always the other way around).</li>
<li>Adding works the same, except that you check to see if the node is balanced after adding.</li>
<li>It&#39;s unbalanced if there&#39;s a height difference greater than one on the subtrees.</li>
<li>Worst case? <code>O(log n)</code>.</li>
<li>You could end up in a situation where you need a double rotation.<ul>
<li>Basically, if the opposite child is heavy during rotation.</li>
<li>So before you do the (probably initially intended) rotation, you do one on the root
node of that rotation, opposite-wise.</li>
</ul>
</li>
</ul>
</li>
<li>Hash tables have constant-time get, delete, and add (if you&#39;re working with a set or a map).<ul>
<li>So, you&#39;ve got a key, and you hash that (MD5 or whatever).<ul>
<li>Now we&#39;ve got a key that points to some addressable space.</li>
<li>This isn&#39;t really a thing in JS.</li>
</ul>
</li>
<li>This is neat in other languages because you can just work against that space, without
needing to do the (logic) work of hunting things down, kinda, basically.</li>
<li>No concept of order.</li>
<li>Uses a fair bit of memory.</li>
<li>Needs an idempotent hash (that is, a super-pure function -- exact same output, provided the same
input, every single time.).</li>
<li>Hash also has to be very well distributed.</li>
<li>And fast.</li>
<li>Almost probably definitely maybe need to use <code>%</code> to get your hash down to a manageable number you can
actually use (smaller than the largest index of your array).</li>
</ul>
</li>
</ul>
<h2 id="some-fp-basics">Some FP Basics</h2>
<ul>
<li>Purity<ul>
<li>Don&#39;t you dare touch my state!</li>
</ul>
</li>
<li>HOF</li>
<li>Vector (or array) programming is especially fp-friendly.<ul>
<li>It makes sense to expect that you can chain functions together.</li>
<li>This ends up being much, <em>much</em> more declarative.</li>
<li>Just think about <code>map</code>, <code>reduce</code>, and <code>filter</code>.</li>
</ul>
</li>
</ul>
]]></description><link>/2016/cs-notes.html</link><guid isPermaLink="true">/2016/cs-notes.html</guid><category><![CDATA[cs]]></category><category><![CDATA[algorithms]]></category><category><![CDATA[datastructures]]></category><category><![CDATA[sort]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 12 May 2016 16:21:24 GMT</pubDate></item><item><title><![CDATA[Forty Reasons To Wonder Why The Fuck You Love Apple]]></title><description><![CDATA[<p>A response to <a href="http://www.networkworld.com/article/3050934/macs/on-its-40th-anniversary-40-things-we-love-about-apple.html">this
absurdity</a>.</p>
<p>These are literally just a summary of each of those slides.</p>
<ul>
<li>Apple has a marketing team</li>
<li>their users are obsessed</li>
<li>they make decent clones of other products years after those products are the norm</li>
<li>they don&#39;t know their own target demographic</li>
<li>they make products</li>
<li>they make the same products year after year and announce them as if they&#39;re new</li>
<li>they make inferior products and market them as if they&#39;re worth buying</li>
<li>they still don&#39;t know their own users</li>
<li>their users are still obsessed</li>
<li>they have stores that sell their products</li>
<li>they put their products in boxes</li>
<li>they offer short-term care for their products after you buy them</li>
<li>they have stores that you have to wait to get into</li>
<li>they make products</li>
<li>they made products years ago, too</li>
<li>their products were not the exact same products as other products, years ago</li>
<li>one of the products they used to make was a printer</li>
<li>they also used to make... products</li>
<li>like an idiot, i don&#39;t back up my data. and when a hard drive fails, i prefer to buy a new computer of a different
brand and then blame an entire major segment of consumer electronics for my own stupidity.</li>
<li>i noce bought one of their products</li>
<li>they make overpriced things that don&#39;t offer anything that any other platform doesn&#39;t have, but i by their crap anyway</li>
<li>their smartphones offer all the same functionality that flip phones have</li>
<li>they make apps</li>
<li>at one point the company almost totally failed, but then didn&#39;t</li>
<li>some people who work at Apple aren&#39;t native English speakers</li>
<li>i buy their products both for myself and for my kids sometimes</li>
<li>they made another &#39;new&#39; product that had already been on the market for years</li>
<li>they even had a marketing team back when CDs were still a thing</li>
<li>they made a really shitty mouse that everyone hated, aww, look at them trying, so cute</li>
<li>applescript is such a joke that it wasn&#39;t going to be included in OS X until, whoops, someone put them on the spot
about it</li>
<li>there is a voice assistant</li>
<li>Apple had a version of BASIC which was almost the same but not <em>exactly</em> the same as any of the other BASICs on the
market at the time</li>
<li>they had PR person that nobody liked</li>
<li>their computers can run software, including some games</li>
<li>they have stores not just where you are but in other places also</li>
<li>they have both marketing and PR people</li>
<li>they sometimes sponsor events, in the same way that most large companies sometimes sponsor events</li>
<li>they sometimes have TV commercials</li>
<li>there are people who like their products enough to sometimes write about them</li>
</ul>
<p>... are you fucking kidding me?</p>
<p>Here&#39;s a couple of things to like about Macs/Apple. Keep in mind that I don&#39;t own any Apple products, and haven&#39;t owned
any since before Mac OS X. I have used them regularly over the past several years, though.</p>
<ul>
<li>Their hardware doesn&#39;t suck. It&#39;s not great, performance-wise, for the price, but it&#39;s good hardware.<ul>
<li>Great battery life (due to the fancy it&#39;s-not-in-just-one-place-in-your-laptop battery).</li>
<li>Great displays (if you pay for the great display).</li>
<li>The cases (speaking of their laptops, here) are <em>gorgeous</em>.</li>
<li>They&#39;re super light. Yes, there are Windows laptops that are also super light. Those Windows laptops also probably
cost less and are more powerful, generally. But you can get a powerful Mac that&#39;s also lightweight (for like $3500).</li>
<li>The keyboards, while annoyingly different from literally every other type of computer ever, have a nice feel.
(My current laptop, and the one I used just prior to this one, had equally good keyboards. They&#39;re not only a
Mac thing.)</li>
</ul>
</li>
<li>Under the hood, Mac OS X is a (gimped) BSD. It&#39;s a PITA sometimes to actually get to the good parts, and it&#39;s a lot
easier to just throw Linux on a (much cheaper, probably faster) laptop, but it can be made into a really nice
development environment. It takes some work on any platform (and is virtually impossible on Windows, unless you&#39;re
developing to target Windows), but on Macs it&#39;s a little more difficult to get to the UNIX-y bits than on a Linux or
BSD.</li>
<li>Macs are trendy. People who really believe they &#39;think different&#39; will think you&#39;re cool for having one. Of course,
all that means is that you believe the same marketing as those people, but they&#39;re not a bad bunch to be kinda lumped
together with, usually.</li>
<li>There&#39;s some software (and I&#39;m thinking specifically of design software here) that just isn&#39;t available for other
platforms. I still can&#39;t accept that it&#39;s a good idea to only target Mac, but The Omni Group has been doing it for
like 27 years and they&#39;re still around, so I guess it works. This fits in with the whole &#39;we make products for a
specific type of person and if you are that type of person you NEED to use this product&#39; kind of marketing though.
There are great design tools available on Windows (Adobe products, for example, or Macaw). There are even great tools
for Linux. Go ahead and laugh at GIMP and Inkscape -- they&#39;ve been around forever and are <em>incredibly</em> powerful. And
we (Linux users) also have Scribus, Blender, Lightworks, Krita, Radiance, Darktable (which is hands-down the best RAW
editor I&#39;ve ever seen), and a host of fantastic video tools -- plus, of course, ImageMagick and everything that
allows.</li>
<li>Mac OS X isn&#39;t Windows.<ul>
<li>I should say that Windows <em>is</em> good at some things. I think. Not the OS itself, but having the OS, it&#39;s probably a
good idea if you&#39;re really into games, or developing specifically for Microsoft products (VB, C#, whatever).</li>
</ul>
</li>
</ul>
]]></description><link>/2016/forty-reasons-to-wonder-why-the-fuck-you-love-apple.html</link><guid isPermaLink="true">/2016/forty-reasons-to-wonder-why-the-fuck-you-love-apple.html</guid><category><![CDATA[apple]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Mon, 09 May 2016 17:14:00 GMT</pubDate></item><item><title><![CDATA[words]]></title><description><![CDATA[<p>words i regret the most:</p>
<blockquote>
<p>it&#39;s cold. you should go.</p>
<p>i&#39;ll see you later.</p>
<p>i should go.</p>
<p>we&#39;ll catch up later, yeah?</p>
<p>it&#39;s been a long day, i&#39;m headed home.</p>
<p>give me a call sometime.</p>
</blockquote>
<p>i have a really hard time with losing people.</p>
<p>and also with losing opportunities.</p>
]]></description><link>/2016/words.html</link><guid isPermaLink="true">/2016/words.html</guid><category><![CDATA[personal]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sun, 08 May 2016 16:53:00 GMT</pubDate></item><item><title><![CDATA[fizzbuzz]]></title><description><![CDATA[<h1 id="fizzbuzz-">fizzbuzz!</h1>
<p>i like to collect fizzbuzz solutions. that&#39;s a little weird, i guess. but fun.</p>
<p>fizzbuzz is kind of the stereotypical pointless toy problem/whiteboarding problem.</p>
<p>if you&#39;re not familiar, here&#39;s the standard definition of the problem:</p>
<p>write a program that prints numbers from 1 to 100, but for multiples of
three print &#39;fizz,&#39; for multiples of five print &#39;buzz,&#39; and for multiples
of both three and five print &#39;fizzbuzz.&#39;</p>
<p>and some good reading on fizzbuzz:</p>
<ul>
<li><a href="http://c2.com/cgi/wiki?FizzBuzzTest">http://c2.com/cgi/wiki?FizzBuzzTest</a></li>
<li><a href="http://blog.codinghorror.com/why-cant-programmers-program/">http://blog.codinghorror.com/why-cant-programmers-program/</a></li>
<li><a href="https://www.rosettacode.org/wiki/FizzBuzz">https://www.rosettacode.org/wiki/FizzBuzz</a></li>
<li><a href="http://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/">http://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/</a></li>
</ul>
<p>i keep a bunch of solutions in js <a href="https://github.com/zacanger/pineapple-curry/tree/solutions/fizzbuzz">here</a>.</p>
<p>here are some of them (including some other languages).</p>
<h2 id="in-c">in c</h2>
<pre class="hljs"><code><span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fizzbuzz from 1 through 100.\n&quot;</span>);
  <span class="hljs-keyword">int</span> hundred;
  <span class="hljs-keyword">for</span> (hundred = <span class="hljs-number">1</span>; hundred &lt;= <span class="hljs-number">100</span>; hundred++){
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, hundred);
    <span class="hljs-keyword">if</span> (hundred % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fizz&quot;</span>);
    } <span class="hljs-keyword">if</span> (hundred % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Buzz\n&quot;</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre><h2 id="coffeescript">coffeescript</h2>
<pre class="hljs"><code><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> in <span class="hljs-matrix">[<span class="hljs-number">1.</span><span class="hljs-number">.100</span>]</span>
  str = <span class="hljs-string">&#39;&#39;</span>
  str += <span class="hljs-string">&#39;Fizz&#39;</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span> <span class="hljs-comment">% 3 is 0</span>
  str += <span class="hljs-string">&#39;Buzz&#39;</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span> <span class="hljs-comment">% 5 is 0</span>
  console.<span class="hljs-built_in">log</span> (<span class="hljs-keyword">if</span> str.<span class="hljs-built_in">length</span> is <span class="hljs-number">0</span> then <span class="hljs-built_in">i</span> <span class="hljs-keyword">else</span> str)</code></pre><h2 id="php">php</h2>
<pre class="hljs"><code>&lt;?php

<span class="hljs-keyword">function</span> fizzbuzz(<span class="hljs-variable">$num</span>) {
  if (<span class="hljs-variable">$num</span> % <span class="hljs-number">15</span> == <span class="hljs-number">0</span>) {
    print(<span class="hljs-string">&quot;FizzBuzz&quot;</span> . PHP_EOL);
  } else if (<span class="hljs-variable">$num</span> % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {
    print(<span class="hljs-string">&quot;Buzz&quot;</span> . PHP_EOL);
  } else if (<span class="hljs-variable">$num</span> % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {
    print(<span class="hljs-string">&quot;Fizz&quot;</span> . PHP_EOL);
  } else {
    print(<span class="hljs-variable">$num</span> . PHP_EOL);
  }
}

<span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt;=<span class="hljs-number">100</span>; <span class="hljs-variable">$i</span>++)
{
  fizzbuzz(<span class="hljs-variable">$i</span>);
}</code></pre><h2 id="ruby">ruby</h2>
<pre class="hljs"><code>def fizz_buzz(num)
  <span class="hljs-literal">result</span> = &#39;&#39;
  <span class="hljs-literal">result</span> += &#39;<span class="hljs-type">Fizz</span>&#39; <span class="hljs-keyword">if</span> num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>
  <span class="hljs-literal">result</span> += <span class="hljs-string">&quot;Buzz&quot;</span> <span class="hljs-keyword">if</span> num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>
  puts(<span class="hljs-literal">result</span>.empty? ? num : <span class="hljs-literal">result</span>)
<span class="hljs-keyword">end</span>

(<span class="hljs-number">1</span>..<span class="hljs-number">100</span>).each{|x|
  fizz_buzz(x)
}

<span class="hljs-comment">####</span>

fizz = [<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;Fizz&quot;</span>].lazy.cycle
buzz = [<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;Buzz&quot;</span>].lazy.cycle
nums = (<span class="hljs-number">1</span>..<span class="hljs-type">Float</span>::<span class="hljs-type">INFINITY</span>).lazy

fizzbuzz = nums.zip(fizz,buzz).map <span class="hljs-keyword">do</span> |n,f,b|
  (f.empty? &amp;&amp; b.empty?) ? n.to_s : f + b
<span class="hljs-keyword">end</span>

puts fizzbuzz.take(<span class="hljs-number">100</span>).to_a

<span class="hljs-comment">####</span>

<span class="hljs-number">1</span>.upto(<span class="hljs-number">100</span>) <span class="hljs-keyword">do</span> |i|
  fizz = (i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>)
  buzz = (i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)
  puts <span class="hljs-keyword">case</span>
    <span class="hljs-keyword">when</span> fizz &amp;&amp; buzz then &#39;<span class="hljs-type">FizzBuzz</span>&#39;
    <span class="hljs-keyword">when</span> fizz then &#39;<span class="hljs-type">Fizz</span>&#39;
    <span class="hljs-keyword">when</span> buzz then &#39;<span class="hljs-type">Buzz</span>&#39;
    <span class="hljs-keyword">else</span> i
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">####</span>

<span class="hljs-number">1</span>.upto(<span class="hljs-number">100</span>) <span class="hljs-keyword">do</span> |i|
  <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>
    puts &#39;<span class="hljs-type">FizzBuzz</span>&#39;
  elsif i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>
    puts &#39;<span class="hljs-type">Fizz</span>&#39;
  elsif i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>
    puts &#39;<span class="hljs-type">Buzz</span>&#39;
  <span class="hljs-keyword">else</span>
    puts i
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><h2 id="python">python</h2>
<pre class="hljs"><code>i=<span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:i+=<span class="hljs-number">1</span>;<span class="hljs-keyword">print</span><span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-string">&quot;BzuzzizF&quot;</span>[::<span class="hljs-number">2</span>*j]<span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> <span class="hljs-number">1</span>&gt;i%(<span class="hljs-number">4</span>+j))<span class="hljs-keyword">or</span> i


print([<span class="hljs-string">&quot;FizzBuzz&quot;</span> <span class="hljs-keyword">if</span> x%<span class="hljs-number">15</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Fizz&quot;</span> <span class="hljs-keyword">if</span> x%<span class="hljs-number">3</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Buzz&quot;</span> <span class="hljs-keyword">if</span> x % <span class="hljs-number">5</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">101</span>)])


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fizz_buzz</span><span class="hljs-params">(num)</span>:</span>
    <span class="hljs-keyword">if</span> num % <span class="hljs-number">15</span> == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;FizzBuzz&quot;</span>
    <span class="hljs-keyword">elif</span> num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Buzz&quot;</span>
    <span class="hljs-keyword">elif</span> num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Fizz&quot;</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">print</span> num

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):
    fizz_buzz(i)



<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fizz_buzz</span><span class="hljs-params">(num)</span>:</span>
    <span class="hljs-keyword">if</span> num % <span class="hljs-number">15</span> == <span class="hljs-number">0</span>:
        print(<span class="hljs-string">&quot;FizzBuzz&quot;</span>)
    <span class="hljs-keyword">elif</span> num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:
        print(<span class="hljs-string">&quot;Buzz&quot;</span>)
    <span class="hljs-keyword">elif</span> num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>:
        print(<span class="hljs-string">&quot;Fizz&quot;</span>)
    <span class="hljs-keyword">else</span>:
        print(num)

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>):
    fizz_buzz(i)</code></pre><h2 id="haskell">haskell</h2>
<pre class="hljs"><code><span class="hljs-comment">-- i wrote this one</span>
<span class="hljs-module"><span class="hljs-keyword">module</span> Main <span class="hljs-keyword">where</span></span>

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = printAll $ map fizzBuzz [<span class="hljs-number">1.</span><span class="hljs-number">.100</span>]
  <span class="hljs-keyword">where</span>
    printAll [] = return ()
    printAll (x:xs) = putStrLn x &gt;&gt; printAll xs

<span class="hljs-title">fizzBuzz</span> :: <span class="hljs-type">Integer</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">fizzBuzz</span> n | n <code>mod</code> <span class="hljs-number">15</span> == <span class="hljs-number">0</span> = <span class="hljs-string">&quot;FizzBuzz&quot;</span>
           | n <code>mod</code> <span class="hljs-number">5</span>  == <span class="hljs-number">0</span> = <span class="hljs-string">&quot;Fizz&quot;</span>
           | n <code>mod</code> <span class="hljs-number">3</span>  == <span class="hljs-number">0</span> = <span class="hljs-string">&quot;Buzz&quot;</span>
           | otherwise       = show n



<span class="hljs-comment">-- i did not write these. found around.</span>

[max(show x)(concat[n|(f,n)&lt;-[(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Fizz&quot;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;Buzz&quot;</span>)],mod x f==<span class="hljs-number">0</span>])|x&lt;-[<span class="hljs-number">1.</span><span class="hljs-number">.100</span>]]

<span class="hljs-comment">-- gh:ryoia</span>
<span class="hljs-comment">-- i like this one. it&#39;s a lot like how i thought it was supposed to be</span>
<span class="hljs-comment">-- which means i can read it, except it&#39;s cleaner so i can see a simple way</span>
<span class="hljs-comment">-- to improve on my own super limited hs</span>
<span class="hljs-module"><span class="hljs-keyword">module</span> FizzBuzz <span class="hljs-keyword">where</span></span>

<span class="hljs-title">divBy</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">Bool</span>
<span class="hljs-title">divBy</span> d x = x <code>mod</code> d == <span class="hljs-number">0</span>

<span class="hljs-title">fizzBuzz</span> :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span>
<span class="hljs-title">fizzBuzz</span> x
  | divBy <span class="hljs-number">15</span> x = <span class="hljs-string">&quot;FizzBuzz&quot;</span>
  | divBy <span class="hljs-number">5</span>  x = <span class="hljs-string">&quot;Buzz&quot;</span>
  | divBy <span class="hljs-number">3</span>  x = <span class="hljs-string">&quot;Fizz&quot;</span>
  | otherwise  = show x


<span class="hljs-comment">-- the below are from haskellquiz</span>

<span class="hljs-comment">-- a FizzBuzz (and FizzBuzzBaz) solution by Aaron Contorer.</span>
<span class="hljs-comment">-- This implementation is designed for extensibility,</span>
<span class="hljs-comment">-- as the list of tags can be easily edited, loaded from a file, etc.</span>
<span class="hljs-comment">-- Number range is set &gt;100 so as to demonstrate the FizzBuzzBaz case.</span>
<span class="hljs-title">fizzBuzz</span> i = <span class="hljs-keyword">if</span> null desc <span class="hljs-keyword">then</span> show i <span class="hljs-keyword">else</span> desc <span class="hljs-keyword">where</span>
  desc = concat [label | (j,label) &lt;- tags, <span class="hljs-number">0</span> == rem i j]
  tags = [ (<span class="hljs-number">3</span>,<span class="hljs-string">&quot;Fizz&quot;</span>), (<span class="hljs-number">5</span>,<span class="hljs-string">&quot;Buzz&quot;</span>), (<span class="hljs-number">7</span>,<span class="hljs-string">&quot;Baz&quot;</span>) ]

<span class="hljs-title">main</span> = mapM<em> (putStrLn . fizzBuzz) [<span class="hljs-number">1.</span><span class="hljs-number">.120</span>]


<span class="hljs-comment">-- don&#39;t know if this works, but looks not nice.</span>
<span class="hljs-module"><span class="hljs-keyword">module</span> Main <span class="hljs-keyword">where</span></span>

  main :: <span class="hljs-type">IO</span> ()
  main = <span class="hljs-keyword">do</span>
    mapM</em> (putStrLn) [fizzBuzz x | x &lt; [<span class="hljs-number">0.</span><span class="hljs-number">.100</span>]]

    fizz :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span>
    fizz x = <span class="hljs-keyword">if</span> x <code>mod</code> <span class="hljs-number">3</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;fizz&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>

    buzz :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span>
    buzz x = <span class="hljs-keyword">if</span> x <code>mod</code> <span class="hljs-number">5</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&quot;buzz&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span>

    fizzBuzz :: <span class="hljs-type">Int</span> -&gt; <span class="hljs-type">String</span>
    fizzBuzz x = <span class="hljs-keyword">if</span> fizz(x) ++ buzz(x) == <span class="hljs-string">&quot;&quot;</span>
                    <span class="hljs-keyword">then</span> show x
                    <span class="hljs-keyword">else</span> fizz(x) ++ buzz(x)


<span class="hljs-comment">{-
Fizz comes before Buzz comes before an integer. Fizz and Buzz stick to each other, but hide integers.
The lists for Fizz and Buzz are infinite, but zipping together with a finite list of integers,
the result is finite.
-}</span>

<span class="hljs-module"><span class="hljs-keyword">module</span> Main <span class="hljs-keyword">where</span></span>

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = mapM<em> putStrLn $ zipWith3 join (loop <span class="hljs-number">3</span> <span class="hljs-string">&quot;Fizz&quot;</span>) (loop <span class="hljs-number">5</span> <span class="hljs-string">&quot;Buzz&quot;</span>) [<span class="hljs-number">1.</span><span class="hljs-number">.100</span>]
  <span class="hljs-keyword">where</span>
    xor s t = <span class="hljs-keyword">if</span> null s <span class="hljs-keyword">then</span> t <span class="hljs-keyword">else</span> s
    loop n s = cycle $ replicate (n-<span class="hljs-number">1</span>) [] ++ [s]
    join s t n = xor (s ++ t) (show n)

<span class="hljs-comment">{-
If one has enabled all warnings as errors, then the integers need an explicit type, as shown below.
The hiding logic can also be implemented by filtering for the first non-null element of a list:
-}</span>

<span class="hljs-module"><span class="hljs-keyword">module</span> Main <span class="hljs-keyword">where</span></span>
  <span class="hljs-module"><span class="hljs-keyword">module</span> Main <span class="hljs-keyword">where</span></span>

  main :: <span class="hljs-type">IO</span> ()
  main = sequence</em> $ zipWith3 join (loop <span class="hljs-number">3</span> <span class="hljs-string">&quot;Fizz&quot;</span>) (loop <span class="hljs-number">5</span> <span class="hljs-string">&quot;Buzz&quot;</span>) [<span class="hljs-number">1.</span><span class="hljs-number">.100</span> :: <span class="hljs-type">Int</span>]
    <span class="hljs-keyword">where</span>
      loop n s = cycle $ replicate (n-<span class="hljs-number">1</span>) <span class="hljs-string">&quot;&quot;</span> ++ [s]
      join s t n = putStrLn . head $ filter (not . null) [s ++ t, show n]</code></pre><h2 id="javascript">javascript</h2>
<pre class="hljs"><code>
<span class="hljs-keyword">for</span>(x=<span class="hljs-number">0</span>;x++&lt;<span class="hljs-number">100</span>;)console.log(x%<span class="hljs-number">3</span>||<span class="hljs-string">&#39;fizz&#39;</span>,x%<span class="hljs-number">5</span>||<span class="hljs-string">&#39;buzz&#39;</span>)

<span class="hljs-comment">////</span>

<span class="hljs-keyword">var</span>
  words = []
, func = <span class="hljs-keyword">null</span>
, l    = <span class="hljs-number">100</span>

<span class="hljs-keyword">var</span> conditions = {
  <span class="hljs-number">1</span>  : {
    <span class="hljs-keyword">true</span>  : <span class="hljs-keyword">null</span>
  , <span class="hljs-keyword">false</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(i)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        console.log(i)
      }
    }
  }
, <span class="hljs-number">3</span>  : {
    <span class="hljs-keyword">true</span>  : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> func;
    }
  , <span class="hljs-keyword">false</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        console.log(<span class="hljs-string">&#39;fizz&#39;</span>)
      }
    }
  }
, <span class="hljs-number">5</span>  : {
    <span class="hljs-keyword">true</span>  : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> func
    }
  , <span class="hljs-keyword">false</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        console.log(<span class="hljs-string">&#39;buzz&#39;</span>)
      }
    }
  }
, <span class="hljs-number">15</span> : {
    <span class="hljs-keyword">true</span>  : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> func
    }
  , <span class="hljs-keyword">false</span> : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        console.log(<span class="hljs-string">&#39;fizzbuzz&#39;</span>)
      }
    }
  }
}

<span class="hljs-keyword">for</span> (l = <span class="hljs-number">1</span>; l &lt; <span class="hljs-number">100</span>; l++) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> thing in conditions) {
    <span class="hljs-keyword">var</span> result = l % thing
    func = conditions[thing]<a href="l">!!result</a>
  }
  func()
}

<span class="hljs-comment">////</span>

Object.keys(<span class="hljs-keyword">new</span> Int8Array(<span class="hljs-number">100</span>))
.map(x      =&gt; ((++x % <span class="hljs-number">3</span>  ==  <span class="hljs-number">0</span>) ? f = <span class="hljs-string">&#39;fizz&#39;</span> : x))
.map((x, i) =&gt; ((++i % <span class="hljs-number">5</span>  ==  <span class="hljs-number">0</span>) ? b = <span class="hljs-string">&#39;buzz&#39;</span> : x))
.map((x, i) =&gt; ((++i % <span class="hljs-number">15</span> === <span class="hljs-number">0</span>) ? f + b : x))

<span class="hljs-comment">////</span>

<span class="hljs-comment">// this is basically the same as the usual solution, just sorta recursive also</span>
<span class="hljs-keyword">const</span> fizzBuzz = num =&gt; {
  <span class="hljs-keyword">if</span> (num % <span class="hljs-number">3</span> === <span class="hljs-number">0</span> &amp;&amp; num % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) {
    console.log(<span class="hljs-string">&#39;FizzBuzz&#39;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) {
    console.log(<span class="hljs-string">&#39;Fizz&#39;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) {
    console.log(<span class="hljs-string">&#39;Buzz&#39;</span>)
  } <span class="hljs-keyword">else</span> {
    console.log(num)
  }
  <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">let</span> newNum = num + <span class="hljs-number">1</span>
    fizzBuzz(newNum)
  }
}
fizzBuzz(<span class="hljs-number">1</span>)

<span class="hljs-comment">////</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fizzbuzz</span><span class="hljs-params">(num, fizz, buzz)</span> </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) {
    <span class="hljs-keyword">if</span> (i % (fizz <em> buzz) === <span class="hljs-number">0</span>) {
      console.log(<span class="hljs-string">&#39;FizzBuzz&#39;</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % buzz === <span class="hljs-number">0</span>) {
      console.log(<span class="hljs-string">&#39;Buzz&#39;</span>)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % fizz === <span class="hljs-number">0</span>) {
      console.log(<span class="hljs-string">&#39;Fizz&#39;</span>)
    } <span class="hljs-keyword">else</span> {
      console.log(i)
    }
  }
}
fizzbuzz(<span class="hljs-number">100</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)

<span class="hljs-comment">////</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
  <span class="hljs-keyword">let</span>
    mod3   = i % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>
  , mod5   = i % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>
  , result = mod3 &amp;&amp; mod5 ? <span class="hljs-string">&#39;fizzbuzz&#39;</span> : mod3 ? <span class="hljs-string">&#39;fizz&#39;</span> : mod5 ? <span class="hljs-string">&#39;buzz&#39;</span> : i
  console.log(result)
}

<span class="hljs-comment">////</span>

<span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>

<span class="hljs-keyword">while</span> (counter &lt; <span class="hljs-number">100</span>) {
  counter = counter + <span class="hljs-number">1</span>
  <span class="hljs-keyword">if</span> (counter % <span class="hljs-number">3</span> === <span class="hljs-number">0</span> &amp;&amp; counter % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) {
    console.log(<span class="hljs-string">&#39;FizzBuzz&#39;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counter % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) {
    console.log(<span class="hljs-string">&#39;Fizz&#39;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counter % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) {
    console.log(<span class="hljs-string">&#39;Buzz&#39;</span>)
  } <span class="hljs-keyword">else</span> {
    console.log(counter)
  }
}

<span class="hljs-comment">////</span>

<span class="hljs-keyword">let</span>
  div = ((n, s) =&gt; i =&gt; i % n ? <span class="hljs-string">&#39;&#39;</span> : s)
, f = div(<span class="hljs-number">3</span>,<span class="hljs-string">&#39;fizz&#39;</span>)
, b = div(<span class="hljs-number">5</span>,<span class="hljs-string">&#39;buzz&#39;</span>)
, loop = fn =&gt; i =&gt; i &gt; <span class="hljs-number">0</span> &amp;&amp; loop(fn)(i - <span class="hljs-number">1</span>) || fn(i)
, fizzbuzz = loop(i =&gt; console.log(f(i) + b(i) || i))
fizzbuzz(<span class="hljs-number">100</span>)

<span class="hljs-comment">// (or)</span>

<span class="hljs-keyword">let</span>
  div = ((n, s) =&gt; i =&gt; i % n ? <span class="hljs-string">&#39;&#39;</span> : s)
, f = div(<span class="hljs-number">3</span>,<span class="hljs-string">&#39;fizz&#39;</span>)
, b = div(<span class="hljs-number">5</span>,<span class="hljs-string">&#39;buzz&#39;</span>)
, fizzbuzz = i =&gt; i &gt; <span class="hljs-number">0</span> &amp;&amp; fizzbuzz((i - <span class="hljs-number">1</span>)) || console.log(f(i) + b(i) || i)
fizzbuzz(<span class="hljs-number">100</span>)

<span class="hljs-comment">////</span>

<span class="hljs-comment">// this may or may not continue to work in firefox</span>
<span class="hljs-comment">// it may not ever work anywhere else; list comprehensions were</span>
<span class="hljs-comment">// removed from es2015 drafts.</span>
console.log(
  [<span class="hljs-keyword">for</span> (i of <span class="hljs-keyword">Array</span>(<span class="hljs-number">100</span>).keys())
    (++i % <span class="hljs-number">3</span> ? <span class="hljs-string">&#39;&#39;</span> : <span class="hljs-string">&#39;fizz&#39;</span>) + (i % <span class="hljs-number">5</span> ? <span class="hljs-string">&#39;&#39;</span> : <span class="hljs-string">&#39;buzz&#39;</span>) || i]
  .join(<span class="hljs-string">&#39;\n&#39;</span>)
)

<span class="hljs-comment">////</span>


<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;++i&lt;<span class="hljs-number">101</span>;)console.log((i%<span class="hljs-number">3</span>?<span class="hljs-string">&#39;&#39;</span>:<span class="hljs-string">&#39;Fizz&#39;</span>)+(i%<span class="hljs-number">5</span>?<span class="hljs-string">&#39;&#39;</span>:<span class="hljs-string">&#39;Buzz&#39;</span>)||i)

<span class="hljs-comment">////</span>

<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">101</span>;i++)console.log((x=(i%<span class="hljs-number">3</span>?<span class="hljs-string">&#39;&#39;</span>:<span class="hljs-string">&#39;Fizz&#39;</span>)+(i%<span class="hljs-number">5</span>?<span class="hljs-string">&#39;&#39;</span>:<span class="hljs-string">&#39;Buzz&#39;</span>))?x:i)

<span class="hljs-comment">////</span>

a=b=!![]+![],a--,c=b+b;<span class="hljs-keyword">while</span>(++a)e=!(a%(c+c+b)),alert(!(a%(c+b))?e?<span class="hljs-string">&quot;FizzBuzz&quot;</span>:<span class="hljs-string">&quot;Fizz&quot;</span>:e?<span class="hljs-string">&quot;Buzz&quot;</span>:a);

<span class="hljs-comment">////</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">101</span>; i++) {
  console.log([i, <span class="hljs-string">&#39;fizz&#39;</span>, <span class="hljs-string">&#39;buzz&#39;</span>, <span class="hljs-string">&#39;fizzbuzz&#39;</span>][(i % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) + <span class="hljs-number">2</span> </em> ( i % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>)])
}

<span class="hljs-comment">////</span>

<span class="hljs-keyword">const</span> numGen = i =&gt; i ? numGen(i - <span class="hljs-number">1</span>).concat(i) : []

numGen(<span class="hljs-number">100</span>).map(n =&gt; n % <span class="hljs-number">3</span> ?
      (n % <span class="hljs-number">5</span> ? n : <span class="hljs-string">&#39;Buzz&#39;</span>) :
      (n % <span class="hljs-number">5</span> ? <span class="hljs-string">&#39;Fizz&#39;</span> : <span class="hljs-string">&#39;FizzBuzz&#39;</span>))

<span class="hljs-comment">////</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
  <span class="hljs-keyword">let</span>
    fizz = (!(i%<span class="hljs-number">3</span>)) ? <span class="hljs-string">&#39;Fizz&#39;</span> : <span class="hljs-string">&#39;&#39;</span>
  , buzz = (!(i%<span class="hljs-number">5</span>)) ? fizz + <span class="hljs-string">&#39;Buzz&#39;</span> : fizz
  console.log((buzz) ? buzz : i)
}

<span class="hljs-comment">////</span>

<span class="hljs-keyword">let</span> o, i

<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
  o = <span class="hljs-string">&#39;&#39;</span>
  i % <span class="hljs-number">3</span> === <span class="hljs-number">0</span> ? o += <span class="hljs-string">&#39;fizz&#39;</span> : o
  i % <span class="hljs-number">5</span> === <span class="hljs-number">0</span> ? o += <span class="hljs-string">&#39;buzz&#39;</span> : o
  o === <span class="hljs-string">&#39;&#39;</span> ? o = i : o
  console.log(o)
}

<span class="hljs-comment">////</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
  console.log({
    truefalse : <span class="hljs-string">&#39;Fizz&#39;</span>
  , falsetrue : <span class="hljs-string">&#39;Buzz&#39;</span>
  , truetrue  : <span class="hljs-string">&#39;FizzBuzz&#39;</span>
  }[(i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) + <span class="hljs-string">&#39;&#39;</span> + ( i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)] || i)
}

<span class="hljs-comment">////</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numGen</span><span class="hljs-params">(i)</span></span>{
  <span class="hljs-keyword">return</span> i ? numGen(i - <span class="hljs-number">1</span>).concat(i) : []
})(<span class="hljs-number">100</span>).map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span></span>{
  <span class="hljs-keyword">return</span> n % <span class="hljs-number">3</span> ?
    (n % <span class="hljs-number">5</span> ? n : <span class="hljs-string">&#39;Buzz&#39;</span>) :
    (n % <span class="hljs-number">5</span> ? <span class="hljs-string">&#39;Fizz&#39;</span> : <span class="hljs-string">&#39;FizzBuzz&#39;</span>)
}).join(<span class="hljs-string">&#39; &#39;</span>)

<span class="hljs-comment">////</span>

<span class="hljs-keyword">let</span> f, b, fb, n

<span class="hljs-keyword">for</span> (n = <span class="hljs-number">1</span>; n &lt;= <span class="hljs-number">100</span>; n++) {
  f  = !(n % <span class="hljs-number">3</span>)
  b  = !(n % <span class="hljs-number">5</span>)
  fb = f &amp;&amp; b
  console.log(
    fb ? <span class="hljs-string">&#39;fizzbuzz&#39;</span> :
   (f  ? <span class="hljs-string">&#39;fizz&#39;</span>     :
    b  ? <span class="hljs-string">&#39;buzz&#39;</span>     :
    n))
}

<span class="hljs-comment">////</span>

<span class="hljs-keyword">const</span> fizzBuzz = () =&gt; {
  <span class="hljs-keyword">let</span> i, output
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">101</span>; i += <span class="hljs-number">1</span>) {
    output = <span class="hljs-string">&#39;&#39;</span>
    <span class="hljs-keyword">if</span> (!(i % <span class="hljs-number">3</span>)) {
      output += <span class="hljs-string">&#39;Fizz&#39;</span>
    }
    <span class="hljs-keyword">if</span> (!(i % <span class="hljs-number">5</span>)) {
      output += <span class="hljs-string">&#39;Buzz&#39;</span>
    }
    console.log(output || i)
  }
}

<span class="hljs-comment">////</span>

<span class="hljs-keyword">const</span> word = x =&gt; {
  <span class="hljs-keyword">if</span> (!(x % <span class="hljs-number">15</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;fizzbuzz&#39;</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(x % <span class="hljs-number">3</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;fiz&#39;</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(x % <span class="hljs-number">5</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;buzz&#39;</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> x
  }
}

<span class="hljs-keyword">const</span> fb = max =&gt; <span class="hljs-keyword">Array</span>
  .apply(<span class="hljs-keyword">null</span>, {length : max + <span class="hljs-number">1</span>})
  .map(Number.call, Number)
  .splice(<span class="hljs-number">1</span>)
  .map(word)

<span class="hljs-comment">////</span>

<span class="hljs-function"><span class="hljs-keyword">function</span><em> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>
  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
    <span class="hljs-keyword">let</span> val = <span class="hljs-string">&#39;&#39;</span>
    idx++
    <span class="hljs-keyword">if</span> (idx % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) {
      val += <span class="hljs-string">&#39;Fizz&#39;</span>
    }
    <span class="hljs-keyword">if</span> (idx % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) {
      val += <span class="hljs-string">&#39;Buzz&#39;</span>
    }
    <span class="hljs-keyword">yield</span> val || idx
  }
}

<span class="hljs-keyword">let</span> fb = FizzBuzz()

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  console.log(fb.next().val)
}

<span class="hljs-comment">////</span>

<span class="hljs-keyword">const</span> range = n =&gt; [...<span class="hljs-keyword">Array</span>(n).keys()]

<span class="hljs-keyword">const</span> fbTest = n =&gt; {
  <span class="hljs-keyword">let</span>
    by3 = n % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>
  , by5 = n % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>

  <span class="hljs-keyword">return</span> by3 &amp;&amp; by5 ? <span class="hljs-string">&#39;fizz buzz&#39;</span> :
                by3 ? <span class="hljs-string">&#39;fizz&#39;</span>      :
                by5 ? <span class="hljs-string">&#39;buzz&#39;</span>      :
                n
}

<span class="hljs-keyword">const</span> fizzBuzz = n =&gt; range(n).map(x =&gt; fbTest(x + <span class="hljs-number">1</span>)).join(<span class="hljs-string">&#39;, &#39;</span>)

console.log(fizzBuzz(<span class="hljs-number">100</span>))

<span class="hljs-comment">////</span>

<span class="hljs-comment">// this (or a slight variation on this) is easily the most common solution</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fizz_buzz</span><span class="hljs-params">(num)</span></span>{
  <span class="hljs-keyword">if</span> (num % <span class="hljs-number">15</span> == <span class="hljs-number">0</span>) {
    console.log(<span class="hljs-string">&#39;FizzBuzz&#39;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {
    console.log(<span class="hljs-string">&#39;Buzz&#39;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {
    console.log(<span class="hljs-string">&#39;Fizz&#39;</span>)
  } <span class="hljs-keyword">else</span> {
    console.log(num)
  }
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
  fizz_buzz(i)
}

<span class="hljs-comment">////</span>

<span class="hljs-comment">#!/usr/bin/env node</span>

<span class="hljs-keyword">const</span> max = process.argv[<span class="hljs-number">2</span>]

<span class="hljs-keyword">let</span> FizzBuzz = <span class="hljs-function"><span class="hljs-keyword">function</span></em> <span class="hljs-params">()</span></span>{
  <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>
  <span class="hljs-keyword">while</span> (num &lt;= max){
    <span class="hljs-keyword">let</span> value = num
    num++
    <span class="hljs-keyword">if</span> (value % <span class="hljs-number">15</span> === <span class="hljs-number">0</span>) {
      value = <span class="hljs-string">&#39;FizzBuzz&#39;</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) {
      value = <span class="hljs-string">&#39;Fizz&#39;</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) {
      value = <span class="hljs-string">&#39;Buzz&#39;</span>
    }
    <span class="hljs-keyword">yield</span> value
  }
}()

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n of FizzBuzz){
  console.log(n)
}

<span class="hljs-comment">////</span>

<span class="hljs-keyword">const</span> fb = n =&gt; {
  <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">true</span>) {
    <span class="hljs-keyword">case</span> item % <span class="hljs-number">15</span> === <span class="hljs-number">0</span>:
      console.log(<span class="hljs-string">&#39;fizbuzz&#39;</span>)
      <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> item % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>:
      console.log(<span class="hljs-string">&#39;fizz&#39;</span>)
      <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">case</span> item % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>:
      console.log(<span class="hljs-string">&#39;buzz&#39;</span>)
      <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">default</span>:
      console.log(n)
      <span class="hljs-keyword">break</span>
  }
}

<span class="hljs-keyword">const</span> nums = <span class="hljs-keyword">Array</span>.apply(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">Array</span>(<span class="hljs-number">100</span>)).map(() =&gt; Math.round(Math.random() <em> <span class="hljs-number">100</span>) + <span class="hljs-number">1</span>)

nums.map(fb)

<span class="hljs-comment">////</span>

<span class="hljs-keyword">const</span> a = {fizz : <span class="hljs-number">3</span>, buzz : <span class="hljs-number">5</span>}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>; b &lt;= <span class="hljs-number">100</span>; b++) {
  <span class="hljs-keyword">let</span> c = <span class="hljs-string">&#39;&#39;</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> d in a) {
    c += b % a[d] ? <span class="hljs-string">&#39;&#39;</span> : d
  }
  console.log(c ? c : b)
}

<span class="hljs-comment">// this is nice because you can fizz buzz bing boom zing easily</span>
<span class="hljs-keyword">const</span> a = {
  fizz : <span class="hljs-number">3</span>
, buzz : <span class="hljs-number">5</span>
, bing : <span class="hljs-number">7</span>
, boom : <span class="hljs-number">11</span>
, zing : <span class="hljs-number">13</span>
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>; b &lt;= <span class="hljs-number">1000</span>; b++) {
  <span class="hljs-keyword">let</span> c = <span class="hljs-string">&#39;&#39;</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> d in a) {
    c += b % a[d] ? <span class="hljs-string">&#39;&#39;</span> : d
  }
  console.log(c ? c : b)
}

<span class="hljs-comment">////</span>

<span class="hljs-comment">// this is cheating</span>
alert(<span class="hljs-string">&#39;1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz 31 32 Fizz 34 Buzz Fizz 37 38 Fizz Buzz 41 Fizz 43 44 FizzBuzz 46 47 Fizz 49 Buzz Fizz 52 53 Fizz Buzz 56 Fizz 58 59 FizzBuzz 61 62 Fizz 64 Buzz Fizz 67 68 Fizz Buzz 71 Fizz 73 74 FizzBuzz 76 77 Fizz 79 Buzz Fizz 82 83 Fizz Buzz 86 Fizz 88 89 FizzBuzz 91 92 Fizz 94 Buzz Fizz 97 98 Fizz Buzz&#39;</span>)

<span class="hljs-comment">////</span>

<span class="hljs-comment">#!/usr/bin/env node</span>

<span class="hljs-keyword">const</span> max = +process.argv[<span class="hljs-number">2</span>]

<span class="hljs-keyword">let</span> FizzBuzz = {
  <a href="">Symbol.iterator</a> {
    <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> {
      next() {
        <span class="hljs-keyword">if</span> (num &gt; max) {
          <span class="hljs-keyword">return</span> {
            done : <span class="hljs-keyword">true</span>
          }
        }
        <span class="hljs-keyword">let</span> value = num
        <span class="hljs-keyword">if</span> (value % <span class="hljs-number">15</span> === <span class="hljs-number">0</span>) {
          value = <span class="hljs-string">&#39;FizzBuzz&#39;</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>) {
          value = <span class="hljs-string">&#39;Fizz&#39;</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>) {
          value = <span class="hljs-string">&#39;Buzz&#39;</span>
        }
        num++
        <span class="hljs-keyword">return</span> {
          done  : <span class="hljs-keyword">false</span>
        , value : value
        }
      }
    }
  }
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n of FizzBuzz) {
  console.log(n)
}

<span class="hljs-comment">////</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fizzbuzz</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">let</span>
    i      = <span class="hljs-number">1</span>
  , result = []

  ;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#39;&#39;</span>
    str += fizz(i)
    str += buzz(i)
    result.push(ifFalsy(str, i))
    <span class="hljs-keyword">if</span> (isLt100(i++)) {
      loop()
    }
  })()
  <span class="hljs-keyword">print</span>(result.join(<span class="hljs-string">&#39;, &#39;</span>))
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fizz</span><span class="hljs-params">(num)</span> </span>{
  <span class="hljs-keyword">return</span> isDivBy3(num) ? <span class="hljs-string">&#39;fizz&#39;</span> : <span class="hljs-string">&#39;&#39;</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buzz</span><span class="hljs-params">(num)</span> </span>{
  <span class="hljs-keyword">return</span> isDivBy5(num) ? <span class="hljs-string">&#39;buzz&#39;</span> : <span class="hljs-string">&#39;&#39;</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDivBy3</span><span class="hljs-params">(num)</span> </span>{
  <span class="hljs-keyword">return</span> num % <span class="hljs-number">3</span> === <span class="hljs-number">0</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isDivBy5</span><span class="hljs-params">(num)</span> </span>{
  <span class="hljs-keyword">return</span> num % <span class="hljs-number">5</span> === <span class="hljs-number">0</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isLt100</span><span class="hljs-params">(num)</span> </span>{
  <span class="hljs-keyword">return</span> num &lt; <span class="hljs-number">100</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ifFalsy</span><span class="hljs-params">(value, fallback)</span> </span>{
  <span class="hljs-keyword">return</span> !value ? fallback : value
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span><span class="hljs-params">(str)</span> </span>{
  console.log(str)
}

fizzbuzz()

<span class="hljs-comment">////</span>

<span class="hljs-keyword">const</span> NumbersFromOne = {
  </em>[Symbol.iterator] () {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;; ++i) {
      <span class="hljs-keyword">yield</span> i
    }
  }
}

<span class="hljs-keyword">const</span> take = <span class="hljs-function"><span class="hljs-keyword">function</span><em> <span class="hljs-params">(numberToTake, iterable)</span> </span>{
  <span class="hljs-keyword">let</span> remaining = numberToTake

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value of iterable) {
    <span class="hljs-keyword">if</span> (remaining-- &lt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">break</span>
    }
    <span class="hljs-keyword">yield</span> value
  }
}

<span class="hljs-keyword">const</span> replaceEvery = <span class="hljs-function"><span class="hljs-keyword">function</span></em> <span class="hljs-params">(period, replacement, iterable)</span> </span>{
  <span class="hljs-keyword">let</span> count = period

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value of iterable) {
    <span class="hljs-keyword">if</span> (--count === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">yield</span> replacement
      count = period
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">yield</span> value
  }
}

<span class="hljs-keyword">const</span>
  oneTo100 = take(<span class="hljs-number">100</span>, NumbersFromOne)
, fizz     = replaceEvery(<span class="hljs-number">3</span>, <span class="hljs-string">&#39;fizz&#39;</span>, oneTo100)
, buzz     = replaceEvery(<span class="hljs-number">5</span>, <span class="hljs-string">&#39;buzz&#39;</span>, fizz)
, fizzbuzz = replaceEvery(<span class="hljs-number">15</span>, <span class="hljs-string">&#39;fizzbuzz&#39;</span>, buzz)

console.log(...fizzbuzz)

<span class="hljs-comment">////</span>

<span class="hljs-comment">// with tests</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fizzbuzz</span><span class="hljs-params">(value)</span> </span>{
  <span class="hljs-keyword">if</span> (value % <span class="hljs-number">15</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;fizzbuzz&#39;</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;fizz&#39;</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;buzz&#39;</span>
  }

  <span class="hljs-keyword">return</span> value
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assertEquals</span><span class="hljs-params">(expected, actual)</span> </span>{
  <span class="hljs-keyword">if</span> (expected !== actual) {
    console.error(<span class="hljs-string">&#39;Expected &#39;</span> + actual + <span class="hljs-string">&#39; to equal &#39;</span> + expected)
  }
}

;[<span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">45</span>, <span class="hljs-number">60</span>].<span class="hljs-keyword">forEach</span>(value =&gt; {
  assertEquals(<span class="hljs-string">&#39;fizzbuzz&#39;</span>, fizzbuzz(value))
})

;[<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">24</span>, <span class="hljs-number">27</span>, <span class="hljs-number">33</span>].<span class="hljs-keyword">forEach</span>(value =&gt; {
  assertEquals(<span class="hljs-string">&#39;fizz&#39;</span>, fizzbuzz(value))
})

;[<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">35</span>, <span class="hljs-number">40</span>].<span class="hljs-keyword">forEach</span>(value =&gt; {
  assertEquals(<span class="hljs-string">&#39;buzz&#39;</span>, fizzbuzz(value))
})

;[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>].<span class="hljs-keyword">forEach</span>(value =&gt; {
  assertEquals(value, fizzbuzz(value))
})

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++) {
  console.log(fizzbuzz(i))
}

<span class="hljs-comment">////</span>

<span class="hljs-comment">// this one is CLOSE but not quite there!</span>
<em>=$=+!![];$__=((</em>$={})+<span class="hljs-string">&#39;&#39;</span>)[<em>+$+</em>+$+<em>];__$=((![])+<span class="hljs-string">&#39;&#39;</span>)[$];</em>$<em>=((</em>$={})+<span class="hljs-string">&#39;&#39;</span>)
[<em>+$+</em>+$+<em>+$];<strong>__=[][$</strong>+((</em>$={})+<span class="hljs-string">&#39;&#39;</span>)[$]+(($)/(![])+<span class="hljs-string">&#39;&#39;</span>)[$]+$<strong>+</strong>$+<em>$</em>];$<strong>$=(!![]+<span class="hljs-string">&quot;&quot;</span>)
[$+$+$]+([][(![]+<span class="hljs-string">&quot;&quot;</span>)[$+$+$]+(+[]+{})[$+$]+(!![]+<span class="hljs-string">&quot;&quot;</span>)[$]+(!![]+<span class="hljs-string">&quot;&quot;</span>)[+[]]]+<span class="hljs-string">&quot;&quot;</span>)[($+$)+<span class="hljs-string">&quot;&quot;</span>+
($+$+$)]+(![]+<span class="hljs-string">&quot;&quot;</span>)[$]+(![]+<span class="hljs-string">&quot;&quot;</span>)[$+$];$<em>$</em>=__</strong>()[$-$]<a href="span class=&quot;hljs-string&quot;&gt;&quot;\&quot;\\&quot;&lt;/span&gt;+($">$__$</a>+($+$+$+$+$+$+$)+
($+$)+<span class="hljs-string">&quot;\&quot;&quot;</span>);<em>$=(![]+<span class="hljs-string">&#39;&#39;</span>)[$-$]+([][[]]+[])[$+$+$+$+$]+$</em>$<em>+$</em>$<em>;$</em>=(<em>+{})[$+$+$]+(!![]+<span class="hljs-string">&#39;&#39;</span>)
[</em>+$]+$<em>$</em>+$<em>$</em>;<em>--,$$=$+$;<strong>__()[$-$][$</strong>$]((![]+<span class="hljs-string">&quot;&quot;</span>)[+[]]+(+[]+{})[$+$]+(!![]+<span class="hljs-string">&quot;&quot;</span>)[$]+
<span class="hljs-string">&quot;(;++</em>;)$$$=!(<em>%(&quot;</span>+($$+$$+$)+<span class="hljs-string">&quot;)),<strong>__()[+[]][</strong>$+((![])+&#39;&#39;)[&quot;</span>+($+$)+<span class="hljs-string">&quot;]+((!![])+&#39;&#39;)[&quot;</span>+
($+$+$)+<span class="hljs-string">&quot;]+((!![])+&#39;&#39;)[+!![]]+</em>$<em>](!(</em>%(&quot;</span>+($$+$)+<span class="hljs-string">&quot;))?$$$?<em>$+$</em>:<em>$:$$$?$</em>:_);&quot;</span>);</code></pre><h2 id="and-finally-in-html-and-css">and finally, in html and css</h2>
<pre class="hljs"><code><span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span> <span class="hljs-attribute">lang</span>=<span class="hljs-value">&quot;en&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>fizzbuzz<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">style</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">&quot;text/css&quot;</span>&gt;</span><span class="css">
      <span class="hljs-tag">ul</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">list-style-type</span>:<span class="hljs-value"> none</span></span>; }</span>
      <span class="hljs-tag">li</span><span class="hljs-pseudo">:nth-child(3n)</span>, <span class="hljs-tag">li</span><span class="hljs-pseudo">:nth-child(5n)</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">0px</span></span></span>; }</span>
      <span class="hljs-tag">li</span><span class="hljs-pseudo">:nth-child(3n)</span><span class="hljs-pseudo">:before</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">16px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">content</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Fizz&quot;</span></span></span>; }</span>
      <span class="hljs-tag">li</span><span class="hljs-pseudo">:nth-child(5n)</span><span class="hljs-pseudo">:after</span> <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">font-size</span>:<span class="hljs-value"> <span class="hljs-number">16px</span></span></span>; <span class="hljs-rule"><span class="hljs-attribute">content</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Buzz&quot;</span></span></span>; }</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-title">style</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>12<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>13<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>14<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>15<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>16<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>19<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>21<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>22<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>23<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>24<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>25<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>26<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>27<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>28<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>29<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>31<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>32<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>33<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>34<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>35<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>36<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>37<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>38<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>39<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>40<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>41<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>42<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>43<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>44<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>45<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>46<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>47<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>48<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>49<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>50<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>51<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>52<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>53<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>54<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>55<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>56<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>57<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>58<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>59<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>60<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>61<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>62<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>63<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>64<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>65<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>66<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>67<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>68<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>69<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>70<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>71<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>72<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>73<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>74<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>75<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>76<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>77<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>78<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>79<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>80<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>81<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>82<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>83<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>84<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>85<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>86<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>87<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>88<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>89<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>91<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>92<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>93<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>94<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>95<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>96<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>97<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>98<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">li</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-title">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>]]></description><link>/2016/fizzbuzz.html</link><guid isPermaLink="true">/2016/fizzbuzz.html</guid><category><![CDATA[js]]></category><category><![CDATA[fizzbuzz]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 07 May 2016 17:38:00 GMT</pubDate></item><item><title><![CDATA[bootcamp analogies]]></title><description><![CDATA[<p>bootcamps are like a three-month crash-course on building features and creating value
for yourself and your future employer very quickly. and also on learning. as in,
learning to learn stuff on your own.</p>
<p>mentoring at a bootcamp is kind of a three-month course on talking/people skills.
most obviously, there&#39;s the explaining code you&#39;ve never seen before to people who have
no idea what you&#39;re saying and might not even speak the same language (natively).</p>
<p>working at a bootcamp is like being thrown headfirst into both education and jr dev
roles, which can be overwhelming but also awesome.</p>
<p>hanging out at a bootcamp after finishing is like going back to a high school reunion
after going from nerd to hugely successful nerd, waving it in everyone&#39;s face, except
everyone is that same nerd so it&#39;s kinda more like an encouraging wave than a &quot;see,
told you i&#39;d amount to something&quot; kind of wave.</p>
<p>just some thoughts i had while trying to avoid having my skin ripped off by the
pressure-washer-like shower that i just took. i need to be better at plumbing.</p>
]]></description><link>/2016/bootcamp-analogies.html</link><guid isPermaLink="true">/2016/bootcamp-analogies.html</guid><category><![CDATA[devmtn]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 07 May 2016 16:20:00 GMT</pubDate></item><item><title><![CDATA[currying and partial application]]></title><description><![CDATA[<pre class="hljs"><code><span class="hljs-comment">// Prototype&#39;s version?</span>
<span class="hljs-built_in">Function</span>.prototype.curry = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> fn   = <span class="hljs-keyword">this</span>
    , args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args.concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)))
  }
}

<span class="hljs-comment">// Functional&#39;s version?</span>
<span class="hljs-built_in">Function</span>.prototype.partial = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> fn   = <span class="hljs-keyword">this</span>
    , args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> arg = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length &amp;&amp; arg &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
      <span class="hljs-keyword">if</span> (args[i] === <span class="hljs-literal">undefined</span>) {
        args [i] = <span class="hljs-built_in">arguments</span>[arg++]
      }
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args)
    }
  }
}

<span class="hljs-comment">// from angus croll&#39;s blog</span>
<span class="hljs-comment">// note, the toArray is because the <code>arguments</code> array is actually and object</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">enumm</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(enumm)
}
<span class="hljs-comment">// toArray is superfluous now, though, because we can just do</span>
<span class="hljs-keyword">let</span> args = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>)
<span class="hljs-comment">//</span>
<span class="hljs-built_in">Function</span>.prototype.curry = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>
  }
  <span class="hljs-keyword">var</span> <strong> method = <span class="hljs-keyword">this</span>
    , args      = toArray(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> </strong>method.apply(<span class="hljs-keyword">this</span>, args.concat(toArray(<span class="hljs-built_in">arguments</span>)))
  }
}
<span class="hljs-comment">// and an example from his blog, using the above</span>
<span class="hljs-keyword">const</span>
  converter = (ratio, symbol, input) =&gt; [(input <em> ratio).toFixed(<span class="hljs-number">1</span>), symbol].join(<span class="hljs-string">&#39; &#39;</span>)
, kgToLb    = converter.curry(<span class="hljs-number">2.2</span>, <span class="hljs-string">&#39;lbs&#39;</span>)
, liToPi    = converter.curry(<span class="hljs-number">1.98</span>, <span class="hljs-string">&#39;pints&#39;</span>)
, miToKm    = converter.curry(<span class="hljs-number">1.62</span>, <span class="hljs-string">&#39;km&#39;</span>)


<span class="hljs-comment">// note that these are all examples of partial application,</span>
<span class="hljs-comment">// not true currying as one would have in a purely functional language</span>
<span class="hljs-comment">// see:</span>
<span class="hljs-keyword">const</span> foo = (a, b) =&gt; a + b
foo.partiallyApply(<span class="hljs-number">2</span>) <span class="hljs-comment">// b =&gt; 2 + b</span>
foo.curry() <span class="hljs-comment">// a =&gt; b =&gt; a + b</span>
foo.curry()(<span class="hljs-number">2</span>) <span class="hljs-comment">// foo.partiallyApply(2)</span>

<span class="hljs-built_in">Function</span>.prototype.curry = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span>
    method = <span class="hljs-keyword">this</span>
  , i      = <span class="hljs-number">0</span>
  , len    = <span class="hljs-keyword">this</span>.length
  , args   = []

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>{
    args.push(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">if</span> (++i &lt; len) {
      <span class="hljs-keyword">return</span> f
    } <span class="hljs-keyword">else</span> {
      method.apply(<span class="hljs-keyword">this</span>, args)
    }
  }
  <span class="hljs-keyword">return</span> f
}

<span class="hljs-comment">// here&#39;s a super simplistic adding thingy</span>
<span class="hljs-keyword">const</span> adder = (a, b) =&gt; <span class="hljs-keyword">typeof</span>(b) !== <span class="hljs-string">&#39;undefined&#39;</span> ? a + b : c =&gt; a + c
<span class="hljs-comment">// i think the es6 is right for this? in es5 also:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adder</span>(<span class="hljs-params">a, b</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b !== <span class="hljs-string">&#39;undefined&#39;</span>) {
    <span class="hljs-keyword">return</span> a + b
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>)</span>{
      <span class="hljs-keyword">return</span> a + c
    }
  }
}

<span class="hljs-comment">// the real difference between partial application and currying:</span>
<span class="hljs-comment">// a curried function will accept ONLY one argument at a time.</span>
<span class="hljs-comment">// it will continue accepting one argument each time it&#39;s called right</span>
<span class="hljs-comment">// up until it&#39;s got enough, then will finally be executed for realz.</span>

<span class="hljs-comment">// so: a function that can take a function as input, and an int for</span>
<span class="hljs-comment">// the max args. should be able to call like so:</span>
curry(fn, n, ...args) <span class="hljs-comment">// ... that is,</span>
curry(fn, n, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// or</span>
curry(fn, n)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>) <span class="hljs-comment">// or</span>
curry(fn, n)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// and we should get the same results each way.</span>
<span class="hljs-comment">// so</span>
curry(fn, n, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) == curry(fn, n, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)

<span class="hljs-comment">// notes on the below:</span>
<span class="hljs-comment">// fn.apply(a, [1, 2, 3]) is kinda the same as doing</span>
<span class="hljs-comment">// fn.call(a, 1, 2, 3), where <code>a</code> is <code>this</code></span>
<span class="hljs-keyword">const</span> argsArr = args =&gt; <span class="hljs-built_in">Array</span>.from(args)

<span class="hljs-keyword">const</span> curry = (fn, n) =&gt; {
  <span class="hljs-keyword">const</span> args = argsArr(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">if</span> (n === args.length -<span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">undefined</span>, args.slice(<span class="hljs-number">2</span>))
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> () =&gt; {
      <span class="hljs-keyword">return</span> curry.apply(<span class="hljs-literal">undefined</span>, args.concat(<span class="hljs-built_in">arguments</span>))
    }
  }
}
<span class="hljs-comment">// so try:</span>
<span class="hljs-keyword">const</span> addFour = (a, b, c, d) =&gt; a + b + c + d
curry(addFour, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>)(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)

<span class="hljs-comment">// modified to use Function.length</span>
<span class="hljs-keyword">const</span> newCurry = (fn, n) =&gt; {
  <span class="hljs-keyword">let</span> args = argsArr(<span class="hljs-built_in">arguments</span>)
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(n) == <span class="hljs-string">&#39;undefined&#39;</span>) {
    args[<span class="hljs-number">1</span>] = fn.length
  }
  <span class="hljs-keyword">if</span> (n === args.length - <span class="hljs-number">2</span>) {
    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-literal">undefined</span>, args.slice(<span class="hljs-number">2</span>))
  }
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> newCurry.apply(<span class="hljs-literal">undefined</span>, args.concat(argsArr(<span class="hljs-built_in">arguments</span>)))
  }
}


<span class="hljs-comment">// okay, so, from some other blog</span>
<span class="hljs-keyword">const</span> objs = [{id : <span class="hljs-number">1</span>}, {id : <span class="hljs-number">2</span>}, {id : <span class="hljs-number">3</span>}, {id : <span class="hljs-number">4</span>}]
objs.map(o =&gt; o.id)
<span class="hljs-comment">// this is actualy a lot cleaner than his example, because he&#39;s doing it like</span>
<span class="hljs-keyword">var</span> objs = [{id : <span class="hljs-number">1</span>}, {id : <span class="hljs-number">2</span>}, {id : <span class="hljs-number">3</span>}, {id : <span class="hljs-number">4</span>}]
objs.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>)</span>{<span class="hljs-keyword">return</span> o.id})
<span class="hljs-comment">// but we&#39;ll see where this goes, anyway</span>
<span class="hljs-keyword">const</span> curry = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;curry&#39;</span>) <span class="hljs-comment">// npm i -S curry</span>
<span class="hljs-keyword">const</span> get = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">property, object</span>)</span>{<span class="hljs-keyword">return</span> object[property]})
objs.map(get(<span class="hljs-string">&#39;id&#39;</span>))
<span class="hljs-comment">// meh.</span>
<span class="hljs-keyword">const</span> getIDs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">objects</span>)</span>{
  <span class="hljs-keyword">return</span> objects.map(get(<span class="hljs-string">&#39;id&#39;</span>))
}
getIDs(objs)
<span class="hljs-comment">// double meh.</span>
<span class="hljs-keyword">const</span> map    = curry((fn, val) =&gt; val.map(fn))
    , getIDs = map(get(<span class="hljs-string">&#39;id&#39;</span>))

<span class="hljs-comment">// still not sure this is actually cleaner xD</span>
<span class="hljs-comment">// let&#39;s keep going with his examples (translated to ES2015, though)</span>
<span class="hljs-comment">// some sample data (we&#39;ll pretend this is JSON we&#39;re getting from somewhere):</span>
<span class="hljs-keyword">const</span> sampleData = {
  <span class="hljs-string">&quot;user&quot;</span>  : <span class="hljs-string">&quot;z&quot;</span>
  , <span class="hljs-string">&quot;posts&quot;</span> : [
    {<span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;title!&quot;</span>     , <span class="hljs-string">&quot;contents&quot;</span> : <span class="hljs-string">&quot;asdf&quot;</span>  }
  , {<span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;something!&quot;</span> , <span class="hljs-string">&quot;contents&quot;</span> : <span class="hljs-string">&quot;ghjkl;&quot;</span>}
  ]
}
<span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>).get(<span class="hljs-string">&#39;something.whatever/that/data.json&#39;</span>)
.then(<span class="hljs-built_in">JSON</span>.parse)
.then(data =&gt; data.posts)
.then(posts =&gt; posts.map(post =&gt; post.title))
<span class="hljs-comment">// or, using the curry stuff</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>).get(<span class="hljs-string">&#39;something.whatever/that/data.json&#39;</span>)
.then(<span class="hljs-built_in">JSON</span>.parse)
.then(get(<span class="hljs-string">&#39;posts&#39;</span>))
.then(map(get(<span class="hljs-string">&#39;title&#39;</span>)))
<span class="hljs-comment">// uh</span>
<span class="hljs-comment">// okay</span>
<span class="hljs-comment">// i don&#39;t see that this is any better, here.</span>
<span class="hljs-comment">// oh wait, he wrote a follow-up!</span>

<span class="hljs-comment">// shit. i think some of this might be wrong.</span>
<span class="hljs-comment">// there&#39;s no <code>arguments</code>! i knew about <code>this</code>, but not <code>arguments</code>.</span>
<span class="hljs-comment">// (talking about when using <code>=&amp;gt;</code>, i mean.)</span>
<span class="hljs-comment">// not really a big deal, just in the above, we need to use <code>...args</code> instead.</span>
<span class="hljs-comment">// for example,</span>
<span class="hljs-keyword">let</span> sum = (...nums) =&gt; nums.reduce((a, b) =&gt; a + b)



<span class="hljs-comment">// examples:</span>
<span class="hljs-comment">// in es5:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatter</span>(<span class="hljs-params">tag, text</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;&lt;&#39;</span> + tag + <span class="hljs-string">&#39;&gt;&#39;</span> + text + <span class="hljs-string">&#39;&lt;/&#39;</span> + tag + <span class="hljs-string">&#39;&gt;&#39;</span>
}
<span class="hljs-keyword">var</span> p = formatter.bind(<span class="hljs-literal">undefined</span>, <span class="hljs-string">&#39;p&#39;</span>)
p(<span class="hljs-string">&#39;some content!&#39;</span>)
<span class="hljs-comment">// in es6:</span>
<span class="hljs-keyword">const</span> formatter = (tag, text) =&gt; <span class="hljs-string"><code>&amp;lt;&lt;span class=&quot;hljs-subst&quot;&gt;${tag}&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-subst&quot;&gt;${text}&lt;/span&gt;&amp;lt;/&lt;span class=&quot;hljs-subst&quot;&gt;${tag}&lt;/span&gt;&amp;gt;</code></span>
<span class="hljs-keyword">const</span> p = text =&gt; formatter(<span class="hljs-string">&#39;p&#39;</span>, text)
<span class="hljs-comment">// accepting addtional arguments (more text):</span>
<span class="hljs-keyword">const</span> fmt = (tag, text, moar) =&gt; <span class="hljs-string"><code>&amp;lt;&lt;span class=&quot;hljs-subst&quot;&gt;${tag}&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-subst&quot;&gt;${text}&lt;/span&gt;&lt;span class=&quot;hljs-subst&quot;&gt;${moar}&lt;/span&gt;&amp;lt;/&lt;span class=&quot;hljs-subst&quot;&gt;${tag}&lt;/span&gt;&amp;gt;</code></span>
<span class="hljs-keyword">const</span> span = ...args =&gt; fmt(<span class="hljs-string">&#39;span&#39;</span>, ...args)

<span class="hljs-comment">// okay, that&#39;s cute because it just lets you specify however many you want, but...</span>
<span class="hljs-keyword">const</span> cur = (fn, ...argsOne) =&gt; (...argsTwo) =&gt; fn(...argsOne, ...argsTwo)
<span class="hljs-comment">// or, allowing placeholders, as in underscore:</span>
<span class="hljs-keyword">const</span> curMore = (fn, ...argsOne) =&gt; {
  <span class="hljs-keyword">let</span> i = argsOne.indexOf(<em>)
  <span class="hljs-keyword">let</span> argsOne = (i === -<span class="hljs-number">1</span>) ? [] : argsOne.splice(i).slice(<span class="hljs-number">1</span>)
  <span class="hljs-keyword">return</span> (...argsTwo) =&gt; fn(...argsOne, ...argsTwo, ...argsThree)
}
<span class="hljs-comment">// which can then be used like:</span>
<span class="hljs-keyword">const</span> lessTen = curMore(subtract, </em>, <span class="hljs-number">10</span>) <span class="hljs-comment">// assuming we&#39;ve defined a <code>subtract</code> somewhere</span>



<span class="hljs-comment">// from brian lonsdorf&#39;s blog/medium, a better <code>curry</code> (better in that</span>
<span class="hljs-comment">// it should be easier to debug).</span>
<span class="hljs-comment">// <span class="hljs-doctag">note:</span> very definitely es5. and redifines toString().</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fx</span>)</span>{
  <span class="hljs-keyword">var</span> arity = fx.length
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> (args.length &gt;= arity) {
      <span class="hljs-keyword">return</span> fx.apply(<span class="hljs-literal">null</span>, args)
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> f1.apply(<span class="hljs-literal">null</span>, args.concat(<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>)))
    }
    f2.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> fToString(fx) + <span class="hljs-string">&#39;(&#39;</span> + args.join(<span class="hljs-string">&#39;, &#39;</span>) + <span class="hljs-string">&#39;)&#39;</span>
    }
    <span class="hljs-keyword">return</span> f2
  }
  f1.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> fToString(fx)
  }
  <span class="hljs-keyword">return</span> f1
}
<span class="hljs-comment">// and a compose from the same:</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> fns = <span class="hljs-built_in">arguments</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">result</span>)</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = fns.length - <span class="hljs-number">1</span>; i &gt; -<span class="hljs-number">1</span>; i--) {
      <span class="hljs-keyword">try</span> {
        result = fns[i].call(<span class="hljs-keyword">this</span>, result)
      } <span class="hljs-keyword">catch</span>(e) {
        e.message = f.toString() + <span class="hljs-string">&#39; failed at &#39;</span> fns[i].toString()
        <span class="hljs-keyword">throw</span>(e)
      }
    }
    f.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;compose(&#39;</span>+[].slice.call(fns).map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">f</span>)</span>{ <span class="hljs-keyword">return</span> f.toString() }).join(<span class="hljs-string">&#39;, &#39;</span>)+<span class="hljs-string">&#39;)&#39;</span>;
    }
    <span class="hljs-keyword">return</span> result
  }
  <span class="hljs-keyword">return</span> f
}



<span class="hljs-comment">// from reginald braithwaite&#39;s blog</span>
<span class="hljs-comment">// </em> arity: number of arguments a function accepts</span>
<span class="hljs-comment">//   <em> nullary function takes no arguments</span>
<span class="hljs-comment">//   </em> unary function accepts one</span>
<span class="hljs-comment">//   <em> polyadic function accepts more than one</span>
<span class="hljs-comment">//   </em> binary accepts two</span>
<span class="hljs-comment">//   <em> ternary function accepts three</span>
<span class="hljs-comment">//   </em> variadic function accepts a variable number of arguments</span>

<span class="hljs-comment">// a map fn</span>
<span class="hljs-keyword">const</span> <strong> map = [].map
<span class="hljs-keyword">const</span> square = n =&gt; n * n
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span>(<span class="hljs-params">list, unary</span>)</span>{
  <span class="hljs-keyword">return</span> </strong>map.call(list, unaryFn)
}
map([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], square)

<span class="hljs-comment">// this is fine as long as map gets both arguments (is fully applied)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapWrap</span>(<span class="hljs-params">unaryFn</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">list</span>)</span>{
    <span class="hljs-keyword">return</span> map(list, unaryFn)
  }
}
mapWrap(square)([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])

<span class="hljs-keyword">const</span> squareAll = mapWrap(square)
squareAll([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])

<span class="hljs-comment">// woot! that&#39;s fine, but annoying to write. so, a function to wrap functions:</span>
<span class="hljs-comment">// const wrapper = unaryFn =&gt; list =&gt; map(list, unaryFn) // can become:</span>
<span class="hljs-comment">// const wrapper = second =&gt; first =&gt; binaryFn(first, second) // can become:</span>
<span class="hljs-keyword">const</span> rightCurry = binaryFn =&gt; secondArgument =&gt; firstArgument =&gt; binaryFn(firstArgument, secondArgument)
<span class="hljs-comment">// which can be used like</span>
<span class="hljs-keyword">const</span> rightCurryMap = rightCurry(map)
<span class="hljs-keyword">const</span> squareAll     = rightCurryMap(square)
squareAll([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])
<span class="hljs-comment">// calling this rightCurry because it takes any binary function and curries into a chain</span>
<span class="hljs-comment">// of unary functions, starting with the second argument. a curry that starts on the left</span>
<span class="hljs-comment">// is more common, and it&#39;s usually what people mean.</span>
<span class="hljs-keyword">const</span> curry = binaryFn =&gt; firstArg =&gt; secondArg =&gt; binaryFn(firstArg, secondArg)
<span class="hljs-keyword">const</span> cMap  = curry(map)
<span class="hljs-keyword">const</span> twice         = n =&gt; n + n <span class="hljs-comment">// why did i write this down?</span>
<span class="hljs-comment">// whether one goes with a leftmost or rightmost curry could depend on which things</span>
<span class="hljs-comment">// you might need to name and/or reuse</span>

<span class="hljs-comment">// okay so apparently a pattern like this:</span>
<span class="hljs-keyword">const</span> squareAll = rightCurry(map)(square)
<span class="hljs-keyword">const</span> doubleAll = rightCurry(map)(twice)
<span class="hljs-comment">// is called a:</span>
<span class="hljs-comment">// rightmost unary partial application of the map function</span>
<span class="hljs-comment">// which means it starts from the right, takes one arg, applies not all of the args, and works on the map fn</span>

<span class="hljs-comment">// the wrong way to build a first-class function to do this would be:</span>
<span class="hljs-keyword">const</span> rightUnPartApp = (binaryFn, secondArg) =&gt; rightCurr(binaryFn)(secondArg)
<span class="hljs-comment">// and a better way might be</span>
<span class="hljs-keyword">const</span> lastApplication = (binaryFn, secondArg) =&gt; firstArg =&gt; binaryFn(firstArg, secondArg)
<span class="hljs-comment">// which means we could do</span>
<span class="hljs-keyword">const</span> squareAll = lastApplication(map, square)
<span class="hljs-keyword">const</span> doubleAll = lastApplication(map, twice)
<span class="hljs-comment">// and so, we could do</span>
<span class="hljs-keyword">const</span> firstApp = (binaryFn, firstArg) =&gt; secondArg =&gt; binaryFn(firstArg, secondArg)

<span class="hljs-comment">// SO. wat.</span>
<span class="hljs-comment">// Currying : decomposition of a polyadic function into a chain of nested unary functions. Thus,</span>
<span class="hljs-comment">// decomposed, you can partially apply one or more arguments, although the curry operation itself</span>
<span class="hljs-comment">// does not apply any arguments to the function.</span>
<span class="hljs-comment">// Partial application : conversion of a polyadic function into a function taking fewer arguments</span>
<span class="hljs-comment">// by providing one or more arguments in advance.</span>




<span class="hljs-comment">// this is approximately the same as wu.js&#39;s .autoCurry() (which has been removed??)</span>
<span class="hljs-comment">// (es5, obvs. <span class="hljs-doctag">todo:</span> simplify, basically just by making it es6.)</span>
<span class="hljs-keyword">var</span> autoCurry = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{

  <span class="hljs-keyword">var</span>
    toArray = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toArray</span>(<span class="hljs-params">arr, from</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(arr, from || <span class="hljs-number">0</span>)
  }

, curry = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>{
    <span class="hljs-keyword">var</span> args = toArray(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curried</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, args.concat(toArray(<span class="hljs-built_in">arguments</span>)))
    }
  }

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">autoCurry</span>(<span class="hljs-params">fn, numArgs</span>)</span>{
    numArgs = numArgs || fn.length
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">autoCurried</span>(<span class="hljs-params"></span>)</span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; numArgs) {
        <span class="hljs-keyword">return</span> numArgs - <span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span> ?
        autoCurry(curry.apply(<span class="hljs-keyword">this</span>, [fn].concat(toArray(<span class="hljs-built_in">arguments</span>)))
      , numArgs - <span class="hljs-built_in">arguments</span>.length)           :
        curry.apply(<span class="hljs-keyword">this</span>, [fn].concat(toArray(<span class="hljs-built_in">arguments</span>)))
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>)
      }
    }
  }

}())</code></pre>]]></description><link>/2016/currying-and-partial-application.html</link><guid isPermaLink="true">/2016/currying-and-partial-application.html</guid><category><![CDATA[currying]]></category><category><![CDATA[fp]]></category><category><![CDATA[partial-application]]></category><category><![CDATA[functional-programming]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 21:00:00 GMT</pubDate></item><item><title><![CDATA[ideas for a better jsx]]></title><description><![CDATA[<p>please note: these aren&#39;t all my ideas, some are from <a href="http://ryanwalsh.io">ryan walsh</a></p>
<p>also, all of this was from back when both myself and ryan were just starting to learn react</p>
<p>i don&#39;t dislike jsx, i got over that</p>
<p>pretty sure ryan did, too</p>
<pre class="hljs"><code><span class="hljs-comment">// JSX</span>
export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileInfo</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {</span>
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div className=<span class="hljs-string">&quot;profile-info-container&quot;</span>&gt;

        &lt;div className=<span class="hljs-string">&quot;profile-image-wrapper&quot;</span>&gt;
          &lt;img className=<span class="hljs-string">&quot;profile-image&quot;</span> src=<span class="hljs-string">&quot;<a href="https://avatars1.githubusercontent.com/u/12636781?v=3&amp;s=460">https://avatars1.githubusercontent.com/u/12636781?v=3&amp;s=460</a>&quot;</span> /&gt;
        &lt;/div&gt;

        &lt;div className=<span class="hljs-string">&quot;name-info-container&quot;</span>&gt;
          &lt;h2 className=<span class="hljs-string">&quot;display-name&quot;</span>&gt;<span class="hljs-type">Ryan</span> <span class="hljs-type">Walsh</span>&lt;/h2&gt;
          &lt;h3 className=<span class="hljs-string">&quot;username&quot;</span>&gt;r-walsh&lt;/h3&gt;
        &lt;/div&gt;

        &lt;table className=<span class="hljs-string">&quot;profile-guide-info&quot;</span>&gt;
          &lt;tr className=<span class="hljs-string">&quot;number-container&quot;</span>&gt;
            &lt;th className=<span class="hljs-string">&quot;guide-info-number&quot;</span>&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-authored&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;<span class="hljs-number">12</span>&lt;/a&gt;&lt;/span&gt;
            &lt;/th&gt;
            &lt;th className=<span class="hljs-string">&quot;guide-info-number&quot;</span>&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-favorites&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;<span class="hljs-number">20</span>&lt;/a&gt;&lt;/span&gt;
            &lt;/th&gt;
            &lt;th className=<span class="hljs-string">&quot;guide-info-number&quot;</span>&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-followers&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;<span class="hljs-number">47</span>&lt;/a&gt;&lt;/span&gt;
            &lt;/th&gt;
          &lt;/tr&gt;

          &lt;tr&gt;
            &lt;td&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-authored&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;&lt;i className=<span class="hljs-string">&quot;fa fa-pencil&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;&lt;/span&gt;
            &lt;/td&gt;
            &lt;td&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-favorites&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;&lt;i className=<span class="hljs-string">&quot;fa fa-heart&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;&lt;/span&gt;
            &lt;/td&gt;
            &lt;td&gt;
              &lt;span className=<span class="hljs-string">&quot;profile-followers&quot;</span>&gt;&lt;a href=<span class="hljs-string">&quot;/profile&quot;</span>&gt;&lt;i className=<span class="hljs-string">&quot;fa fa-eye&quot;</span>&gt;&lt;/i&gt;&lt;/a&gt;&lt;/span&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;

      &lt;/div&gt;
    )
  }
}

<span class="hljs-comment">// Other nonsense</span>
export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileInfo</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {</span>
  render() {
    <span class="hljs-keyword">return</span> (
      div( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-guide-info-container&#39;] } ) {

        div( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-string">&quot;profile-image-wrapper&quot;</span>] } ) {
          img( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-image&#39;], src: <span class="hljs-symbol">&#39;https</span>:<span class="hljs-comment">//avatars1.githubusercontent.com/u/12636781?v=3&amp;s=460&#39; } ) {}</span>
        }

        div( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> <span class="hljs-symbol">&#39;name</span>-info-container&#39; } ) {
          h2( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> <span class="hljs-string">&quot;display-name&quot;</span> } ) { <span class="hljs-type">John</span> <span class="hljs-type">Doe</span> }
          h3( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> <span class="hljs-symbol">&#39;usernam</span>e&#39; } ) { jdoe }
        }

        table( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-guide-info&#39;] } ) {
          tr( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;number</span>-container&#39;] } ) {
            th( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;guide</span>-info-number&#39;] } ) {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } )
            }

            th( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;guide</span>-info-number&#39;] } ) {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } )
            }

            th( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;guide</span>-info-number&#39;] } ) {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } )
            }
          }

          tr() {
            td() {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } ) {}
            }

            td() {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } ) {}
            }

            td() {
              span( { <span class="hljs-class"><span class="hljs-keyword">class</span>:</span> [<span class="hljs-symbol">&#39;profile</span>-authored&#39;] } ) {}
            }
          }
        }
      }
    )
  }
}

<span class="hljs-comment">// why not like this?</span>
export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileInfo</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span>{</span>
  render() {
    <span class="hljs-keyword">return</span> ({
      div : {
        <span class="hljs-class"><span class="hljs-keyword">class</span> :</span> [<span class="hljs-symbol">&#39;fo</span>o&#39;, <span class="hljs-symbol">&#39;ba</span>r&#39;]
      , p : {
          str : <span class="hljs-symbol">&#39;Bespoke</span> scenester retro bitters <span class="hljs-type">Pitchfork</span> <span class="hljs-number">8</span>-bit mixtape <span class="hljs-type">PBR</span>&amp;<span class="hljs-type">B</span> mlkshk iphone wire-rimmed glasses forage <span class="hljs-type">Helvetica</span> put a bird on it intelligentsia semiotics leggings normcore. <span class="hljs-type">Flexitarian</span> <span class="hljs-type">Echo</span> <span class="hljs-type">Park</span> mustache carles kickstarter <span class="hljs-type">Echo</span> <span class="hljs-type">Park</span> <span class="hljs-type">Blue</span> <span class="hljs-type">Bottle</span> actually tumblr beard literally tote bag <span class="hljs-type">Pitchfork</span> cray shabby <span class="hljs-type">Portland</span> stumptown asymmetrical.&#39;
        }
      }
    , footer : {
        span : {
          str : <code>&lt;span class=&quot;hljs-type&quot;&gt;Copyright&lt;/span&gt; ${datespan} ${company}. &lt;span class=&quot;hljs-type&quot;&gt;All&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;Rights&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;Reserved&lt;/span&gt;.</code>
}}})}

<span class="hljs-comment">// or this?</span>
const n = notJSX
function notJSXparser(){
  <span class="hljs-keyword">return</span> n(<span class="hljs-symbol">&#39;bod</span>y&#39;, [
    n(<span class="hljs-symbol">&#39;h</span>1&#39;, {<span class="hljs-symbol">&#39;this</span> is a website&#39;},
      n(&#39;p&#39;, {<span class="hljs-symbol">&#39;this</span> is a lot of text! texytext, text. texting. txet.&#39;},
        n(<span class="hljs-symbol">&#39;foote</span>r&#39;, {<code>&lt;span class=&quot;hljs-type&quot;&gt;Copyright&lt;/span&gt; ${stuff}</code>})
      )
    )
  ])
}

<span class="hljs-comment">// how they do it in EVE&#39;s UI (<span class="hljs-doctag">note:</span> they use typescript and an in-house custom lib they call &#39;microReact&#39;)</span>
const page = {
  t          : <span class="hljs-symbol">&#39;spa</span>n&#39; <span class="hljs-comment">// the tag type; defauts to &#39;div&#39;</span>
, c          : <span class="hljs-symbol">&#39;col</span>-<span class="hljs-number">12</span>&#39; <span class="hljs-comment">// className</span>
, text       : <span class="hljs-symbol">&#39;some</span> content&#39;
, children   : [{
    <span class="hljs-comment">// array of further nodes</span>
  }]
, top        : <span class="hljs-number">10</span>
, width      : <span class="hljs-number">100</span> <span class="hljs-comment">// more styles can go here, like react&#39;s style object basically</span>
, click      : someHandler
, svg        : <span class="hljs-literal">true</span> <span class="hljs-comment">// to add svg properties... why? idk. just &#39;cuz, i guess.</span>
, cx         : <span class="hljs-number">4</span>
, cy         : <span class="hljs-number">4</span>
, postRender : someDomManipulationFunction <span class="hljs-comment">// on insertion and on update</span>
}

<span class="hljs-comment">// how jsx actually kinda works (reactelement anyway) under the hood:</span>
let someEl = {
  <span class="hljs-class"><span class="hljs-keyword">type</span>  :</span> <span class="hljs-symbol">&#39;di</span>v&#39;
, props : {}
, ref   : <span class="hljs-literal">null</span>
, key   : <span class="hljs-literal">null</span>
}</code></pre>]]></description><link>/2016/better-jsx.html</link><guid isPermaLink="true">/2016/better-jsx.html</guid><category><![CDATA[jsx]]></category><category><![CDATA[react]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 19:00:00 GMT</pubDate></item><item><title><![CDATA[More DevMountain Notes]]></title><description><![CDATA[<p>This is a bunch more notes from my time going through the course at DevMountain.</p>
<p>These notes are specifically from the first three weeks. They&#39;re a mess.</p>
<p>Don&#39;t take anything too seriously. I probably didn&#39;t know what I was talking about, a lot of the time.</p>
<hr>
<h2 id="css">css</h2>
<p>if a div has position absolute, position RELATIVE on another
element will be in RELATION to the div that has ABSOLUTE.</p>
<p>so, top 0 is in RELATION to something else that has ABSOLUTE,
otherwise just defaults to in relative to HTML.</p>
<p>in simpler terms... position is basically just referring to its immediate parent,
unless there&#39;s no frame of reference there. all hierarchical. (lol hence C in CSS....)</p>
<ul>
<li>box-model:<ul>
<li>border goes OUTwards from the element</li>
<li>padding goes IN and squishes the element</li>
<li>LOTS of padding will actually stretch an element out</li>
<li>margins--space between picture and other items</li>
</ul>
</li>
</ul>
<hr>
<h2 id="rly-just-beginning-js">rly just beginning js</h2>
<pre class="hljs"><code><span class="hljs-comment">// Variables</span>

<span class="hljs-comment">// JavaScript uses &quot;lexical&quot; scoping for variables, meaning it matches</span>
<span class="hljs-comment">// a variable based on its name.  &quot;Name&quot; isn&#39;t the same as &quot;name&quot;.</span>

<span class="hljs-comment">// Variables hold values (Numbers, Strings, Arrays, Objects, Functions, Boolean)</span>
<span class="hljs-keyword">var</span> myAge = <span class="hljs-number">39</span>
<span class="hljs-keyword">var</span> myName = <span class="hljs-string">&#39;Jared&#39;</span>
<span class="hljs-keyword">var</span> myKids = [<span class="hljs-string">&#39;Isaac&#39;</span>,<span class="hljs-string">&#39;Abbi&#39;</span>,<span class="hljs-string">&#39;Natalia&#39;</span>,<span class="hljs-string">&#39;Camila&#39;</span>,<span class="hljs-string">&#39;Bella&#39;</span>]

<span class="hljs-comment">// Conditional Statements (if/else)</span>

<span class="hljs-comment">// Conditional statements use comparison operators to produce a</span>
<span class="hljs-comment">// Boolean result (true/false)</span>
<span class="hljs-keyword">if</span> (myAge &lt; <span class="hljs-number">20</span>) {
  <span class="hljs-comment">// do something</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (myAge &lt; <span class="hljs-number">40</span>) {

} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// do something else</span>
}

<span class="hljs-comment">// Truthy and Falsy</span>
<span class="hljs-comment">// There are 6 values that are considered &quot;falsy&quot;</span>
<span class="hljs-comment">// &#39;&#39;,0,false,undefined,null,NaN</span>

<span class="hljs-comment">// == vs ===</span>
<span class="hljs-comment">// The double equals will convert the string to a number</span>
<span class="hljs-comment">// The triple equals will return false if the values aren&#39;t</span>
<span class="hljs-comment">// the same type</span>
<span class="hljs-keyword">if</span> (<span class="hljs-string">&#39;42&#39;</span> == <span class="hljs-number">42</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#39;42&#39; == 42&quot;</span>)
}

<span class="hljs-keyword">if</span> (<span class="hljs-string">&#39;42&#39;</span> === <span class="hljs-number">42</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;&#39;42&#39; === 42&quot;</span>)
}

<span class="hljs-comment">// Function Declaration</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DoubleANumber</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-built_in">console</span>.log(number <em> <span class="hljs-number">2</span>)
}

<span class="hljs-comment">// A function can also return a value</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DoubleANumber2</span>(<span class="hljs-params">number</span>) </span>{
  <span class="hljs-keyword">return</span> number </em> <span class="hljs-number">2</span>
}

<span class="hljs-comment">// Function Invocation</span>
DoubleANumber(<span class="hljs-number">10</span>)

<span class="hljs-comment">// If a function returns a value, we save that in a variable</span>
<span class="hljs-keyword">var</span> doubled = DoubleANumber2(<span class="hljs-number">10</span>)
<span class="hljs-built_in">console</span>.log(doubled)

<span class="hljs-comment">// Function Expression</span>

<span class="hljs-comment">// Functions themselves can be stored in a variable</span>
<span class="hljs-keyword">var</span> func = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayHello</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello&quot;</span>)
}

<span class="hljs-comment">// When a function is used in an expression, the function name</span>
<span class="hljs-comment">// isn&#39;t required.  This is called an anonymous function</span>
<span class="hljs-keyword">var</span> func1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello&quot;</span>)
}

<span class="hljs-comment">// We&#39;ll see where using anonymous functions is a common</span>
<span class="hljs-comment">// pattern in a future lesson</span>

<span class="hljs-comment">// Scope</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Jared&quot;</span>

<span class="hljs-comment">// A function can access variables declared outside the function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayMyName</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(name)
}

SayMyName()

<span class="hljs-comment">// A function argument is &quot;local&quot; to the function, and &quot;hides&quot;</span>
<span class="hljs-comment">// the outer variable with the same name</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayMyName2</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-built_in">console</span>.log(name)
}

SayMyName2(<span class="hljs-string">&quot;John&quot;</span>)

<span class="hljs-comment">// A variabled declared inside the function also &quot;hides&quot; the</span>
<span class="hljs-comment">// outer variable with the same name</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayMyName3</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Bob&quot;</span>
  <span class="hljs-built_in">console</span>.log(name)
}

SayMyName3()

<span class="hljs-comment">// But variables declared inside a function are only</span>
<span class="hljs-comment">// visible inside the function</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ShowAge</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>
  <span class="hljs-built_in">console</span>.log(age)
}

<span class="hljs-comment">//console.log(age) // This is an error because &quot;age&quot; isn&#39;t defined</span>

<span class="hljs-comment">// Functions can be &quot;nested&quot; inside of other functions.  Scope works</span>
<span class="hljs-comment">// from the inside-out.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Grandpa</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Grandpa&quot;</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dad</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Dad&quot;</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Son&quot;</span>
    }
  }
}

<span class="hljs-comment">// There are two rules to remember with functions</span>
<span class="hljs-comment">// 1. A function can access the the variables declared in outer functions</span>
<span class="hljs-comment">// 2. A function can access those variables even after the outer function</span>
<span class="hljs-comment">//    has been invoked and returned.</span>
<span class="hljs-comment">// A function that has &quot;remembered&quot; these values is called a closure.</span>

<span class="hljs-comment">// Closures</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">firstName, lastName</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SayMyName</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(firstName + <span class="hljs-string">&#39; &#39;</span> + lastName)
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;All done&#39;</span>)
  <span class="hljs-keyword">return</span> SayMyName;
}

<span class="hljs-keyword">var</span> person = Person(<span class="hljs-string">&#39;Jared&#39;</span>,<span class="hljs-string">&#39;Stark&#39;</span>)
person()

.call(scope, arg1, arg2, etc) <span class="hljs-comment">// takes ARGUMENTS, comma sep</span>
.apply(scope, [arg1, arg2, etc])<span class="hljs-comment">// takes ARRAY of arguments</span>
using .call() or .apply() invokes the <span class="hljs-function"><span class="hljs-keyword">function</span>, <span class="hljs-title">so</span> <span class="hljs-title">no</span> <span class="hljs-title">need</span> <span class="hljs-title">to</span> <span class="hljs-title">invoke</span> <span class="hljs-title">like</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>);
.<span class="hljs-title">bind</span>(<span class="hljs-params"></span>) <span class="hljs-title">does</span> <span class="hljs-title">NOT</span> <span class="hljs-title">invoke</span>, <span class="hljs-title">just</span> <span class="hljs-title">binds</span> <span class="hljs-title">values</span> <span class="hljs-title">prior</span> <span class="hljs-title">to</span> <span class="hljs-title">invocation</span>.
// <span class="hljs-title">this</span> <span class="hljs-title">way</span> <span class="hljs-title">one</span> <span class="hljs-title">can</span> <span class="hljs-title">bind</span> <span class="hljs-title">values</span> <span class="hljs-title">WITHOUT</span> <span class="hljs-title">calling</span> <span class="hljs-title">it</span>, <span class="hljs-title">so</span> <span class="hljs-title">no</span> <span class="hljs-title">need</span> <span class="hljs-title">to</span> <span class="hljs-title">create</span> <span class="hljs-title">another</span> <span class="hljs-title">inner</span> <span class="hljs-title">function</span>
// <span class="hljs-title">and</span> <span class="hljs-title">go</span> <span class="hljs-title">through</span> <span class="hljs-title">lots</span> <span class="hljs-title">of</span> <span class="hljs-title">work</span> <span class="hljs-title">to</span> <span class="hljs-title">avoid</span> <span class="hljs-title">screwing</span> <span class="hljs-title">up</span> <span class="hljs-title">scope</span></span></code></pre><hr>
<h2 id="js-basix">js basix</h2>
<pre class="hljs"><code>object that <span class="hljs-keyword">contains</span> a <span class="hljs-function"><span class="hljs-keyword">function</span></span> = {
  <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">return</span>: stuffs
  }
}
<span class="hljs-keyword">call</span>.the(object(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>)</code></pre><ul>
<li><code>arrayName.pop()</code> removes the last item from the array</li>
<li><code>arrayName.push(&quot;item&quot;, &quot;maybeAnotherItem&quot;)</code> adds to the end of the array</li>
<li><code>arrayName[integer] = &quot;item&quot;</code> adds item at this place in array; could leave empty items thusly</li>
<li><code>arrayName.shift()</code> removes FIRST item from array</li>
<li><code>arrayName.unshift(&quot;item&quot;, &quot;more if you want&quot;, &quot;hey why not&quot;)</code> adds to the BEGINNING of array</li>
<li><p><code>arrayName.splice(startingInteger, integerofItemsToRemove, &quot;string&quot;, &quot;item&quot;, &quot;etc&quot;)</code></p>
<p>  // example:
  var bits = [&quot;bots&quot;, &quot;boots&quot;, &quot;bats&quot;, &quot;beets&quot;, &quot;boats&quot;, &quot;bets&quot;]
  bits.splice(2, 2, &quot;wat&quot;, &quot;wuuuuuuuh&quot;)
  // would result in:
  bots boots way wuuuh boats bets</p>
</li>
</ul>
<p>use same method to just remove from an array eg <code>bits.splice(3, 3)</code> would return from the above, <code>bots boots boats bets</code></p>
<p>to move items from one array to another, also splice, like so: <code>var stib = bits.splice(2, 5)</code></p>
<p>this would leave bits unchanged.
2 is the starting index of item to be copied;
5 is the element AFTER the last one to be copied.
can use same method simply to reduce current array (overwrite)</p>
<pre class="hljs"><code><span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>: booleans (so no quotes)
<span class="hljs-keyword">if</span> blahblah
    <span class="hljs-keyword">break</span>;
don<span class="hljs-string">&#39;t know why i&#39;</span>m making a note <span class="hljs-keyword">of</span> <span class="hljs-string">&#39;break.&#39;</span>

whateVaR.toLowerCase(); <span class="hljs-comment">//does that thing that it says it does. WOOWWOWOWOWW</span>
wutTHEfack.toUpperCase(); <span class="hljs-comment">//does the exact opposite of the thing above this line. MIND. BLOWN.</span>

.slice(indexinginteger, firstCharAFTERtheslice) <span class="hljs-comment">// so, second number minus first number equals total characters in the slice</span>
example: <span class="hljs-keyword">var</span> threeLetterPrefix = thatDudesName.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)
.slice(singleNumber) would return <span class="hljs-keyword">until</span> the <span class="hljs-keyword">end</span> <span class="hljs-keyword">of</span> the string.

<span class="hljs-keyword">var</span> blah = whatever.length
<span class="hljs-comment">//returns the length of &#39;whatever&#39;</span></code></pre><p>in the case of true || whatever, whatever will never be checked;
in the casae of false &amp;&amp; whatever, whatever will never be checked.
they are evaluated <em>only when necessary</em>.</p>
<p>expression is kinda like a clause in natural language;
can have nested subclauses, whatnots.
statemets, more like full, complete sentences.</p>
<p>builtin function <code>Number()</code> converts given value to integer. for example:</p>
<pre class="hljs"><code><span class="hljs-tag">var</span> ancient = <span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(prompt(<span class="hljs-string">&#39;how many milliseconds have you been alive?&#39;</span>)</span></span>, <span class="hljs-string">&#39;&#39;</span>))
<span class="hljs-function"><span class="hljs-title">alert</span><span class="hljs-params">(<span class="hljs-string">&#39;you&#39;</span>re one old sonofabitch, <span class="hljs-string">&quot; + ancient + &quot;</span> is a long freaking time.<span class="hljs-string">&#39;)</span></span></span></code></pre><p>do loop is similar to while, but do will always execute at least once;
it doesn&#39;t test until after the first execution. example:</p>
<pre class="hljs"><code><span class="hljs-operator"><span class="hljs-keyword">do</span> {
  <span class="hljs-keyword">var</span> asdf = <span class="hljs-keyword">prompt</span>(<span class="hljs-string">&quot;what do they call you?&quot;</span>)
  } <span class="hljs-keyword">while</span> (!asdf)
console.<span class="hljs-keyword">log</span>(asdf)
// this will <span class="hljs-keyword">keep</span> prompting <span class="hljs-keyword">until</span> the <span class="hljs-keyword">prompt</span> recieves a <span class="hljs-keyword">string</span></span></code></pre><p>standard loop boilerplate pattern: counter variable to count (duh);
while loop (check counter against limit?) then update counter.</p>
<p>OH WAIT WE CALL THIS A FOR LOOP DUH.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">number</span> &lt;= <span class="hljs-number">26</span>; <span class="hljs-built_in">number</span> = <span class="hljs-built_in">number</span> + <span class="hljs-number">1</span>)
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">number</span>)
<span class="hljs-comment">//0</span>
<span class="hljs-comment">//1</span>
<span class="hljs-comment">//etc, until we are less than or equal to 26.</span></code></pre><ul>
<li>for loop syntax:<ul>
<li>for (bit that initializes the loop, like setting an integer at 0 to count up;</li>
<li>expression check if the loop should still go, like defining a counting limit;</li>
<li>what to do, if we&#39;ve made it through those first bits)</li>
<li>always needs three sections/two semicolons</li>
</ul>
</li>
</ul>
<p><code>+=</code> is not the only thing that works for updating;
looks like all math operations, when done <code>i *= i</code>;
obvs <code>i += i</code> and <code>i -= i</code> can be shortened to <code>i--</code> and <code>i++</code></p>
<p>switch: it&#39;s case, i guess, but minus esac (because, note, we also don&#39;t use done, or fi... wtf).</p>
<p>so:</p>
<pre class="hljs"><code><span class="hljs-keyword">switch</span> (thingy(whatthewhat)) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;oioioi!&quot;</span>:
    alert(<span class="hljs-string">&quot;OI! OI! OI!&quot;</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;blaahh&quot;</span>:
    whatever
  <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">default</span>:
    console.log(<span class="hljs-string">&quot;u r a bag of dix&quot;</span>)
  <span class="hljs-keyword">break</span>
}</code></pre><p>functions always have curly braces around body, even if just one command</p>
<p>braces are allowed everywhere but only define a new local environment within functions,
and only really useful for grouping conditionals and loops</p>
<p>like any other variable, functions can totally get new names.
their values are just as mutable as any other vars&#39;.</p>
<p>use brackets when accessing vague proprop (eg looping over) from object;
otherwise dot notation if know specific key</p>
<p>NOT <code>for i in arr.length whatever</code></p>
<p>....</p>
<p>rather,
<code>return arr[arr.length -1]</code></p>
<pre class="hljs"><code><span class="hljs-comment">//GLOBAL SCOPE</span>
<span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outerFunction</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">//LOCAL SCOPE FOR OUTERFUNCTION</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFunction</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">//LOCAL SCOPE INNERFUNCTION</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;hello&#39;</span>;
  }
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">returnOne</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-keyword">var</span> myNewFunction = outerFunction();
myNewFunction();
myNewFunction();
<span class="hljs-keyword">var</span> numOne = returnOne();

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//local scoped makeCounter and children</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCounter</span><span class="hljs-params">()</span> </span>{
    counter++;
  }
}

<span class="hljs-keyword">var</span> count = makeCounter();
count(); <span class="hljs-comment">//return 1</span>
count(); <span class="hljs-comment">//return 2</span>
<span class="hljs-keyword">var</span> count = makeCounter();

<span class="hljs-keyword">var</span> secondCount = makeCounter();
secondCount() <span class="hljs-comment">//return 1</span></code></pre><p>a closure references variables OUTSIDE OF ITSELF
and remembers those even when its parent scope (parent function) has returned</p>
<p>remember, don&#39;t need to do
<code>if whatever == true/if whatever != true (or == false)</code>
just need to do</p>
<pre class="hljs"><code>if<span class="hljs-function"> (</span>whatever<span class="hljs-function">)</span><span class="hljs-instruction">
return </span>true
else<span class="hljs-instruction">
return </span>false
<span class="hljs-keyword">.</span>..<span class="hljs-instruction"> and </span>that&#39;s all.


// reversing an<span class="hljs-instruction"> array </span>without using<span class="hljs-function"> array.reverse(</span><span class="hljs-function">)</span> ...
function<span class="hljs-function"> flipIt(</span>arr<span class="hljs-function">)</span>{
  var flipped =<span class="hljs-instruction"> new </span>Array
 <span class="hljs-function"> for(</span>var i = arr.length-1; i &gt;= 0; i--<span class="hljs-function">)</span>{
   <span class="hljs-function"> flipped.push(</span>arr<span class="hljs-keyword">[</span>i]<span class="hljs-function">)</span>
  }
 <span class="hljs-instruction"> return </span>flipped
}</code></pre><hr>
<h2 id="ajax-jquery-snippets">ajax (jquery) snippets</h2>
<pre class="hljs"><code>$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> app = $(<span class="hljs-string">&#39;app&#39;</span>)
  <span class="hljs-keyword">var</span> header = $(<span class="hljs-string">&#39;&lt;h3&gt;Random Colour Palette&lt;/h3&gt;&#39;</span>)
  <span class="hljs-keyword">var</span> button = $(<span class="hljs-string">&#39;&lt;button&gt;Colours!&lt;/button&gt;&#39;</span>)
  <span class="hljs-keyword">var</span> clear = $(<span class="hljs-string">&#39;&lt;button&gt;New ones!&lt;/button&gt;&#39;</span>)
  <span class="hljs-keyword">var</span> list = $(<span class="hljs-string">&#39;&lt;ul&gt;&lt;/ul&gt;&#39;</span>)
  button.on(<span class="hljs-string">&#39;click&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    $.ajax({
      method: <span class="hljs-string">&#39;GET&#39;</span>,
      url:<span class="hljs-string">&#39;<a href="http://www.colourlovers.com/api/palettes/random?format=json">http://www.colourlovers.com/api/palettes/random?format=json</a>&#39;</span>,
    }).then(data){
      <span class="hljs-keyword">var</span> dataObj = <span class="hljs-built_in">JSON</span>.parse(data)
      showData(dataObj)
    })
  }

  app.append(header)
  app.append(button)
  app.append(clear)
  app.append(palette)

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showData</span>(<span class="hljs-params">data</span>)</span>{
    <span class="hljs-keyword">var</span> image = indexOf(<span class="hljs-string">&#39;imageUrl&#39;</span>)
    <span class="hljs-keyword">var</span> paletteDiv = $(<span class="hljs-string">&#39;&lt;div&gt;&lt;/div&gt;&#39;</span>)
    <span class="hljs-comment">//    var image = $(image tag  + url)</span>

    pallet.append(paletteDiv)
  }

})</code></pre><hr>
<h2 id="toy-problem-notes-week-two">toy problem notes, week two</h2>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkEvens</span>(<span class="hljs-params"> num </span>) </span>{
  <span class="hljs-keyword">if</span> (num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {    <span class="hljs-comment">// this just checks if the argument passed is divisible by two</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compareLengths</span>(<span class="hljs-params"> originalArr, newArr </span>) </span>{
  <span class="hljs-keyword">if</span> (originalArr &gt; newArr) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;More odds than evens.&#39;</span>   <span class="hljs-comment">// this is pretty self-explanitory</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (originalArr &lt; newArr) { <span class="hljs-comment">// just comparing lengths (whodathunkit)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;More evens than odds.&#39;</span>   <span class="hljs-comment">// and returning based on which is longer</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#39;Same number of evens and odds&#39;</span>
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">howMany</span>(<span class="hljs-params"> originalArr, newArr, evensOrOdds </span>) </span>{
  <span class="hljs-keyword">if</span> (evensOrOdds === <span class="hljs-string">&#39;More odds than evens.&#39;</span>) {
    <span class="hljs-keyword">var</span> length = originalArr.length - newArr.length <span class="hljs-comment">// this is the bit where things are</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;There are &#39;</span> + length + <span class="hljs-string">&#39; more odds than evens.&#39;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (evensOrOdds === <span class="hljs-string">&#39;More evens than odds.&#39;</span>) {
    <span class="hljs-keyword">var</span> length = newArr.length - (originalArr.length - newArr.length)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;There are &#39;</span> + length + <span class="hljs-string">&#39; more evens than odds.&#39;</span>)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;There are the same number of evens and odds.&#39;</span>)
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCallbacks</span>(<span class="hljs-params"> iterator, lengthCompare, counter, arr </span>) </span>{
  <span class="hljs-keyword">var</span> newArray = []                      <span class="hljs-comment">// hey hey hey, a sweet new array</span>
  arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> num, index </span>) </span>{   <span class="hljs-comment">// let&#39;s loop over the old array first</span>
    <span class="hljs-keyword">if</span> (checkEvens(num)) {               <span class="hljs-comment">// see if them items is %2===0</span>
      newArray.push(checkEvens(num))     <span class="hljs-comment">// if they is... i can&#39;t keep that up...</span>
    }                                    <span class="hljs-comment">// we just push them to the new array.</span>
  })
  <span class="hljs-keyword">var</span> evensOrOdds = lengthCompare(arr, newArray) <span class="hljs-comment">// we compare lengths of the old array and new array</span>
  counter(arr, newArray, evensOrOdds)            <span class="hljs-comment">// we pass the old array, the new array, and the variable above</span>
}                                                <span class="hljs-comment">// to the parameter from the top of this function</span>

<span class="hljs-keyword">var</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ,<span class="hljs-number">3</span> ,<span class="hljs-number">4</span> ,<span class="hljs-number">5</span> ,<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>] <span class="hljs-comment">// oh, HERE&#39;s that array we keep talking about</span>

myCallbacks(checkEvens, compareLengths, howMany, myArray) <span class="hljs-comment">// let&#39;s invoke that function and pass it ALL THE THINGS</span></code></pre><hr>
<h2 id="something-about-some-twitter-clone-thing">something about some twitter clone thing</h2>
<h3 id="do-this">do this</h3>
<ul>
<li>hide tweet button and character count initially (so, just not there)</li>
<li>on click, double textarea size, reveal character count and tweet button</li>
<li>ch count decrease realtime</li>
<li>at 10 chars, count turns red</li>
<li>if chars &gt; 140, disable tweet button (and re-enable if =&lt; 140)</li>
<li>new tweet pushed to column immediately, w/ prof image in top left, full username and name</li>
<li>tweet actions on :hover over individual tweets only</li>
<li>rt/timestamp/reply area hidden by default; expand on click</li>
<li>timestamps with timeago (or, i think, livestamp actually)</li>
<li>icons for favs/rts in upper right of tweet card</li>
<li>bootstrap tooltips on :hover over avatar</li>
<li>localstorage (or howabout localForage?)</li>
<li>or baas... ... yeah. localforage.</li>
</ul>
<h4 id="notes-on-changes">notes on changes</h4>
<ul>
<li>setting max-viewport is a <em>horrible</em> practice. nixed.</li>
<li>normalize instead of reset; cdn instead of stuck in our own stylesheet.</li>
<li>updated to jquery 2.1.4; cdn instead of in our js directory.</li>
<li>replacing ids with classes, at least for starters... just a few ids in here, sprinkled around </li>
<li><code>page-container</code> = <code>container</code></li>
<li><code>dashboard</code> = <code>dash</code></li>
<li><code>profile-summary</code> = <code>profile</code></li>
<li><code>char-count</code> = <code>count</code></li>
<li><code>tweet-controls</code> = <code>controls</code></li>
<li>because i don&#39;t like to type</li>
</ul>
<h4 id="notes-on-the-process-and-result-">notes on the process (and result)</h4>
<ul>
<li>so it turns out that i&#39;m 99% sure none of us is doing this right. after doing epic battle with</li>
<li>the javascripts, i&#39;ve been defeated. manually moving the first tweet down and putting the new</li>
<li>tweet&#39;s content in its place, right now, kind of relies solely on using the actual username/name</li>
<li>of the former top tweet on the feed (btw, css could probably use an update... twitter&#39;s one column</li>
<li>of user and tweets, and two side columns of promos and ads, now.). that&#39;s, uh, totally unrealistic.</li>
</ul>
<hr>
<h2 id="murr-nuutes">murr nuutes</h2>
<pre class="hljs"><code><span class="hljs-comment">// make a loop. then have it go 1-5 endlessly. then have it only do it once.</span>

<span class="hljs-comment">// our way</span>
<span class="hljs-comment">// function count () {</span>
<span class="hljs-comment">//   while (true) {</span>
<span class="hljs-comment">//    for (i = 1; i &lt;= 5; i++) {</span>
<span class="hljs-comment">//      console.log(i);</span>
<span class="hljs-comment">//     }</span>
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// correct way</span>
<span class="hljs-comment">// function countOnce () {</span>
<span class="hljs-comment">//   for (var i = 0; i &lt; 1; i++) {</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">5</span>) {
      <span class="hljs-keyword">return</span> num++;
    } <span class="hljs-keyword">else</span> {
      num = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> num;
    }
  };
}
<span class="hljs-comment">//   }</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// other way</span>

<span class="hljs-comment">// function makeCounter() {</span>
<span class="hljs-comment">//  var x = 1;</span>
<span class="hljs-comment">//  retrun function() {</span>
<span class="hljs-comment">//    console.log(x1);</span>
<span class="hljs-comment">//    x++;</span>
<span class="hljs-comment">//    if (x&gt;5) {</span>
<span class="hljs-comment">//      x=0;</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//    }</span>
<span class="hljs-comment">//  }</span>
<span class="hljs-comment">// }</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeCounter</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> counter = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> counter2 = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myCounter</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (counter2 &gt; <span class="hljs-number">11</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (counter === <span class="hljs-number">6</span>) {
      counter = <span class="hljs-number">0</span>;
    }
    counter2++;
    <span class="hljs-keyword">return</span> counter++;
  };
}

<span class="hljs-comment">// Objects: less primitive than primitives.</span>
<span class="hljs-comment">// create an object literal that models a facebook message:</span>

<span class="hljs-comment">// var fbMsg = {</span>
<span class="hljs-comment">//    sender: &#39;Jack&#39;;</span>
<span class="hljs-comment">//    recipient: &#39;Jill&#39;;</span>
<span class="hljs-comment">//    topic: [&#39;water&#39;, &#39;pail&#39;, &#39;hill&#39;, &#39;cranial trauma&#39;]</span>
<span class="hljs-comment">//    }</span>

<span class="hljs-comment">// or, using new Object();</span>

<span class="hljs-keyword">var</span> fbMsg = { };
fbMsg.sender = <span class="hljs-string">&#39;Jack&#39;</span>;
fbMsg.recipient = <span class="hljs-string">&#39;Jill&#39;</span>;
fbMsg.topic = [<span class="hljs-string">&#39;water&#39;</span>, <span class="hljs-string">&#39;pail&#39;</span>, <span class="hljs-string">&#39;hill&#39;</span>, <span class="hljs-string">&#39;cranial trauma&#39;</span>];

<span class="hljs-comment">// removing from object, much less work than in array</span>

<span class="hljs-keyword">delete</span> message.recipient;

<span class="hljs-comment">// brackets also work for accessing properties on an object</span>

fbMsg[<span class="hljs-string">&#39;fuzzy date&#39;</span>] = <span class="hljs-string">&#39;yesterday afternoon&#39;</span>;

<span class="hljs-comment">// for loops over keys/values in an object:</span>

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> fbMsg) {
  <span class="hljs-built_in">console</span>.log(key);
}

<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> fbMsg) {
  <span class="hljs-built_in">console</span>.log(fbMsg[value]);
}

<span class="hljs-comment">// you don&#39;t really NEED to declare that something&#39;s a variable...</span>
<span class="hljs-comment">// that&#39;s bad practice, though. that&#39;ll make your whatever a global variable.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// there are no constants in javascrpt, apparently.</span>
<span class="hljs-comment">// so, js isn&#39;t really modular. and scripts included in html will basically</span>
<span class="hljs-comment">// just override in loading order. so, a script tag by the footer would</span>
<span class="hljs-comment">// override one that&#39;s all the way up at the beginning of your body, if they</span>
<span class="hljs-comment">// had the same globals, for example.</span>

<span class="hljs-comment">// wrapping an entire function (even anonymous) in parens is a sweet idea!</span>
<span class="hljs-comment">// this way you&#39;re not polluting global namespace, and you can just</span>
<span class="hljs-comment">// invoke the &#39;function expression&#39; immediately, so it&#39;s not really any</span>
<span class="hljs-comment">// different in practice than as if you&#39;d left off the parents. so...</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> yo = <span class="hljs-string">&#39;billybob&#39;</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;what up &#39;</span> + yo);
})();(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> yo = <span class="hljs-string">&#39;margie-jo&#39;</span>;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;what up &#39;</span> + yo);
})();

<span class="hljs-comment">// i guess a lot of minifiers will automatically just wrap all your scripts</span>
<span class="hljs-comment">// in these kind of expressions?</span>

<span class="hljs-comment">// a function is an object. it has a property called prototype.</span>
<span class="hljs-comment">// the keys of prototype (which is an object itself) are inhereted by any other</span>
<span class="hljs-comment">// object below that one.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// one can add to a prototype after declaring that function.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// a prototype describes the idea of a thing; here&#39;s all the things that would</span>
<span class="hljs-comment">// be in a facebook message, y&#39;know? so this way, we just made a CONSTRUCTOR.</span>
<span class="hljs-comment">// and there&#39;s your use for the new Object syntax! now we know how to use that.</span>
<span class="hljs-comment">//</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Message</span>(<span class="hljs-params">sender, recipient, topic</span>) </span>{
  <span class="hljs-keyword">this</span>.from = sender;
  <span class="hljs-keyword">this</span>.to = recipient;
  <span class="hljs-keyword">this</span>.subject = topic;
}

<span class="hljs-comment">// if you DON&#39;T explicity definte a prototype, you&#39;d get one anyway,</span>
<span class="hljs-comment">// it would basically just be implied/automatic.</span>
<span class="hljs-comment">// readability is a good reason to explicitly define it, though.</span>
<span class="hljs-comment">// also, you can set values in your prototype, obvs, that&#39;ll then be applied</span>
<span class="hljs-comment">// to all the stuffs that uses that prototype.</span>

<span class="hljs-comment">// // so we could also go ahead and comment out all that like so</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Message</span>(<span class="hljs-params"></span>) </span>{
}

Message.prototype = {
  to: <span class="hljs-string">&#39; &#39;</span>,
  from: <span class="hljs-string">&#39; &#39;</span>,
  about: <span class="hljs-string">&#39; &#39;</span>,
  date: <span class="hljs-string">&#39; &#39;</span> <span class="hljs-comment">// note no comma on this line</span>
};        <span class="hljs-comment">// also note that this could return stuff in ANY GODDAMN ORDER.</span>

<span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">new</span> Message (<span class="hljs-string">&#39;joe&#39;</span>, <span class="hljs-string">&#39;ruth&#39;</span>, <span class="hljs-string">&#39;pickles and cream cheese&#39;</span>);
<span class="hljs-keyword">var</span> mssg - <span class="hljs-keyword">new</span> Message (<span class="hljs-string">&#39;ann&#39;</span>, <span class="hljs-string">&#39;barb&#39;</span>, <span class="hljs-string">&#39;i hear joe eats some weird stuff&#39;</span>);
<span class="hljs-built_in">console</span>.log(msg, mssg);

<span class="hljs-comment">// this will make each one basically have the same structure (oh! prototype)</span>
<span class="hljs-comment">// is basically a framework for building objects!), but each INSTANCE is a</span>
<span class="hljs-comment">// totally different actual object. okay.</span>

<span class="hljs-comment">// the keyword this: this.thing, etc... this just references the new (current</span>
<span class="hljs-comment">// parent) object, that&#39;s all!</span>

<span class="hljs-comment">// okay. a method is a property containing a function definition. that sounds</span>
<span class="hljs-comment">// more complicated than it needs to. a method is kind of like a little</span>
<span class="hljs-comment">// function that works just on an object, i guess.</span>
<span class="hljs-comment">// or, in other words, it&#39;s literally just a property, the value of which</span>
<span class="hljs-comment">// happens to be a function.</span>

<span class="hljs-comment">// okay, and so as was just cleared up, things that use the notation that</span>
<span class="hljs-comment">// makes me think they&#39;re just being confusing and shit? yeah. basically just</span>
<span class="hljs-comment">// properties of the string object, or the window object, or the browser</span>
<span class="hljs-comment">// object, or the global (in node) object.</span>

<span class="hljs-comment">// but wait. what about node, really, seriously? i mean, is global the same</span>
<span class="hljs-comment">// as browser? or window? because those are actual structures that would need</span>
<span class="hljs-comment">// to be emulated, right? um... i&#39;ll want to ask our lecturer this, though</span>
<span class="hljs-comment">// chances are we&#39;ll actually be getting to this in a few weeks.</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// ARRAYS</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// Length of an array is how many items. In arrays, order matters (unlike objects).</span>



<span class="hljs-comment">// snippet for reversing strings, because we apparently don&#39;t have a builtin</span>
<span class="hljs-comment">// for this, exactly...</span>
<span class="hljs-keyword">var</span> reversed
  , name = <span class="hljs-string">&quot;zac anger&quot;</span>;

reversed = name.split(<span class="hljs-string">&quot;&quot;</span>).reverse().join(<span class="hljs-string">&quot;&quot;</span>);
<span class="hljs-keyword">return</span>(reversed);

<span class="hljs-comment">//</span>
<span class="hljs-comment">// THIS</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// <code>this</code> is not assigned a value until an <em>object</em> invokes the <em>function</em></span>
<span class="hljs-comment">// where <code>this</code> is defined.</span>
<span class="hljs-comment">// So, while it seems (to me, and I guess to others) that <code>this</code> refers to the</span>
<span class="hljs-comment">// object, it&#39;s not until an object invokes a function that <code>this</code> is</span>
<span class="hljs-comment">// actually assigned a value. The actual <em>value</em> is <strong>only</strong> based on which</span>
<span class="hljs-comment">// object invoked said function. <code>this</code> has the value of the invoking object</span>
<span class="hljs-comment">// in most cases. sometimes it does not.</span>

<span class="hljs-comment">// IMPLICIT is the value attached to a keyword when it refers to an object</span>
<span class="hljs-comment">// and it applies to the PARENT object</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// EXPLICIT (call, apply, bind)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// DEFAULT (window object)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// NEW in creation of new objects</span>

<span class="hljs-comment">// To mantain <code>this</code> inside anonymous functions, we can set the value</span>
<span class="hljs-comment">// before entering all that forEach bidnez.</span>
<span class="hljs-comment">// eg var that = this ... lol</span>

<span class="hljs-keyword">var</span> arrOne = [<span class="hljs-number">1</span>, <span class="hljs-number">44</span>, <span class="hljs-number">7</span>, <span class="hljs-number">89</span>];
<span class="hljs-keyword">var</span> arrTwo = [<span class="hljs-number">44</span>, <span class="hljs-number">2</span>, <span class="hljs-number">19</span>, <span class="hljs-number">21</span>, <span class="hljs-number">37</span>, <span class="hljs-number">1</span>];
<span class="hljs-keyword">var</span> arrThree = [<span class="hljs-number">56</span>, <span class="hljs-number">19</span>, <span class="hljs-number">44</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">89</span>];
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arrayItUp</span>(<span class="hljs-params">arrOne, arrTwo, arrThree</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i =&gt; arrOne.length; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j =&gt; arrTwo.length; j++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>; k =&gt; arrThree.length; k++) {
        <span class="hljs-keyword">if</span> (arrOne[i] === arrTwo[j] &amp;&amp; arrOne[i] === arrThree[k]);
        arrFour.push(arrOne[i]);
      }
    }
  }
  <span class="hljs-keyword">return</span> arrFour;
}
arrayItUp(arrOne, arrTwo, arrThree);

<span class="hljs-comment">// all of this could&#39;ve just been basically a foreach loop... and avoided</span>
<span class="hljs-comment">// the scope problems... crap.</span>


<span class="hljs-comment">//</span>
<span class="hljs-comment">// back to <code>this</code></span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// because it&#39;s better to keep methods and their objects/properties together in</span>
<span class="hljs-comment">// the same model, one can always go ahead and make a method over there, and</span>
<span class="hljs-comment">// then include that method as the value to a key under the object. that way</span>
<span class="hljs-comment">// you&#39;ve got modularity of a sort, but also keeping your models together in</span>
<span class="hljs-comment">// one place.</span>
<span class="hljs-comment">// so defining it in one place and then pointing to it in a second and maybe</span>
<span class="hljs-comment">// invoking it in a third? it&#39;s still going to point to that <em>function</em> that</span>
<span class="hljs-comment">// called it (or, rather, that function&#39;s object).</span>
<span class="hljs-comment">// may be important, because he&#39;s said this several times now:</span>
<span class="hljs-comment">// &#39;we want our models to represent the real world.&#39; and...</span>
<span class="hljs-comment">// &#39;we want the behaviors that represent our models to be with those models.&#39;</span>
<span class="hljs-comment">// i suppose this is more expressive? either way, it&#39;s obvious how it&#39;d be</span>
<span class="hljs-comment">// much easier to maintain and scale.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// .call is ONLY on a function, yo.</span>
<span class="hljs-comment">// .apply works identically to call, except in how one passes in parameters.</span>
<span class="hljs-comment">// first argument is <em>always</em> what <code>this</code> is bound to... which to use depends</span>
<span class="hljs-comment">// on how you intend to pass in parameters.</span>
<span class="hljs-comment">// btw, <code>arguments</code> is actually a keyword, apparently--for use in functions,</span>
<span class="hljs-comment">// it provides an array of all the passed parameters.</span>
<span class="hljs-comment">// but with .call, the second argument is a comma sep list;</span>
<span class="hljs-comment">// .call and .apply invoke the function immediately. .bind dooesn&#39;t. instead,</span>
<span class="hljs-comment">// it kind of makes a new function for you. that&#39;s actually super cool!</span>
<span class="hljs-comment">// OKAY OKAY wait. so. both call and apply are functions  that can ONLY be</span>
<span class="hljs-comment">// called on other functions! The one difference here is that call accepts both</span>
<span class="hljs-comment">// a first argument AND ANY ADDITIONAL ARGUMENTS THA ARE PASSED TO IT.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// okay, here&#39;s a new example.</span>

<span class="hljs-keyword">var</span> car = {};

<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doors, model, make</span>) </span>{
  <span class="hljs-keyword">this</span>.doors = doors
  <span class="hljs-keyword">this</span>.make = make
  <span class="hljs-keyword">this</span>.model = model
  <span class="hljs-keyword">return</span>
}

car.call (car, <span class="hljs-number">2</span>, <span class="hljs-string">&#39;Hyundai&#39;</span>, <span class="hljs-string">&#39;Equus&#39;</span>);

<span class="hljs-comment">// so this is actually just a super roundabout way (in this simplified example)</span>
<span class="hljs-comment">// to do a constructor functon, i guess.</span>


<span class="hljs-comment">// okay, so the NEW keyword! var blah = new Blah(thing2 thing2);</span>
<span class="hljs-comment">// but javascript IMPLICITLY does that, and IMPLICITY returns things for you,</span>
<span class="hljs-comment">// and so makes things easier for you. HOWEVER, <code>new</code> is actually a shortcut</span>
<span class="hljs-comment">// for you. but don&#39;t do that. it&#39;s not pretty, and it&#39;s not nice.</span>
<span class="hljs-comment">// there&#39;s a thing that&#39;s like if (this instanceof Foo) or so, which will aid</span>
<span class="hljs-comment">// in avoiding using the window/browser/global object. syntax is super fuzzy</span>
<span class="hljs-comment">// though.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// currying: providing missing paramaters, some or all, when you call BIND.</span>
<span class="hljs-comment">// it will not override anything. so:</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">what</span>(<span class="hljs-params">one, two</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;oi! &#39;</span> + one);
}

<span class="hljs-keyword">var</span> huh = { meh: <span class="hljs-string">&#39;yo&#39;</span> }; meh.what(); (two);

<span class="hljs-comment">// so with apply, those other parameters after the first, you&#39;d better get</span>
<span class="hljs-comment">// them into an array.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// from rey:</span>
<span class="hljs-comment">// The this Keyword</span>
<span class="hljs-comment">// In JavaScript, the thing called this, is the object that &quot;owns&quot; the JavaScript code.</span>
<span class="hljs-comment">//The value of this, when used in a function, is the object that &quot;owns&quot; the function.</span>
<span class="hljs-comment">//The value of this, when used in an object, is the object itself.</span>
<span class="hljs-comment">//The this keyword in an object constructor does not have a value. It is only a substitute for the new object.</span>
<span class="hljs-comment">//The value of this will become the new object when the constructor is used to create an object.</span>
<span class="hljs-comment">//Note     Note that this is not a variable. It is a keyword. You cannot change the value of this.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//<a href="http://www.codeproject.com/Articles/857357/Introduction-to-HTML-WebSockets">http://www.codeproject.com/Articles/857357/Introduction-to-HTML-WebSockets</a> , <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API</a> and <a href="http://www.html5rocks.com/en/tutorials/websockets/basics/">http://www.html5rocks.com/en/tutorials/websockets/basics/</a> are some good primers on the websockets topic mentioned a little bit ago; and <a href="https://www.pubnub.com/blog/websockets-vs-rest-api-understanding-the-difference/">https://www.pubnub.com/blog/websockets-vs-rest-api-understanding-the-difference/</a> and <a href="https://news.ycombinator.com/item?id=3636681">https://news.ycombinator.com/item?id=3636681</a> for differences between websockets and http/rest/ajax/xhr/every-other-hacker-news-buzzword.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// ASYNC</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to avoid problems with async functions and synchronous functions causing conflicts</span>
<span class="hljs-comment">// (eg a sync one returning undefined because the async one hasn&#39;t finished yet),</span>
<span class="hljs-comment">// just do callbacks. that makes <strong>sense</strong>, okay!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// worth noting again that setTimeout really isn&#39;t fantastic practice, so maybe just don&#39;t do that...</span>
<span class="hljs-comment">// but if you do, it&#39;s super not difficult, so don&#39;t make it difficult.</span>
<span class="hljs-comment">// just put in a function (which can obviously just be calling something defined elsewhere), and the</span>
<span class="hljs-comment">// time (in milliseconds, which can also be calculated elsewhere). that&#39;s all.</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doThatThing</span>(<span class="hljs-params">arr</span>)</span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-string">&#39;Hello &#39;</span> + arr + <span class="hljs-string">&#39;, how are you?&#39;</span>);
}
setTimeout(doThatThing, <span class="hljs-number">1000</span>);

<span class="hljs-comment">// ask:</span>
<span class="hljs-comment">// would it be harmful to think of underscore (or functional javascript in general) as</span>
<span class="hljs-comment">// being modular libraries/modules? (because javascript, at least in the browser, is not</span>
<span class="hljs-comment">// inherently modular -- no more so than it is inherently functional, object-oriented,</span>
<span class="hljs-comment">// or anything else... it&#39;s dynamic and multi-paradigm).</span>

<span class="hljs-comment">// order.updateTotal();</span>
<span class="hljs-comment">// console.log(order.total.bind();</span>

<span class="hljs-comment">// he uses &#39;self&#39;; we could just as easily use &#39;that&#39; or whatever <code>var foo = this.bar</code></span>
<span class="hljs-comment">// ... or we could not, also.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Functions as parameters</span>

<span class="hljs-comment">// Create a function that calculates 10% tax</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateTax</span>(<span class="hljs-params">amount</span>) </span>{
  <span class="hljs-keyword">return</span> amount <em> <span class="hljs-number">0.10</span>;
}

<span class="hljs-comment">// Create a function that takes in an order amount calculates total</span>
<span class="hljs-comment">// including tax</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateTotal</span>(<span class="hljs-params">amount</span>) </span>{
  <span class="hljs-keyword">return</span> amount + calculateTax(amount);
}

<span class="hljs-keyword">var</span> orderTotal = calculateTotal(<span class="hljs-number">10.00</span>);
<span class="hljs-built_in">console</span>.log(orderTotal);

<span class="hljs-comment">// Create a function that calculates 7% tax for Utah</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calculateUtahTax</span>(<span class="hljs-params">amount</span>) </span>{
  <span class="hljs-keyword">return</span> amount </em> <span class="hljs-number">0.07</span>;
}

<span class="hljs-comment">// Update calculateTotal to include a state parameter use</span>
<span class="hljs-comment">// the new utah calculator when the state is Utah</span>
calculateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">amount, state</span>) </span>{
  <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#39;Utah&#39;</span>) {
    <span class="hljs-keyword">return</span> amount + calculateUtahTax(amount);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> amount + calculateTax(amount);
  }
};

orderTotal = calculateTotal(<span class="hljs-number">20</span>, <span class="hljs-string">&#39;Utah&#39;</span>);
<span class="hljs-built_in">console</span>.log(orderTotal);

<span class="hljs-comment">// Q: What are some potential problems with this method?</span>
<span class="hljs-comment">// Q: What if tax calculation for Utah is based on county?</span>
<span class="hljs-comment">// Q: What if we need to calculate for other states?</span>

<span class="hljs-comment">// Update the calculateTotal to accept a function</span>
<span class="hljs-comment">// as a parameter that can calculate tax</span>
calculateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">amount, taxCalculator</span>) </span>{
  <span class="hljs-keyword">return</span> amount + taxCalculator(amount);
};


<span class="hljs-comment">// Invoke calculateTotal with both calculateTax functions</span>
orderTotal = calculateTotal(<span class="hljs-number">30</span>, calculateUtahTax);
<span class="hljs-built_in">console</span>.log(orderTotal);

<span class="hljs-comment">// Q: What is better about this approach?</span>


<span class="hljs-comment">// Create a another function called GetTaxCalculator</span>
<span class="hljs-comment">// that takes state as a parameter and returns the</span>
<span class="hljs-comment">// correct tax calculator</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetTaxCalculator</span>(<span class="hljs-params"></span>) </span>{

}

<span class="hljs-comment">// Q: If we add new tax calculators, what code will need to be updated?</span>

<span class="hljs-comment">// Using functions as arguments to other functions is one way we can</span>
<span class="hljs-comment">// get results from an asynchronous function.</span>

<span class="hljs-comment">// Asynchronous &amp; functions as callbacks</span>

<span class="hljs-comment">// Create a function called done, that writes done to the console</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">done</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;done&#39;</span>);
}

<span class="hljs-comment">// Use setTimeout and pass the done function as the callback</span>
setTimeout(done, <span class="hljs-number">2000</span>);

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;after setTimeout&#39;</span>);

<span class="hljs-comment">// Q: Why does &#39;after setTimeout&#39; display before &#39;done&#39;?</span>


<span class="hljs-comment">// Create a function called getColors that uses setTimeout to simulate</span>
<span class="hljs-comment">// an asynchronous call to a web server that returns an array of colors</span>
<span class="hljs-keyword">var</span> getColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//console.log(&#39;Returning colors...&#39;);</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#39;Red&#39;</span>,<span class="hljs-string">&#39;Blue&#39;</span>,<span class="hljs-string">&#39;Purple&#39;</span>,<span class="hljs-string">&#39;Black&#39;</span>];
  },<span class="hljs-number">500</span>);
};


<span class="hljs-comment">// Q: What will the value of colors be? Why?</span>
<span class="hljs-keyword">var</span> colors = getColors();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;Colors: &#39;</span> + colors);

<span class="hljs-comment">// Update getColors to solve the problem by using a callback</span>
getColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">displayColors</span>) </span>{

  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    displayColors([<span class="hljs-string">&#39;Red&#39;</span>,<span class="hljs-string">&#39;Blue&#39;</span>,<span class="hljs-string">&#39;Purple&#39;</span>,<span class="hljs-string">&#39;Black&#39;</span>]);
  },<span class="hljs-number">500</span>);

};
<span class="hljs-comment">// Invoke getColors again using the callback</span>
<span class="hljs-keyword">var</span> displayColors = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">colors</span>) </span>{
  <span class="hljs-built_in">console</span>.log(colors);
};

getColors(displayColors);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;after getColors&#39;</span>);


<span class="hljs-comment">// Q: What challenges does asynchronous code create? How does it affect</span>
<span class="hljs-comment">// code readability?</span>
<span class="hljs-comment">// Q: What advantages does it provide?</span>

<span class="hljs-comment">// Create a function called forEach that takes an array as the first parameter, and a function as the second parameter.  The forEach function should loop over the items in the array and invoke the callback function, passing in each item in the array</span>
<span class="hljs-keyword">var</span> forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items, callback</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) {
    callback(items[i]);
  }
};

<span class="hljs-comment">// Create an array of colors</span>
<span class="hljs-keyword">var</span> colors = [<span class="hljs-string">&#39;Red&#39;</span>, <span class="hljs-string">&#39;Blue&#39;</span>, <span class="hljs-string">&#39;Purple&#39;</span>, <span class="hljs-string">&#39;Pink&#39;</span>];

<span class="hljs-comment">// use forEach to loop over the array of colors.  Pass a callback</span>
<span class="hljs-comment">// to forEach that receives a color as a parameter and outputs the</span>
<span class="hljs-comment">// name of the color to the console.</span>
forEach(colors, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">color</span>) </span>{
  <span class="hljs-keyword">return</span> color;
});

<span class="hljs-comment">// Now create an order object that has a total property, and a property called items that is an array containing item prices. Add a method called updateTotal that uses the forEach function to loop over the items and update the total property</span>
<span class="hljs-keyword">var</span> order = {
  total: <span class="hljs-number">0</span>,
  items: [<span class="hljs-number">1.99</span>,<span class="hljs-number">2.50</span>,<span class="hljs-number">9.99</span>],
  updateTotal: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.total = <span class="hljs-number">0</span>;

    forEach(<span class="hljs-keyword">this</span>.items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
      <span class="hljs-keyword">this</span>.total += item;
    });
  }
};

<span class="hljs-comment">// Invoke the updateTotal method and display the order total</span>
order.updateTotal();
<span class="hljs-built_in">console</span>.log(order.total);

<span class="hljs-comment">// Q: Why is the total zero?</span>

<span class="hljs-comment">// Change the updateTotal method to solve the problem using &#39;self&#39;</span>
order.updateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.total = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  forEach(<span class="hljs-keyword">this</span>.items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
    self.total += item;
  });
};

order.updateTotal();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Total using &#39;self&#39;: &quot;</span> + order.total);

<span class="hljs-comment">// Change the updateTotal method to solve the problem using &#39;bind&#39;</span>
order.updateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.total = <span class="hljs-number">0</span>;

  forEach(<span class="hljs-keyword">this</span>.items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
    <span class="hljs-keyword">this</span>.total += item;
  }.bind(<span class="hljs-keyword">this</span>));
};

order.updateTotal();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Total using &#39;bind&#39;: &quot;</span> + order.total);

<span class="hljs-comment">// Change the updateTotal method to solve problem by passing &#39;this&#39;</span>
<span class="hljs-comment">// to forEach</span>
<span class="hljs-comment">// This solution requires updating our forEach function itself and isn&#39;t</span>
<span class="hljs-comment">// always an option</span>

<span class="hljs-comment">// Update forEach to take a 3rd parameter, which is what &#39;this&#39; should</span>
<span class="hljs-comment">// be bound to</span>
forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">items, callback, whatThisShouldBe</span>) </span>{
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; items.length; i++) {
    callback.call(whatThisShouldBe, items[i]);
  }
};

<span class="hljs-comment">// Update updateTotal to pass it the order object</span>
order.updateTotal = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">this</span>.total = <span class="hljs-number">0</span>;

  forEach(<span class="hljs-keyword">this</span>.items, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
    <span class="hljs-keyword">this</span>.total += item;
  }, <span class="hljs-keyword">this</span>);
};

order.updateTotal();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;Total using update to forEach: &#39;</span> + order.total);


<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// JQUERY</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>

<span class="hljs-comment">// things to keep in mind:</span>
<span class="hljs-comment">// css and images will load up to 6 in parl</span>
<span class="hljs-comment">// js will only load in order, once after another</span>
<span class="hljs-comment">// because obviously some things depend on other things</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
.find <span class="hljs-comment">// finds all below</span>
.children <span class="hljs-comment">// finds only direct immediate descendant</span>
<span class="hljs-comment">// this is like nesting in css selectors, basically</span>


<span class="hljs-comment">// dragndrop in jquery:</span>

.on(<span class="hljs-string">&#39;mousedown&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  isPressed = <span class="hljs-literal">true</span>;
}

.on(<span class="hljs-string">&#39;mouseup&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  isPressed = <span class="hljs-literal">false</span>;
})

.on(<span class="hljs-string">&#39;mouseenter&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">if</span>(isPressed) {
    $(<span class="hljs-keyword">this</span>).addClass(color);
  }
})

<span class="hljs-comment">// assuming we&#39;re using that paint example, obvs.</span>

<span class="hljs-comment">// notes on localstorage:</span>
localStorage.setItem(<span class="hljs-string">&#39;key&#39;</span>, <span class="hljs-string">&#39;value&#39;</span>); ==
localStorage.key = <span class="hljs-string">&#39;value&#39;</span>; ==
localStorage[<span class="hljs-string">&#39;key&#39;</span>] = <span class="hljs-string">&#39;value&#39;</span>;

<span class="hljs-keyword">return</span> localStorage.key; ==
<span class="hljs-keyword">return</span> localStorage.getItem(<span class="hljs-string">&#39;key&#39;</span>); ==
<span class="hljs-keyword">return</span> localStorage[<span class="hljs-string">&#39;key&#39;</span>];

<span class="hljs-keyword">delete</span> localStorage.key also works.
;;;;;;;;

<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// AJAX THINGS</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// make data</span>
<span class="hljs-comment">// change data</span>
<span class="hljs-comment">// check data</span>
<span class="hljs-comment">// move data</span>
<span class="hljs-comment">// delete data</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// is there anything else in an application but these five things?</span>
<span class="hljs-comment">// this is a dare, from jeremy. hmmmmmmmmmmm.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// notes: jeremy says to not store drug money data on PCs xD</span>
<span class="hljs-comment">// (because everything is data, data, data, data, data)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Create - POST</span>
<span class="hljs-comment">// Read    - GET</span>
<span class="hljs-comment">// Update - PUT</span>
<span class="hljs-comment">// Delete - DELETE</span>
<span class="hljs-comment">//</span>
<span class="hljs-keyword">var</span> ajaxParams = {
  method: <span class="hljs-string">&#39;GET&#39;</span>,
  url: <span class="hljs-string">&#39;<a href="http://zacanger.com/blog/feed.rss">http://zacanger.com/blog/feed.rss</a>&#39;</span>,
}


$.ajax(ajaxParams).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>{

})

<span class="hljs-comment">// cyclomatic complexity</span>
<span class="hljs-comment">// more things you&#39;re doing</span>
<span class="hljs-comment">// more bugs</span>
<span class="hljs-comment">//</span></code></pre>]]></description><link>/2016/notes-from-devmountain-02.html</link><guid isPermaLink="true">/2016/notes-from-devmountain-02.html</guid><category><![CDATA[devmtn]]></category><category><![CDATA[js]]></category><category><![CDATA[css]]></category><category><![CDATA[angular]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 18:35:00 GMT</pubDate></item><item><title><![CDATA[NOTES FROM DEVMOUNTAIN]]></title><description><![CDATA[<p>This is going to be a crapton of my notes, from when I was going through the course at DevMountain.</p>
<p>Looking back over these, a lot of them are dumb. What I mean by this is that my opinions on things were dumb.</p>
<p>Whatever.</p>
<p>Don&#39;t take it all so seriously. Some of it could be really helpful. This is about half of my collected
notes <em>that were inside project files</em>. Everything else has already been cleaned up and posted, or is in
a directory of drafts somewhere. This stuff is totally unedited.</p>
<hr>
<h2 id="ng-probs">ng probs</h2>
<pre class="hljs"><code><span class="hljs-comment">// this is in a <code>.then</code>. NOTE THAT ANGULAR WILL GIVE YOU AN OBJECT EVEN IF YOU HAVE AN ARRAY</span>
<span class="hljs-comment">// though it will give you your <em>objects</em> in the <em>array</em> that they come in, it&#39;ll still work</span>
<span class="hljs-comment">// on the front end.</span>
<span class="hljs-comment">// we were having issues here looping over the array and setting the returned index on scope,</span>
<span class="hljs-comment">// then trying to return that. this works a lot better.</span>
.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(stuff)</span></span>{
  <span class="hljs-variable">$scope</span>.foo = stuff
  <span class="hljs-variable">$scope</span>.things = stuff.StuffToBringBack
})</code></pre><hr>
<h2 id="angular-directives">angular: directives</h2>
<p>directives are different than controllers and services. directives ALWAYS return an object. when you write a
ctrl or svc you&#39;re giving some definitions to something that already exists. with directives you&#39;re closer
to writing routing. you&#39;re writing a set of instructions. they return an object. objects get, obviously,
key-value pairs.</p>
<pre class="hljs"><code><span class="hljs-class">.directive</span>(<span class="hljs-string">&#39;myDirective&#39;</span>, <span class="hljs-function">function</span>(){
  <span class="hljs-tag">return</span> {
    <span class="hljs-attribute">template</span>: <span class="hljs-string">&#39;Key: Value, key: value&#39;</span>;
  }
})</code></pre><p>directive names MUST be camelCase. pascal case will not be recognized. nor snake case?</p>
<p>i mean, really, it&#39;s all made a lot more complicated than it needs to be. we&#39;re starting out basically
just making our own little bits. it makes sense. if it works as a template file, or as just regular html,
it&#39;ll work as a custom directive. just more reusable as a directive.</p>
<p>we could have a directive with a TYPE. imagine a function that returns a customer with an attribute that&#39;s
.type... so we&#39;d have a directive called myCustomer, type=&quot;name&quot;, then another, type=&quot;smoking habits&quot;.
paramaters here are always (element, attribute).</p>
<p>Restrict as a property: E means element (so you&#39;d do <myDirective> instead of <div myDirective>
A is attribute, so it&#39;d be <div myDirective>
can do BOTH so it&#39;d work for either. (restrict: EA)
C is for class, but let&#39;s not do that! That seems like a really not okay and very bad idea.
This is basically for semantic enforcement. Element would be good for a custom block, eg</p>
<p><myDirective>a whole bunch of shit just about this one</myDirective></p>
<p><mySECONDdirective>another whole bunch</mySECONDdirective> etc
A would be good for tacking things onto elements that would likely be there anyway, it seems.
If you need to take in parameters, A would be better.</p>
<p>custom filters like this!</p>
<pre class="hljs"><code>&lt;input model=<span class="hljs-string">&quot;whatcha&quot;</span>&gt;
&lt;span custom=<span class="hljs-string">&quot;format&quot;</span>&gt;
<span class="hljs-keyword">function</span> link(scope, <span class="hljs-literal">element</span>, attributes){
var whatever
stuffings
}
<span class="hljs-keyword">return</span> { link: link; }
scp.<span class="hljs-variable">$watch</span>(<span class="hljs-string">&#39;format&#39;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-keyword">value</span>){
format=value;
updateTime();
});</code></pre><p>link ALWAYS takes in at leaste those three, and alkways in that order!</p>
<p>inside a directive, feel free to do some jquery-lite.
if you want to use, say, d3, or three.js, you can go ahead and inject that into angular
and use it. (we&#39;re talking about other DOM manupilation, not utilities like lodash).</p>
<p>inside a link whatever, that scp refers to its parent&#39;s scope, it shares parent&#39;s scope
by default. eg if custom up there is directly below mainCtrl, scp means mainCtrl&#39;s $scope.</p>
<p>underneath .directive, the scope: { stuff } actually means, like, scope INSTRUCTIONS or
somesuch.</p>
<p>SCOPE</p>
<pre class="hljs"><code><span class="hljs-tag">scope</span>: {
<span class="hljs-attribute">string</span>: <span class="hljs-string">&#39;@&#39;</span>,
<span class="hljs-attribute">link</span>: <span class="hljs-string">&#39;=&#39;</span>,
<span class="hljs-attribute">func</span>: <span class="hljs-string">&#39;&amp;&#39;</span>
}</code></pre><p>The properties on the scope object represent the attributes on the directive in the html. Our example scope object here would look something like this in the html.
<code>&lt;example-directive string=&quot;a string&quot; link=&quot;user&quot; func=&quot;updateUser()&quot;&gt;&lt;/example-directive&gt;</code>
The hard part here is the <code>@</code>, <code>=</code>, and <code>&amp;</code>. They each have very important and distinct meanings.</p>
<ul>
<li><code>@</code> says take in my attribute value as a string.</li>
<li><code>=</code> says take in my attribute value as a two-way bound variable from the parent scope.</li>
<li><p><code>&amp;</code> says take in my attribute value as a reference to a function on the parent scope.</p>
</li>
<li><p>(from another notes snippet):</p>
<ul>
<li><code>@</code> : string/text (one-way)</li>
<li><code>=</code> : two-way</li>
<li><code>&amp;</code> : binds parent scope&#39;s methods into directive&#39;s scope</li>
<li><code>&lt;</code> : one-way (outer-to-inner)</li>
</ul>
</li>
</ul>
<hr>
<h2 id="firebase">firebase</h2>
<p>firebase with $firebaseObject (or $firebaseArray) and $bindTo just makes all
the <strong>MAGIC</strong> (that we poor slobs are are too dumb to even vaguely comprehend)
even MORE magical; with angularfire and firebase and angular doing everything
for you, we now have, basically, a subpar meteor-like 3-way-binding.</p>
<p><code>&lt;ng-change=&quot;$scope.save(thingy)&quot;&gt;</code> will propogate back to firebase
(or <code>&lt;ng-change=&quot;thingy(save)&quot;&gt; // $scope.sav(thingy)</code> if we&#39;re doing things
modularly).</p>
<p><code>ng-model-options=&quot;{debounce: {&#39;default&#39;: 5000}}&quot; // debounces. to 5000 ms. wowe.</code></p>
<hr>
<h2 id="express">express</h2>
<ul>
<li>if chain in express:</li>
<li>method, url, callback</li>
<li><code>app.all(&#39;/endpoint&#39;, function(){console.log(&#39;a thing&#39;)})</code></li>
<li>so it&#39;s one long chain of if statements. like we do manually. that&#39;s all.</li>
<li>express chain [{method: &#39;all&#39;, endpoint:&#39;/endpoint&#39;, function(){}, {method: &#39;get&#39;, endpoint:&#39;/nextone&#39;}etc etc etc etc}]d</li>
<li>all endpoints are hit, with exception dependent on response</li>
<li>req and res are passed to EVERY function by express</li>
<li>ongoing request and response are passed on down whole if statement chain</li>
<li>a controller can&#39;t reference arrays from another file.<ul>
<li>so, your server (or, let&#39;s say, your index) couldn&#39;t have something defined that a ctrl needs to access<ul>
<li>(assuming your ctrl is set up as a an object, module.exports = {} with your functions(req, res, next) all in there.)</li>
</ul>
</li>
<li>solution?</li>
<li>move your stuff into the file where you want to access it, i guess.</li>
<li>module.exports can be an array, too. that makes sense in a db context, okay.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="express-more">express more</h2>
<h4 id="req-params-vs-req-query">req.params vs req.query</h4>
<ul>
<li>Params and Query do the same thing.</li>
<li>Params is hardcoded into endpoint; query allows some flexibility.</li>
<li>Query uses <a href="http://url.url/api/endpoint?whatever=something">http://url.url/api/endpoint?whatever=something</a></li>
<li>Param would be more like <a href="http://url.url/api/endpoint/something">http://url.url/api/endpoint/something</a></li>
</ul>
<pre class="hljs"><code>app.get(<span class="hljs-string">&#39;api/hobbies/:type/:fun&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span></span>{
  req.params.<span class="hljs-built_in">type</span> // boring
  hobbies.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(hobby)</span></span>{
    <span class="hljs-keyword">if</span> (hobby.<span class="hljs-built_in">type</span> = req.params.<span class="hljs-built_in">type</span>) {
      res.send(hobby)
    }
  })
});

localhost:<span class="hljs-number">8989</span>/api/hobbies/boring/no

app.get(<span class="hljs-string">&#39;api/hobbies&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span></span>{
  req.query.<span class="hljs-built_in">type</span> // boring
  hobbies.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(hobby)</span></span>{
    <span class="hljs-keyword">if</span> (hobby.<span class="hljs-built_in">type</span> = req.query.<span class="hljs-built_in">type</span>) {
      res.send(hobby)
    }
  })
})

localhost:<span class="hljs-number">8989</span>/api/hobbies?<span class="hljs-built_in">type</span>=boring&amp;fun=no

var hobbies = [];</code></pre><h4 id="how-to-not-need-to-use-express-cors-or-whatever-cors-">how to not need to use express-cors (or whatever-cors)</h4>
<pre class="hljs"><code><span class="hljs-keyword">var</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#39;express&#39;</span>);
<span class="hljs-keyword">var</span> request = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#39;request&#39;</span>);

<span class="hljs-keyword">var</span> app = express();
app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&#39;/&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-keyword">var</span> url = apiServerHost + req.url;
  req.pipe(request(url)).pipe(res);
});

app.listen(process.env.PORT || <span class="hljs-number">3000</span>);</code></pre><p>OBVIOUSLY this only applies when everything&#39;s local; this is a proxy server, essentially, sort of.</p>
<p>also there&#39;s an express builtin: <code>app.use(express.static()</code>, eg <code>app.use(express.static(&#39;public&#39;))</code></p>
<h4 id="monogooooooooooo-se-">monogooooooooooo(se)</h4>
<p>Turns out if you send Mongoose anything that&#39;s not in your schema, it&#39;s just like &quot;Oh, okay, I&#39;m not interested&quot; and tosses that bit out, I guess.</p>
<p>When we&#39;re not doing eg <code>require(&#39;./path&#39;)</code> (but rather <code>require(/path)&#39; with no dot first</code>), it looks in <code>node_modules/</code>. Obvs usually we&#39;ll probably look from cwd instead. Any way to look from project root by default?</p>
<pre class="hljs"><code>getStuff: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span>{</span>
  <span class="hljs-transposed_variable">Stuff.</span>find().populate(<span class="hljs-string">&#39;things.whatevers&#39;</span>).exec()
    .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data, err)</span></span>
<span class="hljs-comment">// etc., etc., etc., etc.</span></code></pre><hr>
<h2 id="ionic">ionic</h2>
<ul>
<li>We&#39;re getting a little super-fast (read: unplanned and, I think, unannounced) rundown on Ionic.</li>
<li>Which is totally fine, but it&#39;s basically Angular, plus Phonegap, which are two things I rather dislike.</li>
<li>Okay, I&#39;m using the Yeoman generator-ionic-gulp seed.</li>
<li>Aaaaand this is just like Angular, except with predefined CSS rules, basically.</li>
<li>The &#39;magic&#39; is all in the bit where it handles compiling/wrapping for you.</li>
<li>So... on with my personal project, I suppose.</li>
</ul>
<hr>
<h2 id="d3">D3</h2>
<ul>
<li>svg starts 0,0 top left, not bottom left.</li>
<li>svg has no z-index. just renders in order it&#39;s written.</li>
<li>rotations and transforms on svg will screw with things when it comes to moving stuff!</li>
<li>d3, chaining methods super common.</li>
</ul>
<hr>
<h2 id="react">react</h2>
<ul>
<li>react is reacty. it reacts, sometimes reactively.</li>
<li>it&#39;s still ugly as hell and i hope it dies, though.</li>
<li>note that i&#39;m doing all this in vim because:<ul>
<li>A. lighttable doesn&#39;t like react and</li>
<li>B. lighttable has my projects loadded up, currently, and i don&#39;t want to add yet another workspace.</li>
</ul>
</li>
<li>so, this will probably all be formatted like shit, because vim doesn&#39;t understand, no matter how many times i tell it, that i don&#39;t want it to turn spaces into tabs, i want the opposite.</li>
<li>oh well.</li>
</ul>
<hr>
<h2 id="s3">S3</h2>
<ul>
<li>Basically, since Mongo can&#39;t store images without doing difficult-ish things involving GridFS,
the prescription is to use S3 in... basically the same way, actually, which results in more total requests,
but the hope is that Amazon&#39;s caching or somesuch is good enough to offset the latency.</li>
<li>Amazon needs your regional server to be passed in during requests. Which is both sensible and silly, since really that should be a part of your keys.</li>
<li>When Amazon wants a &#39;Key&#39; in your paramss, that&#39;s not a key. That&#39;s the actual thing you&#39;re fuckin&#39; with. so, req.body.img.</li>
<li>Buffers in node are bytes in python are strings in PHP if they were mutable.</li>
</ul>
<hr>
<h2 id="deployment-while-in-development">deployment while in development</h2>
<h3 id="heroku">heroku</h3>
<ul>
<li>workflow: have a project. have a git repo in it. <code>heroku create</code>, assuming you use/have heroku.</li>
<li>(same as <code>git remote add heroku https://someurl.herokuapp.com</code>)</li>
</ul>
<h3 id="digital-ocean">digital ocean</h3>
<ul>
<li>digital ocean: works the same as ever, which is to say, it&#39;s not convenient,
but it it&#39;s okay. prefer koding if they let me back in, but if not,
maybe using codeanywhere/codenvy/c9/any one of the other IDEs with built in dev servers.</li>
</ul>
<hr>
<p>...that&#39;s all, for now. There will probably be more, once I sort through the first three weeks&#39; worth of shit.</p>
<p>tags: notes, devmountain, lol, i-am-ridiculous, directives, angular, firebase, express, mongo, mongoose, node, ionic, d3, react, heroku, digital-ocean</p>
]]></description><link>/2016/notes-from-devmountain-01.html</link><guid isPermaLink="true">/2016/notes-from-devmountain-01.html</guid><category><![CDATA[devmtn]]></category><category><![CDATA[notes]]></category><category><![CDATA[js]]></category><category><![CDATA[css]]></category><category><![CDATA[angular]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 18:30:00 GMT</pubDate></item><item><title><![CDATA[Promises]]></title><description><![CDATA[<p>Important things:</p>
<ul>
<li>The actual promise is immutable (nothing can change that)</li>
<li>There&#39;s a guarantee that we&#39;ll get something back</li>
<li>Usually create a promise with a constructor (<code>new Promise</code>)</li>
<li>Usually its two handlers are named <code>resolve</code> and <code>reject</code></li>
<li>A promise will have one of three states:<ul>
<li>Pending (until something happens)</li>
<li>Fulfilled (if the first handler is called)</li>
<li>Rejected (if the second handler is called)</li>
</ul>
</li>
<li>It can only be &#39;settled&#39; (either resolved or rejected) once.</li>
<li>Can&#39;t cancel a promise.</li>
<li>No way to check the status (if pending, fulfilled, or rejected).</li>
<li>An immediately-resolved promise can be created like <code>Promise.resolve(&#39;something&#39;)</code>.</li>
<li>An immediately-rejected promise can be created like <code>Promise.reject(&#39;something&#39;)</code>.</li>
<li>Attach a <code>then()</code> to consume the promise.</li>
<li><code>.then</code> takes a callback that gets passed the resolved value, on fulfillment.</li>
<li>It can actually take a rejection callback too.</li>
<li>You can pass in <code>null</code> instead of the first one, which is the same as just doing a <code>.catch()</code>.</li>
<li>You can chain <code>.then()</code>s.</li>
<li>You SHOULD use <code>.catch()</code> instead of the <code>.then(null, cb)</code> style.</li>
<li>This way you can chain multiple <code>then</code>s and then have a final <code>catch</code>.</li>
<li><code>throw</code>ing will automatically reject that promise.</li>
<li><code>Promise.all()</code> takes arr of promises; once all are fulfilled, it returns arr of fulfilled values.<ul>
<li>Otherwise (if any are rejected) it will reject.</li>
</ul>
</li>
<li><code>Promise.race()</code> is similar, but will fulfill once first promise in the array fulfills.</li>
<li>Don&#39;t program with promises using same patterns as with callbacks.<ul>
<li>(Don&#39;t do a <code>.then(fn(res), fn(err))</code>; use <code>.then().catch()</code>.)</li>
</ul>
</li>
<li>Don&#39;t nest promises. Use a <code>.all</code> instead.</li>
</ul>
<p>Examples:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
  <span class="hljs-keyword">if</span> (something) {
    resolve(value)
  } <span class="hljs-keyword">else</span> {
    reject(reason)
  }
})

<span class="hljs-keyword">const</span> p = Promise.resolve(<span class="hljs-string">&#39;something&#39;</span>)
p.then(res =&gt; console.log(res))
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(<span class="hljs-string">&#39;asdf&#39;</span>), <span class="hljs-number">2000</span>)
})
p2.then(res =&gt; {
  res += <span class="hljs-string">&#39;ghjkl;&#39;</span>
  console.log(res)
})
p2.then(res =&gt; console.log(res)) <span class="hljs-comment">// this is still &#39;asdf&#39;</span>

somePromise.then(
  val =&gt; console.log(<span class="hljs-string">&#39;fulfilled&#39;</span>, val)
, err =&gt; console.error(<span class="hljs-string">&#39;rejected&#39;</span>, err))

pr.then(val =&gt; console.log(<span class="hljs-string">&#39;fulfilled&#39;</span>, val))
  .then(<span class="hljs-keyword">null</span>, err =&gt; console.error(<span class="hljs-string">&#39;rejected&#39;</span>, err))

<span class="hljs-keyword">const</span> throwProm = <span class="hljs-keyword">new</span> Promise((res, rej) =&gt; {
  <span class="hljs-keyword">if</span> (something) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#39;rejected&#39;</span>)
  } <span class="hljs-keyword">else</span> {
  resolve(stuff)
  }
})
throwProm
.then(val =&gt; val + <span class="hljs-number">8</span>)
.then(val =&gt; console.log(<span class="hljs-string">&#39;hey&#39;</span>, val))
.<span class="hljs-keyword">catch</span>(err =&gt; console.error(<span class="hljs-string">&#39;err&#39;</span>, err.message))

<span class="hljs-keyword">const</span> fulProm = <span class="hljs-keyword">new</span> Promise((res, rej) =&gt; res(<span class="hljs-number">8</span>))
fulProm
.then(val =&gt; val + <span class="hljs-number">8</span>)
.then(val =&gt; {<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#39;failure&#39;</span>)})
.then(val =&gt; console.log(<span class="hljs-string">&#39;yay&#39;</span>, val))
.<span class="hljs-keyword">catch</span>(err =&gt; console.error(<span class="hljs-string">&#39;error&#39;</span>, err.message))

one()
.then(res =&gt; Promise.all([res, two(res)]))
  .then(results =&gt; <span class="hljs-comment">/<em> stuff </em>/</span>)
  .<span class="hljs-keyword">catch</span>(err =&gt; <span class="hljs-comment">/<em> handle err </em>/</span>)</code></pre>]]></description><link>/2016/promises.html</link><guid isPermaLink="true">/2016/promises.html</guid><category><![CDATA[promises]]></category><category><![CDATA[es6]]></category><category><![CDATA[es2015]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 18:00:00 GMT</pubDate></item><item><title><![CDATA[Creating A React Component]]></title><description><![CDATA[<p>Okay so basically React changes like every two weeks and it&#39;s really tough to know which way to do which thing.</p>
<p>So. Which way should you create a freaking component? These notes are more for myself than anyone else.</p>
<p>Use a class if you need <code>this</code> or lifecycle methods. (An ES6 class. <code>class foo extends React.Component</code>.)</p>
<p>So, <code>this</code> actually refers to that <code>ReactComponent</code>.</p>
<p>If you can use a function, <em>use one</em>.</p>
<p>This refers to a &#39;stateless functional component.&#39;</p>
<p>These are, basically, pure functions. Which are basically <strong>always</strong> a good thing.</p>
<p>Don&#39;t use <code>React.createClass</code>, basically ever. Use <code>React.Component</code> instead.</p>
<p>So basically, use a function if you possibly can. Otherwise use <code>class bar extends React.Component</code>.</p>
<p>That was easy.</p>
]]></description><link>/2016/react-which.html</link><guid isPermaLink="true">/2016/react-which.html</guid><category><![CDATA[react]]></category><category><![CDATA[es6]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 17:42:00 GMT</pubDate></item><item><title><![CDATA[This is a test]]></title><description><![CDATA[<h1 id="this-is-a-test-">This is a test!</h1>
<p>I&#39;m testing out a little thing called <a href="https://github.com/mixu/ghost-render">ghost-render</a>.</p>
<p>I&#39;ve been needing a new blog engine. Maybe this one will do.</p>
]]></description><link>/2016/test.html</link><guid isPermaLink="true">/2016/test.html</guid><category><![CDATA[test]]></category><category><![CDATA[blogging]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 17:39:25 GMT</pubDate></item></channel></rss>