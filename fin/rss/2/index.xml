<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[angr]]></title><description><![CDATA[writings from zac anger]]></description><link>http://blog.zacanger.com/</link><generator>Ghost</generator><lastBuildDate>Sat, 05 Aug 2017 19:29:38 GMT</lastBuildDate><atom:link href="http://blog.zacanger.com/rss/index.xml" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[building command-line apps in node (a note-taking app)]]></title><description><![CDATA[<h1 id="build-a-note-taking-app-for-the-terminal-in-node">Build a Note-Taking App for the Terminal, in Node</h1>
<p>This is a follow-up to my <a href="blog.zacanger.com/2016/a-basic-cli-app-in-node.html">first
post</a> on writing
command-line apps in Node. I suggest you read that first, but this post should
stand on its own if you don&#39;t want to. Below is the little React component
generator that you&#39;d get if you follow that tutorial.</p>
<pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env node</span>

<span class="hljs-keyword">const</span> type = process.argv[<span class="hljs-number">2</span>]
<span class="hljs-keyword">const</span> component = process.argv[<span class="hljs-number">3</span>]
<span class="hljs-keyword">const</span> { writeFile } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;fs&#39;</span>)

<span class="hljs-keyword">const</span> help = () =&gt;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`</span>
  please pass component type <span class="hljs-keyword">and</span> component name
  <span class="hljs-attribute">example</span>: ./rcg.js <span class="hljs-keyword">function</span> Foo
<span class="hljs-string">`)</span>

<span class="hljs-keyword">if</span> (!component || !type) {
  <span class="hljs-keyword">return</span> help()
}

<span class="hljs-keyword">const</span> pureComponent = <span class="hljs-string">`</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>

<span class="hljs-keyword">const</span> ${component} = () =&gt; &lt;div&gt;${component}&lt;/div&gt;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ${component}
<span class="hljs-string">`.trim()</span>

<span class="hljs-keyword">const</span> classComponent = <span class="hljs-string">`</span>
<span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">$</span>{<span class="hljs-title">component</span>} <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> {</span>
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;${component}&lt;/div&gt;
    )
  }
}
<span class="hljs-string">`.trim()</span>

<span class="hljs-keyword">const</span> doTheThing = kind =&gt; (
  writeFile(<span class="hljs-string">`${component}.js`,</span> kind, <span class="hljs-string">&#39;utf8&#39;</span>, err =&gt; {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.log(err)
  })
)

<span class="hljs-keyword">switch</span> (type) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">&#39;function&#39;</span>:
    doTheThing(pureComponent)
    <span class="hljs-keyword">break</span>
  <span class="hljs-keyword">case</span> <span class="hljs-string">&#39;class&#39;</span>:
    doTheThing(classComponent)
    <span class="hljs-keyword">break</span>
  <span class="hljs-attribute">default</span>:
    <span class="hljs-keyword">return</span> help()
}</code></pre><hr>
<h2 id="introduction">Introduction</h2>
<p>I really love writing little command-line utilities in Node. There are other
languages that may be better for this (Bash, Ruby, Perl), but Node is just more
<em>fun</em> than those (at least to me). I especially love trying to do simple little
tools with no dependencies, or wrapping up awesome modules to be used in your
terminal. The majority of <a href="https://www.npmjs.com/~zacanger">my published modules</a>
are little tools like this. A lot of folks only think of Node as the thing that
runs Express, or the thing that lets them test their code without a browser, or
whatever, though. So, this will be a short tutorial on writing a command-line
app in Node. At the end of it, you&#39;ll have a totally awesome little app for
taking notes in JSON. The full version of this app (with a few adjustments and
additions) is <a href="https://www.npmjs.com/package/lilnote">here</a>, and you can
install it to use in your terminal with <code>npm i -g lilnote</code>.</p>
<p>Okay, so, let&#39;s do stuff!</p>
<h2 id="update-node">Update Node</h2>
<p>First things first&mdash;make sure Node and npm are up to date. If you&#39;re
already using at least versions 6 of node and 3 of npm (<code>node -v</code> and <code>npm -v</code>
to find out), you&#39;re fine. Otherwise, you really should update.</p>
<p>I recommend using <a href="https://www.npmjs.com/package/n">n</a> for this. If you already
use NVM, go with that; if you&#39;re on Windows, you&#39;ll likely have to go download
the new version and manually install it. Otherwise, just <code>npm i -g n &amp;&amp; n latest
&amp;&amp; npm i -g npm@next</code> (you can leave out the last bit, but it&#39;s nice to have the
newest version of the coolest tools).</p>
<h2 id="start-a-project">Start a Project</h2>
<p>Make a new directory and start a project (<code>mkdir note-taking-app</code>, <code>cd
note-taking-app</code>, <code>npm init</code>, <code>touch index.js</code>, and <code>chmod +x index.js</code> to make
it executable).</p>
<p>You won&#39;t need any dependencies here; the <code>npm init</code> isn&#39;t vital, but if you
later wanted to add dependencies, publish this (please don&#39;t unless it&#39;s
significantly different from <a href="https://npmjs.com/package/lilnote">lilnote</a>!), or
something, it&#39;d be nice to just have this already set up.</p>
<p>If you want, you can add some fields to your <code>package.json</code> to specifiy that
it&#39;s a global, command-line sort of app. Add <code>&quot;preferGlobal&quot;: true</code> and <code>&quot;bin&quot;:
&quot;./index.js&quot;</code> for this.</p>
<h2 id="write-some-code">Write Some Code</h2>
<p>Open the <code>index.js</code> in your editor.</p>
<p>The first thing you&#39;ll need to write is the shebang. This is to let your shell
know how to execute this file. For a Node script, it should read <code>#!/usr/bin/env
node</code>. Any time you&#39;re writing an executable script, this goes on the first
line. You&#39;ll use a similar thing for any language you&#39;d use (for example,
<code>#!/bin/bash</code> for a Bash script, or <code>#!/usr/bin/ruby</code> for a Ruby script&mdash;
the <code>env</code> bit says &#39;find out what my computer thinks Node is, and execute that
script with that thing&#39;&mdash;it&#39;s the same idea as doing <code>which node index.js</code>).</p>
<p>We&#39;re going to require some stuff. If you happen to be using <code>babel-node</code> or
using <code>babel-register</code> you could use <code>import</code>s here, but we&#39;ll go with
<code>require</code>s because this means we can keep our app dependency-free.</p>
<p>Add <code>&#39;use strict&#39;</code> to the next line. You don&#39;t <em>have</em> to do this, <a href="https://www.nczonline.net/blog/2012/03/13/its-time-to-start-using-javascript-strict-mode">but you
should</a>.</p>
<p>We&#39;ll require just one thing to start with: <code>fs</code>, which is built in to Node.</p>
<p>Our file should currently look like this:</p>
<pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env node</span>

<span class="hljs-string">&#39;use strict&#39;</span>

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;fs&#39;</span>)</code></pre><p>Our app is going to read input from the terminal, so we&#39;ll need to use the
built-in <code>process</code>. This provides an <code>argv</code>, which is an &#39;argument
vector&#39;&mdash;an array of all things entered on the command-line, which will
always start with <code>node</code> and the file that&#39;s being run. So, we&#39;ll use
<code>process.argv[2]</code>, which will be the first manually entered argument. Sidenote:
<code>process</code> is an awesome piece of Node, and if you&#39;re not familiar with it, open
a REPL (just enter <code>node</code> in the terminal) and type in <code>process</code>, and skim
through that gigantic object.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> arg = process.argv[<span class="hljs-number">2</span>]</code></pre><p>Parsing arguments is tedious and sometimes difficult. There are a
<a href="https://github.com/tj/commander.js">lot</a> of
<a href="https://github.com/substack/minimist">awesome</a>
<a href="https://www.npmjs.com/package/yargs">modules</a> that exist for this, and if you
keep building cli apps in Node you should definitely investigate these, but for
this tutorial we&#39;ll parse options manually. In the same way that you should know
how HTTP works and then maybe use <a href="http://koajs.com">Koa</a> or
<a href="http://hapijs.com">hapi</a>, you should know how arguments work before deciding on
a library to handle them.</p>
<p>We&#39;ll need a couple of other things before we can really get going. We should
probably do something with that <code>fs</code> module&mdash;let&#39;s use it to specify a
piece of JSON we&#39;ll work against. I won&#39;t get into how to handle what happens if
that file doesn&#39;t already exist here, but you can check out <a href="https://github.com/zacanger/lilnote/blob/master/check-file.js#L10">lilnote&#39;s source
code</a> if
you&#39;re curious. For our purposes, you should <code>touch notes.json</code> in the same
directory as your app, and put an empty array (<code>[]</code>) in there. (Note: <code>lilnote</code>
uses a file under the user&#39;s home directory; that&#39;s another thing we won&#39;t worry
about right now, but it&#39;s <a href="https://github.com/zacanger/lilnote/blob/master/check-file.js#L10">pretty
easy</a> to do.)</p>
<p>Let&#39;s add another couple of declarations:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">n</span> = &#39;./<span class="hljs-keyword">notes</span>.json&#39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">file</span> = fs.readFileSync(<span class="hljs-keyword">n</span>)</code></pre><p>We&#39;ll also have a variable here for our read-in notes.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-keyword">notes</span> = JSON.<span class="hljs-keyword">parse</span>(<span class="hljs-keyword">file</span>)</code></pre><p>And since we&#39;ll be using <code>console.log</code> in a few places, let&#39;s just make that a
little shorter:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-built_in">log</span> = console.<span class="hljs-built_in">log</span></code></pre><p>Your file should now look something like this:</p>
<pre class="hljs"><code>#!/usr/bin/env node

&#39;<span class="hljs-keyword">use</span> strict&#39;

<span class="hljs-keyword">const</span> fs = require(&#39;fs&#39;)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">log</span> = console.<span class="hljs-literal">log</span>
<span class="hljs-keyword">const</span> arg = process.argv[2]
<span class="hljs-keyword">const</span> <span class="hljs-keyword">n</span> = &#39;./<span class="hljs-keyword">notes</span>.json&#39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">file</span> = fs.readFileSync(<span class="hljs-keyword">n</span>)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">notes</span> = JSON.<span class="hljs-keyword">parse</span>(<span class="hljs-keyword">file</span>)</code></pre><p>And your file structure should look something like:</p>
<pre class="hljs"><code>project-root
  package<span class="hljs-class">.json</span>
  index<span class="hljs-class">.js</span>
  notes.json</code></pre><h2 id="make-it-do-things">Make It Do Things</h2>
<p>So let&#39;s do stuff! First let&#39;s make a way to record notes taken. This will work
by just calling your script and treating the first argument as a note.</p>
<pre class="hljs"><code>./index<span class="hljs-class">.js</span> <span class="hljs-string">&quot;go to the grocery store&quot;</span>
./index<span class="hljs-class">.js</span> cook
./index<span class="hljs-class">.js</span> eat
./index<span class="hljs-class">.js</span> <span class="hljs-string">&quot;wash dishes&quot;</span></code></pre><p>Let&#39;s write a function for this.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> takeNote = (<span class="hljs-keyword">notes</span>, <span class="hljs-keyword">note</span>) =&gt; {
  <span class="hljs-keyword">notes</span>.push(<span class="hljs-keyword">note</span>)
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}</code></pre><p>Note that we&#39;re using function expressions, not function declarations. This
could also be written as:</p>
<pre class="hljs"><code>function takeNote (<span class="hljs-keyword">notes</span>, <span class="hljs-keyword">note</span>) {
  <span class="hljs-keyword">notes</span>.push(<span class="hljs-keyword">note</span>)
  <span class="hljs-keyword">var</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">file</span>, taken, &#39;utf8&#39;, function(<span class="hljs-keyword">err</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
    }
  })
}</code></pre><p>These extra parameters to <code>JSON.stringify()</code> make our JSON look decent. Check
out the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">docs on
MDN</a>
if you&#39;re not familiar with them.</p>
<p>We&#39;re taking in the array of notes and a note, and pushing that note to the
array of notes. Then we&#39;re using <code>writeFile()</code> from <code>fs</code> to write to the <code>file</code>
we declared earlier, using the <code>taken</code> we declared earlier, with the encoding
<code>UTF-8</code>. The callback here is in case there&#39;s an error&mdash;if the file doesn&#39;t
already exist, for example.</p>
<p>We should handle this function where we process our command-line arguments,
which we&#39;ll get to in a little bit.</p>
<p>Let&#39;s also write a function for removing a note by its index in the array.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> removeNote = (<span class="hljs-keyword">notes</span>, noteIndex) =&gt; {
  <span class="hljs-keyword">notes</span>.splice(noteIndex -1, 1)
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}</code></pre><p>Awesome! That&#39;s like 90% of our app right there.</p>
<p>We should probably handle some arguments so we can actually use this thing.</p>
<h2 id="make-it-all-work">Make It All Work</h2>
<p>We&#39;re going to do this with a series of <code>if</code> statements. We could also use a
<code>switch</code> here, but for a lot of people that&#39;ll seem a little unfamiliar. Let&#39;s
assume that you&#39;ll use <code>-s</code> to show all notes, and <code>-r</code> to remove a note. We
should also handle a case where there are no arguments passed.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (!arg) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(&#39;Please pass <span class="hljs-keyword">an</span> argument&#39;)
}
<span class="hljs-keyword">if</span> (arg &amp;&amp; arg === &#39;-r&#39;) {
  <span class="hljs-keyword">const</span> noteIndex = process.argv[3]
  <span class="hljs-keyword">return</span> removeNote(<span class="hljs-keyword">notes</span>, noteIndex)
}
<span class="hljs-keyword">if</span> (arg &amp;&amp; arg === &#39;-s&#39;) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">notes</span>)
}
<span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">return</span> takeNote(<span class="hljs-keyword">notes</span>, arg)
}</code></pre><p>So, that&#39;s a basic way to handle command-line options. Let&#39;s just wrap that last
bit in a function and call it at the end. It&#39;s not beautiful, but if you put a
little bit of work into this, you could have a decent app! Here&#39;s how your whole
file should look, now:</p>
<pre class="hljs"><code>#!/usr/bin/env node

&#39;<span class="hljs-keyword">use</span> strict&#39;

<span class="hljs-keyword">const</span> fs = require(&#39;fs&#39;)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">log</span> = console.<span class="hljs-literal">log</span>
<span class="hljs-keyword">const</span> arg = process.argv[2]
<span class="hljs-keyword">const</span> <span class="hljs-keyword">n</span> = &#39;./<span class="hljs-keyword">notes</span>.json&#39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">file</span> = fs.readFileSync(<span class="hljs-keyword">n</span>)
<span class="hljs-keyword">const</span> <span class="hljs-keyword">notes</span> = JSON.<span class="hljs-keyword">parse</span>(<span class="hljs-keyword">file</span>)

<span class="hljs-keyword">const</span> takeNote = (<span class="hljs-keyword">notes</span>, <span class="hljs-keyword">note</span>) =&gt; {
  <span class="hljs-keyword">notes</span>.push(<span class="hljs-keyword">note</span>)
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}

<span class="hljs-keyword">const</span> removeNote = (<span class="hljs-keyword">notes</span>, noteIndex) =&gt; {
  <span class="hljs-keyword">notes</span>.splice(noteIndex -1, 1)
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  fs.writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}

<span class="hljs-keyword">const</span> runTheApp = () =&gt; {
  <span class="hljs-keyword">if</span> (!arg) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(&#39;Please pass <span class="hljs-keyword">an</span> argument&#39;)
  }
  <span class="hljs-keyword">if</span> (arg &amp;&amp; arg === &#39;-r&#39;) {
    <span class="hljs-keyword">const</span> noteIndex = process.argv[3]
    <span class="hljs-keyword">return</span> removeNote(<span class="hljs-keyword">notes</span>, noteIndex)
  }
  <span class="hljs-keyword">if</span> (arg &amp;&amp; arg === &#39;-s&#39;) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">notes</span>)
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> takeNote(<span class="hljs-keyword">notes</span>, arg)
  }
}

runTheApp()</code></pre><p>This isn&#39;t beautiful, but as with the last post, I&#39;ll leave it to you to clean
it up, handle funky cases, and whatnot. If you&#39;re having fun with this, check
back for my next post! Also, if you have any thoughts on fun command-line
projects in Node but aren&#39;t sure how to get started, hit me up <a href="https://twitter.com/zacanger">on
Twitter</a> and I&#39;ll see about writing something up!</p>
]]></description><link>/2016/note-taking-app.html</link><guid isPermaLink="true">/2016/note-taking-app.html</guid><category><![CDATA[node]]></category><category><![CDATA[cli]]></category><category><![CDATA[terminal]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 27 Aug 2016 02:45:00 GMT</pubDate></item><item><title><![CDATA[a basic command-line app in node]]></title><description><![CDATA[<p>I&#39;m going to walk through a super basic app in Node that you can
run in your terminal. I&#39;ve got a more in-depth tutorial coming up soon,
but wanted to get this idea out there tonight.</p>
<p><a href="http://ryanwalsh.io">Someone</a> brought up the idea of a React component
generator the other day, and I immediately thought <em>Bash script</em>. Well, that&#39;s
pretty easy.</p>
<pre class="hljs"><code><span class="hljs-shebang">#!/bin/bash
</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;
import React from &#39;react&#39;

const <span class="hljs-variable">$1</span> = () =&gt; (
  &lt;div&gt;<span class="hljs-variable">$1</span>&lt;/div&gt;
)

export default <span class="hljs-variable">$1</span>
&quot;</span> &gt; <span class="hljs-variable">$1</span>.js</code></pre><p>There you go, a basic pure component generator script. This could be a little
more complex, handle some content, handle generating a class instead of a
function, and whatever, but that&#39;s the basic idea, in Bash.</p>
<blockquote>
<p>Keep in mind, none of this is React-specific. All we&#39;re doing is handling
arguments and spitting out a file.</p>
</blockquote>
<p>The idea here is that you just call this script from somewhere and it gives you
a component already laid out for you. It&#39;s not too fancy, but it&#39;s useful.</p>
<pre class="hljs"><code>$ ./my-script.sh Foo

$ cat Foo.js

<span class="hljs-literal">import</span> React from <span class="hljs-string">&#39;react&#39;</span>

<span class="hljs-keyword">const</span> Foo = () =&gt; (
  &lt;div&gt;Foo&lt;/div&gt;
)

<span class="hljs-literal">export</span> <span class="hljs-keyword">default</span> Foo</code></pre><p>That could save a little bit of time. I use something similar for generating an
<code>index.html</code> for React apps.</p>
<p>This is a lot like using snippets in your editor, except it doesn&#39;t rely on you
having that editor and those snippets handy. You could pass this around to anyone
who uses any editor, on any computer, and get the same result. You could upload
it to somewhere and just <code>curl my-script.sh | bash</code> and not even need to have the
file around. Pretty handy, I think.</p>
<p>But... what about in JS? I mean, we&#39;re JavaScript devs, right?</p>
<p>It&#39;s still pretty straightforward in Node, as it happens.</p>
<p>We only need one file to get going. I&#39;ll call mine <del>compgen</del> rcg.js, for React
Component Generator.</p>
<blockquote>
<p>I apologize in advance, some of the syntax highlighting will look a little
odd... apparently the highlighting library I use doesn&#39;t understand template
strings.</p>
</blockquote>
<pre class="hljs"><code>touch rcg.js     # <span class="hljs-operator"><span class="hljs-keyword">create</span> a <span class="hljs-keyword">new</span> <span class="hljs-keyword">file</span>
chmod +x rcg.js  # <span class="hljs-keyword">set</span> an executable <span class="hljs-built_in">bit</span> <span class="hljs-keyword">on</span> the <span class="hljs-keyword">file</span>
vi rcg.js        # <span class="hljs-keyword">open</span> it <span class="hljs-keyword">for</span> editing</span></code></pre><p>(Obviously substitute your editor for <code>vi</code>.)</p>
<p>What&#39;s the first thing any executable script needs? A shebang! We&#39;ll also go
ahead and use <code>process</code>. If you don&#39;t know <code>process</code>, open Node in a terminal
(<code>node</code>) and just type in <code>process</code>. It&#39;s pretty cool. The bit we want is
<code>.argv</code>, which is an array of all arguments passed. It always has <code>node</code> and the
file that&#39;s calling it as the first two elements, so we don&#39;t need those.</p>
<pre class="hljs"><code><span class="hljs-shebang">#!/usr/bin/env node</span>

<span class="hljs-keyword">const</span> args = process.argv.slice(<span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> type = args[<span class="hljs-number">0</span>]
<span class="hljs-keyword">const</span> component = args[<span class="hljs-number">1</span>]</code></pre><p>What we&#39;re going for here is a script we can call like <code>./rcg.js function Foo</code>,
or with a <code>class</code> parameter instead.</p>
<p>The next thing we&#39;ll need to do is actually sketch out these components. I&#39;ll be
using template literals. If you don&#39;t have a recent version of Node, you should
update. If you can&#39;t update, you&#39;ll have to use string concatenation instead (so
really, you should just update). To update (on Mac or Linux; on Windows you
should just go to <a href="http://nodejs.org">the website</a> and download a new version),
just <code>npm i -g n &amp;&amp; n latest</code>.</p>
<p>Let&#39;s write out what a pure (function) component looks like, first.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> pureComponent = <span class="hljs-string">`</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>

<span class="hljs-keyword">const</span> ${component} = () =&gt; &lt;div&gt;${component}&lt;/div&gt;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ${component}
<span class="hljs-string">`</span></code></pre><p>It doesn&#39;t have a whole lot going on, I know. This is just a quick file
generator, it can&#39;t write your code for you. :P</p>
<p>If you can&#39;t update node, that&#39;d look something like this:</p>
<pre class="hljs"><code><span class="hljs-keyword">var</span> pureComponent = <span class="hljs-string">&#39;import React from \&#39;</span>react\<span class="hljs-string">&#39;&#39;</span> +
<span class="hljs-string">&#39;function &#39;</span> + component + <span class="hljs-string">&#39;(){&#39;</span> +
  <span class="hljs-string">&#39;return &lt;div&gt;&#39;</span> + component + <span class="hljs-string">&#39;&lt;/div&gt;&#39;</span> +
<span class="hljs-string">&#39;}&#39;</span> +
<span class="hljs-string">&#39;module.exports = &#39;</span> + component</code></pre><p>(Kind of annoying, right?)</p>
<p>So now, let&#39;s get one for a class (I won&#39;t go through doing this one with an old
version of Node, nor with <code>React.createClass</code>&mdash;just with ES2015 classes).</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> classComponent = <span class="hljs-string">`</span>
<span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">$</span>{<span class="hljs-title">component</span>} <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> {</span>
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;${component}&lt;/div&gt;
    )
  }
}
<span class="hljs-string">`</span></code></pre><p>Lovely! Obviously this should be more complex; if your class only has a render
function that returns JSX, just use a function instead.</p>
<p>Great, now you have a bunch of stuff in a file that doesn&#39;t do anything! Let&#39;s
handle arguments and make it actually do things.</p>
<p>There are a lot of great libraries for parsing options, and I&#39;ll list a few of
them in the next blog post. For now, we&#39;ll just use <code>if</code> statements.</p>
<pre class="hljs"><code><span class="hljs-keyword">let</span> toWrite <span class="hljs-comment">// this is what we&#39;ll end up writing to a file</span>
<span class="hljs-keyword">if</span> (<span class="hljs-class"><span class="hljs-keyword">type</span> </span>=== &#39;<span class="hljs-keyword">function</span>&#39;) {
  toWrite = pureComponent
}
<span class="hljs-keyword">if</span> (<span class="hljs-class"><span class="hljs-keyword">type</span> </span>=== &#39;<span class="hljs-keyword">class</span>&#39;) {
  toWrite = classComponent
}
<span class="hljs-keyword">if</span> (<span class="hljs-class"><span class="hljs-keyword">type</span> !</span>== &#39;<span class="hljs-keyword">function</span>&#39; &amp;&amp; <span class="hljs-class"><span class="hljs-keyword">type</span> !</span>== &#39;<span class="hljs-keyword">class</span>&#39;) {
  console.log(&#39;please pass <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">of</span> <span class="hljs-title">component</span> <span class="hljs-title">as</span> <span class="hljs-title">first</span> <span class="hljs-title">argument</span>&#39;)</span>
}</code></pre><p>That&#39;s a little sloppy&mdash;intentionally! I&#39;m hoping you take some time to
write this out a little better than just copying and pasting from this blog
post.</p>
<p>There&#39;s one major bit left: actually writing a file. We&#39;ll need Node&#39;s <code>fs</code> for
this.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { writeFile } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;fs&#39;</span>)</code></pre><p>Now, at the bottom of our file, let&#39;s actually do the fun bit.</p>
<pre class="hljs"><code>writeFile<span class="hljs-list">(`${component}.js`, toWrite, <span class="hljs-quoted">&#39;utf8</span>&#39;, err =&gt; {
  if <span class="hljs-list">(<span class="hljs-keyword">err</span>)</span> console.log<span class="hljs-list">(<span class="hljs-keyword">err</span>)</span>
})</span></code></pre><p>Now your whole file should look something like this:</p>
<pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env node</span>

<span class="hljs-keyword">const</span> args = process.argv.slice(<span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> type = args[<span class="hljs-number">0</span>]
<span class="hljs-keyword">const</span> component = args[<span class="hljs-number">1</span>]
<span class="hljs-keyword">const</span> { writeFile } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;fs&#39;</span>)

<span class="hljs-keyword">const</span> pureComponent = <span class="hljs-string">`</span>
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>

<span class="hljs-keyword">const</span> ${component} = () =&gt; &lt;div&gt;${component}&lt;/div&gt;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ${component}
<span class="hljs-string">`</span>

<span class="hljs-keyword">const</span> classComponent = <span class="hljs-string">`</span>
<span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">$</span>{<span class="hljs-title">component</span>} <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> {</span>
  render() {
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;${component}&lt;/div&gt;
    )
  }
}
<span class="hljs-string">`</span>

<span class="hljs-keyword">let</span> toWrite
<span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#39;function&#39;</span>) {
  toWrite = pureComponent
}
<span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#39;class&#39;</span>) {
  toWrite = classComponent
}
<span class="hljs-keyword">if</span> (type !== <span class="hljs-string">&#39;function&#39;</span> &amp;&amp; type !== <span class="hljs-string">&#39;class&#39;</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#39;please pass type of component as first argument&#39;</span>)
}

writeFile(<span class="hljs-string">`${component}.js`,</span> toWrite, <span class="hljs-string">&#39;utf8&#39;</span>, err =&gt; {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.log(err)
})</code></pre><p>Boom! You&#39;ve made a command-line app! You can drop this anywhere in your <code>$PATH</code>
and call it from anywhere to generate a component for you! (<code>$PATH</code> is where
your system looks for files to execute. If you don&#39;t have something like a
<code>~/bin</code> directory, maybe <code>mv rcg.js /usr/local/bin</code>. If you don&#39;t want to move it
somewhere like that, you can always either do <code>./rcg.js</code> or <code>node rcg</code>.)</p>
<p>That&#39;s it! This script is not super clean. There are a few little things that
can be done to make it a lot better, like using a <code>switch</code> statement to handle
arguments, handling unexpected arguments, not overwritting an existing file,
passing more options, and trimming extra lines from the generated files, and not
keeping your templates in the same file as all the rest of the things. I&#39;m going
to leave that up to you. Have fun with it!</p>
<p>If you&#39;re interested in doing this kind of stuff in Node, be sure to check back!
I&#39;ve got two more tutorials on writing command-line apps in Node, which will go
progressively more in depth, on the way</p>
]]></description><link>/2016/a-basic-cli-app-in-node.html</link><guid isPermaLink="true">/2016/a-basic-cli-app-in-node.html</guid><category><![CDATA[node]]></category><category><![CDATA[cli]]></category><category><![CDATA[terminal]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 25 Aug 2016 03:42:00 GMT</pubDate></item><item><title><![CDATA[things that suck about js]]></title><description><![CDATA[<p>asked some people what they dislike about js, just out of curiosity.
results are predictable.</p>
<p>in no particular order:</p>
<ul>
<li>events (dom events, event cycle, event loop)</li>
<li>js fatigue</li>
<li>this (context)</li>
<li>es6 classes/oo idea prevalence</li>
<li>mobile safari even existing</li>
<li>internet explorer/edge</li>
<li>no type system</li>
<li>everything DOM related</li>
<li>no real immutable values</li>
<li>lack of neat syntax tools found in new languages (simple shit like range operators)</li>
<li>the way everyone else writes it</li>
</ul>
]]></description><link>/2016/things-that-suck-about-js.html</link><guid isPermaLink="true">/2016/things-that-suck-about-js.html</guid><category><![CDATA[js]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Tue, 23 Aug 2016 00:22:00 GMT</pubDate></item><item><title><![CDATA[visual studio oddities]]></title><description><![CDATA[<h2 id="story-">Story:</h2>
<p>Manager: &#39;Hey there&#39;s this thing, can you do it? Shouldn&#39;t take long.&#39;</p>
<p>Me: &#39;Sure, I guess.&#39;</p>
<p>Manager: &#39;It&#39;s in Angular.&#39;</p>
<p>Me: &#39;Urgh, right, okay, no prob.&#39;</p>
<p>Me: &#39;In [C# app]?&#39;</p>
<p>Manager: &#39;Yeah.&#39;</p>
<p>Me: Spends five hours fighting Visual Studio.</p>
<p>True story.</p>
<p>Some Visual Studio oddities:</p>
<ul>
<li>undo is ctrl-z, but</li>
<li>redo is shift-alt-backspace.</li>
<li>there&#39;s no &#39;revert&#39; (which even basic text editors have)</li>
<li>shift-tab only works if you have multiple lines selected</li>
<li>jump-to-matching-symbol (<code>%</code> in vim) only works sometimes</li>
<li>there&#39;s no search-in-open-buffers, i think</li>
<li>commenting out code: <code>ctrl-k ctrl-c</code></li>
<li>selecting text and hitting quotes will delete the text, not wrap in quotes</li>
<li>line-numbers are off by default</li>
<li>menus upon menus upon menus, each one slower than the last</li>
</ul>
<p>I&#39;m sure it&#39;s a really great IDE for C# people, but goddamn, it&#39;s slow.</p>
<p>It also has that horrible malware problem where you need to have Windows to use it.</p>
]]></description><link>/2016/visual-studio-oddities.html</link><guid isPermaLink="true">/2016/visual-studio-oddities.html</guid><category><![CDATA[visual-studio]]></category><category><![CDATA[windows]]></category><category><![CDATA[ms]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Mon, 22 Aug 2016 22:20:00 GMT</pubDate></item><item><title><![CDATA[principles and tips]]></title><description><![CDATA[<p>I&#39;m not very experienced, and sometimes I&#39;m pretty sure I&#39;m not very good at
programming, but I have some principles I try to stick to that help, I think.
They&#39;re not complicated. Also some tips. These are all in no particular order.
And kind of stream-of-consciousness.</p>
<p>Have a changelog. This doesn&#39;t have to be something complicated. It can actually
be <em>really</em> simple. Here&#39;s a script that&#39;ll do this for you.</p>
<pre class="hljs"><code><span class="hljs-shebang">#!/usr/bin/env bash</span>
range=<span class="hljs-string">&quot;<span class="hljs-variable">${1:-origin..}</span>&quot;</span>
<span class="hljs-built_in">shift</span> <span class="hljs-number">1</span>
git <span class="hljs-built_in">log</span> \
  --no-merges \
   --format=<span class="hljs-string">&#39;%C(auto,green)* %s%C(auto,reset)%n%w(0,2,2)%+b&#39;</span> \
   --reverse <span class="hljs-string">&quot;<span class="hljs-variable">$range</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span></code></pre><p>Write tests. Even if they&#39;re not complex, thorough tests, write them. It&#39;s a
start.</p>
<p>If you change things and tests break, fix the tests. Try not to break the tests.
But if you do, and it&#39;s a necessary change, fix the tests to line up with how
things work now.</p>
<p>Don&#39;t decrease code coverage. This goes back to &#39;if you write a thing, write a
test for it.&#39;</p>
<p>Don&#39;t bring in new libraries/frameworks/whatever unless without good reason.</p>
<p>Keep all dependencies up to date. If there&#39;s a breaking change, take a day to
update your code. If there are breaking changes all the time and no easy way to
update (like codemods), get rid of that dependency.</p>
<p>Delete code. As much as possible. Don&#39;t keep it around &#39;just in case&#39; or
something. Get rid of it.</p>
<p>Don&#39;t write very specific functions. And name your functions appropriately.  No
<code>getThisSpecificPieceOfData()</code>; instead, <code>getData(specificPiece)</code>. And then, if
you&#39;re going to be calling it with that specific piece of data, maybe write a
second function. But have that first one, first. <code>const getThisThing =
getThings(thisThing)</code>.</p>
<p>Don&#39;t stress about not knowing something. Either someone else knows it, or
literally no one around you knows it so you can be the first to figure it out,
which is cool. (I suck at this not-stressing bit, but I&#39;m trying.)</p>
<p>No language or framework or library sucks. I mean, okay, some do, but most
really don&#39;t, they&#39;re just probably not what you&#39;re looking for. Even Angular
doesn&#39;t <em>suck</em>, it&#39;s just not a good fit for many many webapps. And by the same
token, not all good things are always good. React is great, but if you&#39;re doing
a little static site, screw it, just use jQuery. It&#39;s okay. No one will judge
you too harshly. And if they do, screw them, too.</p>
<p>Some paradigms are better than others, but no one will ever agree on which ones
are better, so it&#39;s best to just pretend that OO is great when talking to C#
people, and that FP is great when talking to Haskell people, or whatever.
Believe whatever you want to believe, and if you do decide to stick hardcore to
one way of writing code, make sure you know it <em>really</em> well.</p>
<p>Use the simplest tool possible. This isn&#39;t my principle, this is a law. But
people break it all the time, <strong>especially</strong> in the front-end world. If you can
do it with ten lines of Bash, do it with ten lines of Bash, don&#39;t install five
dependencies to be able to do it in 40 lines of JS. (If you&#39;re on a computer
that doesn&#39;t have Bash, change or update your OS. Even Windows has Bash, now.)</p>
<p>Premature abstractions are just as bad as premature optimizations. Avoid, avoid,
avoid.</p>
<p>Being good at using a computer comes first. If you can&#39;t use the basic tools you
need to do your job, you need to learn that first. That means your hardware,
your OS, your terminal, your shell, your editor, your browser, whatever. You
don&#39;t need to go read the source and learn every hotkey and all that, but being
good with your tools means being faster and more productive, which gives you a
lot more time for thinking, reading docs, and all the other things that you
actually do most of the time when writing code.</p>
<p>Also, type. If you can&#39;t type well, practice. I&#39;m a fast typist&mdash;114 wpm,
which is pretty fast&mdash;and while it hasn&#39;t made me a <em>better</em> developer,
being able to type things quickly means I have more time to do all the things
that aren&#39;t just typing. Like thinking and reading docs.</p>
<p>Figure out what doesn&#39;t work, and what you don&#39;t like. That&#39;s actually pretty
easy to do. Just play with a lot of things and learn what sucks, to you.</p>
<p>No job is worth screwing up your personal life over. If you can&#39;t take a few
days off for important events without much warning, find a different job. You&#39;re
a developer. You&#39;re in control, in the current job market.</p>
<p>Don&#39;t just code. It&#39;s bad for you. Have something else. Music, woodworking,
fancy-wine-drinking, whatever. You need to get your eyes away from the screen
for a while, and get your wrists out of that position. You&#39;ll end up blind with
carpal tunnel if all you do is code all day long.</p>
<p>If a tool you&#39;re using isn&#39;t working out (that could be a language, framework,
package manager, OS, cloud provider, whatever), find a way to get rid of it.
That might take a while (ages, maybe), but it&#39;ll be worth it. Good tools are
worth using. Don&#39;t get yourself stuck with shitty ones. You can almost always
find a way to gradually switch over, so it&#39;s not a big immediate change for your
team or your project or whatever. If you use an editor you don&#39;t like, but
you&#39;re not sure you&#39;d like anything else better, just try a different editor.
Maybe try a different one every two weeks, &#39;til you&#39;ve picked one.</p>
<p>Laptop screens aren&#39;t great. Get a decent monitor for at home. Just do it. It&#39;s
worth it. Also a decent mouse, if you use a mouse. If you have a laptop with a
crappy keyboard, treat yourself to a nice keyboard. All these things make a
difference.</p>
<p>No language is great.  No one has ever written a language that&#39;s just perfect.
Anyone who claims their language is provably superior in all ways to your language
is either an idiot or trying to sell you something. No one will ever write a
language that&#39;s great for everything in all ways, either. So just find one that
works kind of okay in a way you feel like you can live with, and go with that.
Doesn&#39;t matter if that&#39;s Smalltalk, ML, Jelly, or Brainfuck. If you can be
productive in it and it works for the thing you&#39;re making (and for your team),
do that, and screw the haters.</p>
<p>Don&#39;t live on energy drinks, pizza, and IPAs on Friday nights.</p>
<p>I&#39;m a little off-topic now I guess, so, that&#39;s all.</p>
]]></description><link>/2016/principles-and-tips.html</link><guid isPermaLink="true">/2016/principles-and-tips.html</guid><category><![CDATA[process]]></category><category><![CDATA[development]]></category><category><![CDATA[principles]]></category><category><![CDATA[tips]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 20 Aug 2016 03:57:00 GMT</pubDate></item><item><title><![CDATA[purescript things]]></title><description><![CDATA[<p>What are <code>@</code> and <code>=&gt;</code>?</p>
<p>What is fixity? Is this the same as precedence?</p>
<pre class="hljs"><code>foo :: [<span class="hljs-operator">a</span>] <span class="hljs-comment">-- in haskell would be</span>
foo :: forall <span class="hljs-operator">a</span>. Array <span class="hljs-operator">a</span> <span class="hljs-comment">-- in purescript, i think?</span>
<span class="hljs-comment">-- there&#39;s no [] in annotations, it&#39;s always Array a</span>
<span class="hljs-comment">-- but there is List, but you have to use Data.List instead of just []</span>

Number <span class="hljs-comment">-- is js number</span>
Int <span class="hljs-comment">-- is 32 bit -- and it&#39;s basically n | 0 (?)</span>

Unit <span class="hljs-comment">-- ()</span>

main :: IO () <span class="hljs-comment">-- would be</span>
main :: Eff <span class="hljs-comment">-- basically, but really more something like</span>
main :: Eff (<span class="hljs-built_in">process</span> :: PROCESS, fs :: FS) Unit <span class="hljs-comment">-- or something</span>

<span class="hljs-operator">a</span> &lt;&gt; b <span class="hljs-comment">-- a ++ b -- concat a b</span>

A &lt;= B <span class="hljs-comment">-- B implies instance of A</span></code></pre><p>something like this is kind of right i think (what builds on what):
i</p>
<pre class="hljs"><code>      monad
  applicative   ??
    apply  <span class="hljs-keyword">bind
</span>      functor</code></pre><p>No tuples, just records. But there&#39;s a lib for tuples.</p>
<p><code>&lt;&lt;&lt;</code>  is <code>.</code> for rtl composition, and <code>&gt;&gt;&gt;</code> for ltr</p>
<p>Lots of <code>Data.List</code> stuff is in <code>Data.Foldable</code> and <code>Data.Traversable</code> instead.</p>
<p>To export stuff: <code>module Foo (a, b, c) where</code>.
That&#39;s like <code>export { a, b, c }</code> in JS, I think.
<code>module Foo (..)</code> exports everything, I think.</p>
<h2 id="what">what</h2>
<pre class="hljs"><code>z ± psci
PSCi requires the purescript-psci-support package to be installed.
You can <span class="hljs-operator"><span class="hljs-keyword">install</span> it <span class="hljs-keyword">using</span> Bower <span class="hljs-keyword">as</span> <span class="hljs-keyword">follows</span>:

  bower <span class="hljs-keyword">i</span> purescript-psci-support <span class="hljs-comment">--save-dev</span>

<span class="hljs-keyword">For</span> <span class="hljs-keyword">help</span> getting started, visit <span class="hljs-keyword">http</span>://wiki.purescript.org/PSCi

z ± a bower_components/ | ag psci
purescript-psci-support/

z ± jq .devDependencies &lt; bower.<span class="hljs-keyword">json</span>
{
  <span class="hljs-string">&quot;purescript-spec&quot;</span>: <span class="hljs-string">&quot;^0.8.0&quot;</span>,
  <span class="hljs-string">&quot;purescript-psci-support&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>
}

z ±

z ± pulp psci
PSCi, <span class="hljs-keyword">version</span> <span class="hljs-number">0.9</span><span class="hljs-number">.3</span>
<span class="hljs-keyword">Type</span> :? <span class="hljs-keyword">for</span> <span class="hljs-keyword">help</span>

&gt; :<span class="hljs-keyword">l</span> <span class="hljs-keyword">Main</span>
Unrecognized directive. <span class="hljs-keyword">Type</span> :? <span class="hljs-keyword">for</span> <span class="hljs-keyword">help</span>.
&gt; <span class="hljs-keyword">import</span> <span class="hljs-keyword">Main</span>
&gt; :<span class="hljs-keyword">t</span> <span class="hljs-keyword">Main</span>
<span class="hljs-keyword">Error</span> <span class="hljs-keyword">found</span>:
<span class="hljs-keyword">in</span> <span class="hljs-keyword">module</span> $PSCI
<span class="hljs-keyword">at</span>  line <span class="hljs-number">1</span>, <span class="hljs-keyword">column</span> <span class="hljs-number">1</span> - line <span class="hljs-number">1</span>, <span class="hljs-keyword">column</span> <span class="hljs-number">2</span>

  <span class="hljs-keyword">Unknown</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">constructor</span> <span class="hljs-keyword">Main</span>


See <a href="https://github.com/purescript/purescript/wiki/">https://github.com/purescript/purescript/wiki/</a><span class="hljs-keyword">Error</span>-Code-UnknownName <span class="hljs-keyword">for</span> more information,
<span class="hljs-keyword">or</span> <span class="hljs-keyword">to</span> contribute <span class="hljs-keyword">content</span> related <span class="hljs-keyword">to</span> this <span class="hljs-keyword">error</span>.


&gt; :<span class="hljs-keyword">i</span> <span class="hljs-keyword">Main</span>
Unrecognized directive. <span class="hljs-keyword">Type</span> :? <span class="hljs-keyword">for</span> <span class="hljs-keyword">help</span>.
&gt; :<span class="hljs-keyword">t</span> <span class="hljs-keyword">Module</span>.Thing.functionThatIKnowIsThere
<span class="hljs-keyword">Error</span> <span class="hljs-keyword">found</span>:
<span class="hljs-keyword">in</span> <span class="hljs-keyword">module</span> $PSCI
<span class="hljs-keyword">at</span>  line <span class="hljs-number">1</span>, <span class="hljs-keyword">column</span> <span class="hljs-number">1</span> - line <span class="hljs-number">1</span>, <span class="hljs-keyword">column</span> <span class="hljs-number">15</span>

  <span class="hljs-keyword">Unknown</span> <span class="hljs-keyword">module</span> <span class="hljs-keyword">Module</span>.Thing


See <a href="https://github.com/purescript/purescript/wiki/">https://github.com/purescript/purescript/wiki/</a><span class="hljs-keyword">Error</span>-Code-UnknownName <span class="hljs-keyword">for</span> more information,
<span class="hljs-keyword">or</span> <span class="hljs-keyword">to</span> contribute <span class="hljs-keyword">content</span> related <span class="hljs-keyword">to</span> this <span class="hljs-keyword">error</span>.


&gt; :q
See ya!</span></code></pre><p>kbai</p>
]]></description><link>/2016/purescript-things.html</link><guid isPermaLink="true">/2016/purescript-things.html</guid><category><![CDATA[purescript]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 20 Aug 2016 03:32:00 GMT</pubDate></item><item><title><![CDATA[angular in one line]]></title><description><![CDATA[<p>also angular in one line, just cuz.</p>
<pre class="hljs"><code><span class="hljs-label">WEIRD</span> MIX <span class="hljs-keyword">BETWEEN </span><span class="hljs-keyword">MARKUP </span><span class="hljs-keyword">AND </span>JAVA-LIKE JAVASCRIPT GOES HERE</code></pre>]]></description><link>/2016/angular-in-one-line.html</link><guid isPermaLink="true">/2016/angular-in-one-line.html</guid><category><![CDATA[angular]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 13 Aug 2016 23:59:00 GMT</pubDate></item><item><title><![CDATA[react in one line]]></title><description><![CDATA[<p>like my redux-in-one-line post&mdash;no, not really. just the idea of it.
really the idea of stateless components, the pure-function kind that we got to
start using in 0.14 or whatever.</p>
<pre class="hljs"><code>v = <span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(d)</span></span></code></pre><p>tada.</p>
]]></description><link>/2016/react-in-one-line.html</link><guid isPermaLink="true">/2016/react-in-one-line.html</guid><category><![CDATA[react]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 13 Aug 2016 23:58:00 GMT</pubDate></item><item><title><![CDATA[void elements]]></title><description><![CDATA[<p>i posted this a while back on <a href="http://zacanger.com/blog">my old blog</a> but it&#39;s worth posting again.</p>
<p>obviously this doesn&#39;t apply when using jsx, because everything needs to be closed. but, in jsx, if
it <em>can</em> be a self-closed tag (meaning literally any of these but also anything else that doesn&#39;t
have children), please self-close it.</p>
<ul>
<li>area</li>
<li>base</li>
<li>br</li>
<li>col</li>
<li>embed</li>
<li>hr</li>
<li>img</li>
<li>input</li>
<li>keygen</li>
<li>link</li>
<li>menuitem</li>
<li>meta</li>
<li>param</li>
<li>source</li>
<li>track</li>
<li>wbr</li>
</ul>
<p>see what they all have in common?</p>
<p>you can&#39;t possibly have anything in any of them, like, between tags. what can you put between
an opening and closing line break tag? <strong>nothing</strong>. so why would you need a closing tag?  <strong>you wouldn&#39;t</strong>.
so don&#39;t close it. none of that <code>&lt;img src=&quot;img.jpg&quot;&gt;&lt;/img&gt;</code> bs. No <code>&lt;br /&gt;</code>. and please, please,
never do something just weird like <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot; /&gt;</code>.</p>
]]></description><link>/2016/void-elements.html</link><guid isPermaLink="true">/2016/void-elements.html</guid><category><![CDATA[html]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Tue, 09 Aug 2016 19:58:00 GMT</pubDate></item><item><title><![CDATA[redux notes, part three]]></title><description><![CDATA[<p>Because the Redux docs say &quot;Redux is actually really simple!&quot; when sometimes
it&#39;s not, and because those docs themselves are pretty overwhelming when
you&#39;re first trying out Redux, I&#39;m going to attempt to distill the docs and
bits of my own (admittedly limited) personal experience with Redux into a
couple of blog posts.</p>
<hr>
<p>Just want to take a second to go over some syntax before going on more about
Redux. A lot of folks who&#39;re new to React might also be new to new JavaScript,
so some things might be looking a little unusual.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&#39;bar&#39;</span> <span class="hljs-comment">// is roughly the same as</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#39;bar&#39;</span> <span class="hljs-comment">// EXCEPT that you could not then do</span>
foo = <span class="hljs-string">&#39;baz&#39;</span> <span class="hljs-comment">// because you&#39;d be reassigning a const which is not okay.</span>
<span class="hljs-keyword">let</span> asdf = <span class="hljs-string">&#39;ghjkl&#39;</span> <span class="hljs-comment">// is a lot more like var</span>
asdf = <span class="hljs-string">&#39;qwerty&#39;</span> <span class="hljs-comment">// no errors</span>

import React from <span class="hljs-string">&#39;react&#39;</span> <span class="hljs-comment">// is kinda like</span>
<span class="hljs-keyword">const</span> React = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#39;react&#39;</span>) <span class="hljs-comment">// except it&#39;s actually just a part of the language now</span>
import { resolve } from <span class="hljs-string">&#39;path&#39;</span> <span class="hljs-comment">// is like</span>
<span class="hljs-keyword">const</span> { resolve } = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#39;path&#39;</span>) <span class="hljs-comment">// which is like</span>
<span class="hljs-keyword">var</span> path = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#39;path&#39;</span>)
<span class="hljs-keyword">var</span> resolve = path.resolve

export <span class="hljs-keyword">const</span> whatever = () =&gt; {} <span class="hljs-comment">// is like</span>
module.exports.whatever = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{}

export <span class="hljs-keyword">default</span> MyThing <span class="hljs-comment">// is like</span>
module.exports = MyThing

<span class="hljs-keyword">const</span>
  a = <span class="hljs-string">&#39;a&#39;</span>
, b = <span class="hljs-string">&#39;b&#39;</span>
, c = <span class="hljs-string">&#39;c&#39;</span>
, o = { a, b, c } <span class="hljs-comment">// is the same as</span>

<span class="hljs-keyword">var</span> a = <span class="hljs-string">&#39;a&#39;</span>
<span class="hljs-keyword">var</span> b = <span class="hljs-string">&#39;b&#39;</span>
<span class="hljs-keyword">var</span> c = <span class="hljs-string">&#39;c&#39;</span>
<span class="hljs-keyword">var</span> o = {
  a : a
, b : b
, c : c
}

<span class="hljs-keyword">const</span> someFunc = param =&gt; param <span class="hljs-comment">// is roughly the same as</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(param)</span> </span>{
  <span class="hljs-keyword">return</span> param
}
<span class="hljs-comment">// though there <em>are</em> important differences</span></code></pre><p>If you&#39;re not at all familiar with ES2015, you should really go get comfortable
with it. I put together a repo a while ago for that, full of examples and notes.
Check it out <a href="https://github.com/zacanger/es6-and-builds/tree/master">here</a>.
(Also if you want, check out my semi-maintained bunch of examples and resources
for learning React <a href="https://github.com/zacanger/react-bits">here</a>.)</p>
<hr>
<p><code>react-redux</code> (not a part of Redux itself, since it&#39;s supposed to be
framework/library agnostic... ish) is something you&#39;ll need for writing React
apps using Redux. It sort of enforces the presentational/container (or
dumb/smart) way of structuring your components.</p>
<p>Note&mdash;you don&#39;t <em>need</em> <code>react-redux</code> to be able to use Redux with React, it
just helps. A lot.</p>
<p>I won&#39;t go into the whole presentational/container component thing, there are a
lot of blogs posts and such out there on that topic, but it&#39;s basically what it
sounds like; you have components that handle how things look and components that
handle how things work.</p>
<p><code>react-redux</code> gives you this <code>connect()</code> function which is pretty handy. You can
do a lot of the stuff it does by hand using <code>store.subscribe()</code>, but then you
start needing to worry about <code>shouldComponentUpdate</code> and all this stuff, and
it&#39;s all kind of annoying.</p>
<p>When wrapping a &#39;dumb&#39; component up in a &#39;smart&#39; component, there are two
functions you usually throw in there. One is called <code>mapStateToProps</code>, and the
other is <code>mapDispatchToProps</code>. I&#39;d suggest you take a good look at the <a href="https://github.com/reactjs/react-redux">official
docs</a> on <code>react-redux</code> to get a good
feel for how it all works, but setting up a container component turns out to be
pretty straightforward.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> { connect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react-redux&#39;</span>
<span class="hljs-keyword">import</span> { someReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./wherever/your/reducers/are&#39;</span>
<span class="hljs-keyword">import</span> AComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./AComponent&#39;</span>

<span class="hljs-keyword">const</span> mapStateToProps = (state, ownProps) =&gt; ({
  <span class="hljs-attribute">somethingInState</span>: someReducer(state, ownProps.maybeSomeProperty.Here)
})

<span class="hljs-keyword">const</span> mapDispatchToProps = (dispatch, ownProps) =&gt; ({
  <span class="hljs-attribute">something</span>: probablyAnActionOrOtherFunction
})

<span class="hljs-keyword">const</span> AComponentThatIsNowConnected = connect(
  mapStateToProps
, mapDispatchToProps
)(AComponent)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> AComponentThatIsNowConnected</code></pre><p><code>mapDispatchToProps</code> is a little tricky, so I&#39;d really suggest just checking out
<a href="https://github.com/reactjs/react-redux/blob/master/docs/api.md">the docs</a>.</p>
<p>There&#39;s one other important bit, and that&#39;s this thing called <code>Provider</code>. It&#39;s a
component that makes the store available to all your container components
without you needing to actually pass it down everywhere. It uses this funky
<a href="https://facebook.github.io/react/docs/context.html">context</a> thing under the
hood. You don&#39;t need to put it everywhere, you just wrap a root component in it.</p>
<pre class="hljs"><code><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react&#39;</span>
<span class="hljs-keyword">import</span> { render } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react-dom&#39;</span>
<span class="hljs-keyword">import</span> { Provider } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;react-redux&#39;</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;redux&#39;</span>
<span class="hljs-keyword">import</span> reducers <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./reducers&#39;</span>
<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#39;./App&#39;</span>

<span class="hljs-keyword">const</span> store = createStore(reducers)
<span class="hljs-keyword">const</span> root = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#39;root&#39;</span>)

render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;
, root
)</code></pre><p>This can trip you up when testing! You don&#39;t need to do much to work around it,
but it can be annoying the first time you see all these random errors. Try
something like:</p>
<pre class="hljs"><code><span class="hljs-literal">import</span> test from <span class="hljs-string">&#39;ava&#39;</span> <span class="hljs-comment">// seriously awesome test runner</span>
<span class="hljs-literal">import</span> React from <span class="hljs-string">&#39;react&#39;</span>
<span class="hljs-literal">import</span> { mount } from <span class="hljs-string">&#39;enzyme&#39;</span> <span class="hljs-comment">// seriously awesome testing thing for React</span>
<span class="hljs-literal">import</span> { createStore } from <span class="hljs-string">&#39;redux&#39;</span>
<span class="hljs-literal">import</span> { Provider } from <span class="hljs-string">&#39;react-redux&#39;</span>
<span class="hljs-literal">import</span> MyComponent from <span class="hljs-string">&#39;./MyComponent&#39;</span>

test.beforeEach(<span class="hljs-string">&#39;Set up &lt;MyComponent /&gt;&#39;</span>, t =&gt; {
  <span class="hljs-keyword">const</span> store = createStore(() =&gt; ({}))
  t.context = mount(
    &lt;Provider store={store}&gt;
      &lt;MyComponent
        some=<span class="hljs-string">&#39;props&#39;</span>
      /&gt;
    &lt;/Provider&gt;
  )
})

<span class="hljs-comment">// and then you can do</span>
test(<span class="hljs-string">&#39;&lt;MyComponent /&gt; isn\&#39;t broken!&#39;</span>, t =&gt; {
  t.<span class="hljs-keyword">is</span>(t.context.prop(<span class="hljs-string">&#39;some&#39;</span>), <span class="hljs-string">&#39;props&#39;</span>)
})
<span class="hljs-comment">// and it won&#39;t throw errors about not finding a store and stuff!</span></code></pre>]]></description><link>/2016/redux-three.html</link><guid isPermaLink="true">/2016/redux-three.html</guid><category><![CDATA[redux]]></category><category><![CDATA[react]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sun, 07 Aug 2016 03:29:00 GMT</pubDate></item><item><title><![CDATA[redux notes, part two]]></title><description><![CDATA[<p>Because the Redux docs say &quot;Redux is actually really simple!&quot; when sometimes
it&#39;s not, and because those docs themselves are pretty overwhelming when
you&#39;re first trying out Redux, I&#39;m going to attempt to distill the docs and
bits of my own (admittedly limited) personal experience with Redux into a
couple of blog posts.</p>
<hr>
<p>All your data moves in one direction. This is the same as in Flux. You will
always go through the same steps in redux:</p>
<ul>
<li>Action (call <code>store.dispatch()</code> with an object that describes something
happening)</li>
<li>Reducer (pure function called based on the action that was dispatched that
calculates next state)</li>
<li>Your root reducer combines a bunch of reducers&#39; outputs into one state tree
(assuming you have a root reducer, which you probably do)</li>
<li>The store saves the state tree as returned by the above&mdash;now that&#39;s your
state (and at this point anything you subscribed with will be invoked)</li>
</ul>
<p>All your state in redux is just an object&mdash;just one object. It&#39;s probably a
good idea to try to keep that as shallow as possible, and reference things by
keys (IDs), rather than deeply nesting stuff.</p>
<p>Reducers are just functions. They take your existing state (state previous to
acting on it) and an action and output state (new state).</p>
<pre class="hljs"><code>const someReducer = <span class="hljs-function"><span class="hljs-params">(oldState, action)</span> =&gt;</span> newState</code></pre><p>It&#39;s a reducing function just like you&#39;d pass to <code>Array.reduce()</code>, it it should
always be a pure function. Don&#39;t mutate arguments, call non-pure functions, make
API calls, or anything like that in a reducer. If you don&#39;t know what a pure
function is, it&#39;s actually super simple:</p>
<blockquote>
<p>Given the same arguments, a pure function will always have the same output.
This means it&#39;s a function who&#39;s result relies solely on its arguments.</p>
</blockquote>
<p>One thing you should get in the habit of doing is using &#39;default arguments.&#39;
This is new in ES2015, and saves you a bit of code. This means you could have
some initial state:</p>
<pre class="hljs"><code>const initState = {
  <span class="hljs-string">something     :</span> <span class="hljs-string">&#39;a&#39;</span>
, <span class="hljs-string">somethingElse :</span> <span class="hljs-string">&#39;b&#39;</span>
}</code></pre><p>And instead of needing to write</p>
<pre class="hljs"><code>const reducer = (<span class="hljs-keyword">state</span>, action) =&gt; {
  if (typeof <span class="hljs-keyword">state</span> === &#39;undefined&#39;) {
    return initState
  }
  // do stuff
}</code></pre><p>You can just do</p>
<pre class="hljs"><code>const reducer = (<span class="hljs-keyword">state</span> = initState, action) =&gt; // do stuff</code></pre><p>Reducers are frequently switch statements. This might seem a little weird at
first, since most JS folks avoid switch statements (I think some linters even
warn about them, saying they&#39;re &#39;confusing&#39;), but it makes sense in reducers
since you can handle various actions in one function. Remember, an action is
just an object: <code>{type: &#39;do_thing&#39;}</code> with possible other fields: <code>{type:
&#39;do_thing&#39;, to: &#39;stuff&#39;}</code>.</p>
<pre class="hljs"><code>const someReducer = (<span class="hljs-keyword">state</span> = initState, action) {
  switch (action.type) {
    case do_stuff:
      return Object.assign({}, <span class="hljs-keyword">state</span>, {something: action.<span class="hljs-keyword">to</span>})
    <span class="hljs-keyword">default</span>:
      return <span class="hljs-keyword">state</span>
  }
}</code></pre><p>Note the <code>Object.assign()</code>&mdash;we don&#39;t mutate state, we return a new state
based on the old state and the action. You&#39;ll probably want to use a polyfill
for <code>.assign()</code>, but chances are you&#39;re already using Babel anyway. You could
also use something from Lodash, Underscore, or some other library.</p>
<p>It&#39;s always a good idea to return <code>state</code> (which is our old state) as a default,
in case we get sent some unexpected action.</p>
<p>It&#39;s also a good idea to split your reducers and compose them:</p>
<pre class="hljs"><code>const firstReducer = (<span class="hljs-keyword">state</span> = {}, action) =&gt; {
  switch (action.type) {
    case something:
      return stuff
    <span class="hljs-keyword">default</span>:
      return <span class="hljs-keyword">state</span>
  }
}

const secondReducer = (<span class="hljs-keyword">state</span> = initState, action) =&gt; {
  switch (action.type) {
    case whatever:
      return firstReducer(<span class="hljs-keyword">state</span>.field, action)
    <span class="hljs-keyword">default</span>
      return <span class="hljs-keyword">state</span>
  }
}</code></pre><p>This means that <code>firstReducer</code> only needs to get the state that it actually
cares about, when it needs to do something. Also note that defaut state is an
empty object there. It could be anything you want it to be, just make sure it&#39;s
the shape your reducer expects to act on.</p>
<p>When you have a lot of reducers, you can use <code>combineReducers</code>:</p>
<pre class="hljs"><code><span class="hljs-literal">import</span> { combineReducers } from <span class="hljs-string">&#39;redux&#39;</span>

<span class="hljs-keyword">const</span> lotsOfReducers = combineReducers({
  firstReducer
, secondReducer
<span class="hljs-comment">// , etc.</span>
})

<span class="hljs-literal">export</span> <span class="hljs-keyword">default</span> lotsOfReducers</code></pre><p>And you can do this as many times as you like, in as many files as you need.</p>
<p>All you&#39;re doing with reducers is taking in the state as it exists, taking in an
action, and outputing the new state. What you&#39;re operating against is the store.</p>
<p>The Store is a really important bit. It holds all the state of your app. This
is different from Flux, where you&#39;d have a lot of little stores. In Redux
there&#39;s only one. It&#39;s accessed similiarly&mdash;you have <code>getState()</code>, you
dispatch actions, and you can have listeners subscribe to changes. To create a
store in Redux, you just use <code>createStore</code>.</p>
<pre class="hljs"><code><span class="hljs-literal">import</span> { createStore } from <span class="hljs-string">&#39;redux&#39;</span>
<span class="hljs-literal">import</span> someReducer from <span class="hljs-string">&#39;./someFile&#39;</span>
<span class="hljs-keyword">const</span> store = createStore(someReducer)
<span class="hljs-comment">// createStore can take your initial state, too</span>
<span class="hljs-keyword">const</span> store = createStore(someReducer, initialState)
<span class="hljs-comment">// and for creating a store as simply as possible (mocking in testing, etc.):</span>
<span class="hljs-keyword">const</span> store = createStore(() =&gt; ({})) <span class="hljs-comment">// your store is just an empty object, now</span></code></pre><p><code>store.subscribe()</code> returns a function for _un_subscribing. So you can do
something like:</p>
<pre class="hljs"><code>const unsubscribe = store.<span class="hljs-function"><span class="hljs-title">subscribe</span><span class="hljs-params">(someListener)</span></span>
<span class="hljs-function"><span class="hljs-title">unsubscribe</span><span class="hljs-params">()</span></span></code></pre>]]></description><link>/2016/redux-two.html</link><guid isPermaLink="true">/2016/redux-two.html</guid><category><![CDATA[redux]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sat, 06 Aug 2016 14:37:00 GMT</pubDate></item><item><title><![CDATA[redux notes, part one]]></title><description><![CDATA[<p>Because the Redux docs say &quot;Redux is actually really simple!&quot; when sometimes
it&#39;s not, and because those docs themselves are pretty overwhelming when
you&#39;re first trying out Redux, I&#39;m going to attempt to distill the docs and
bits of my own (admittedly limited) personal experience with Redux into a
couple of blog posts.</p>
<hr>
<p>The store is an object that holds state. There&#39;s only ever one store in Redux,
with many reducers that act on it.</p>
<p><code>getState()</code> returns the state from the store.</p>
<p><code>subscribe(listener)</code> says &quot;Hey, call <code>listener</code> when the state changes.&quot;</p>
<p>There&#39;s also a <code>replaceReducer</code> but unless you&#39;re writing hot middlware or
something you probably won&#39;t touch this one.</p>
<p>State can by any type, though obviously it&#39;s probably best to just use an
object here.</p>
<p>Actions are always objects, and they always have a <code>type</code>.</p>
<pre class="hljs"><code>store.<span class="hljs-function"><span class="hljs-title">dispatch</span><span class="hljs-params">({type: <span class="hljs-string">&#39;do-stuff&#39;</span>})</span></span>
<span class="hljs-comment">// it&#39;s conventional to use all uppercase, but it&#39;s also hideous. so.</span>
store.<span class="hljs-function"><span class="hljs-title">dispatch</span><span class="hljs-params">({type: <span class="hljs-string">&#39;DO_OTHER_STUFF&#39;</span>, stuff: <span class="hljs-string">&#39;[things to do here, maybe]&#39;</span>})</span></span></code></pre><p>Action creators are functions that create actions based on any sorts of
arguments.</p>
<pre class="hljs"><code><span class="hljs-title">const</span> sendSomeData = &#39;send-some-<span class="hljs-typedef"><span class="hljs-keyword">data</span>&#39;</span>
<span class="hljs-title">const</span> sendSomeDataActionCreator = <span class="hljs-typedef"><span class="hljs-keyword">data</span> =&gt; <span class="hljs-container">({
  <span class="hljs-title">type</span> : <span class="hljs-title">sendSomeData</span>
, <span class="hljs-title">data</span>
})</span></span></code></pre><p>A &#39;bound&#39; action creator would be one that creates the action and immediately
dispatches it. This might be familiar to folks who&#39;ve worked with Flux before.</p>
<p>This is how you might have something like this in Flux:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> sendMoreData = data =&gt; {
  <span class="hljs-keyword">const</span> doIt = {
    type : sendMoreData,
    data
  }
  dispatch(doIt)
}</code></pre><p>And this is how it&#39;d work in Redux:</p>
<pre class="hljs"><code><span class="hljs-comment">// assuming you already have the dispatch and action creator, you&#39;d just</span>
const boundSendMoreData = data =&gt;
  <span class="hljs-function"><span class="hljs-title">dispatch</span><span class="hljs-params">(sendMoreData(data)</span></span>)</code></pre><p>There&#39;s also a <code>bindActionCreators()</code> to just do this for you, and React-Redux
has <code>connect()</code>.</p>
<p>Async actions should go through middleware to be turned into regular actions
before being dispatched.</p>
<p>Reducers always take state and an action and return state.
<code>reducer (state, action) =&gt; state</code>
These are what they sound like&mdash;reducing functions.
The state a reducer takes is your existing (or previous, I guess) state.
Reducers are pure functions.</p>
<p>A dispatch is a function that takes an action (or an async action). It may then
dispatch an action (or actions) which will affect the store.
There&#39;s a base <code>dispatch</code> that always sends an action to the reducer.</p>
<p>Middleware are about what you&#39;d expect&mdash;functions (HOF) that take a
dispatch function and return a dispatch function.</p>
<p>There are &#39;store enhancers&#39; that are higher-order functions that take a store
creator and return a different store creator. They&#39;re basically kind of a
middleware for the store creator. You probably won&#39;t directly use one, ever.
Instead you&#39;ll just use the regular store creator (<code>createStore</code>).</p>
]]></description><link>/2016/redux-one.html</link><guid isPermaLink="true">/2016/redux-one.html</guid><category><![CDATA[redux]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Wed, 03 Aug 2016 01:10:00 GMT</pubDate></item><item><title><![CDATA[idea: series on design for devs]]></title><description><![CDATA[<p>I&#39;ve wanted to do something like this for a while (since December-ish), but
haven&#39;t had the time. I have some minor design experience (not a lot), and tend
to read more about interaction design, HCI, and other random
non-programming-but-still-computer-and-person-working-together-related topics
than I do about programming.</p>
<p>Would anyone be interested in seeing something like that? This is a short list
of things I might cover:</p>
<ul>
<li>A11Y</li>
<li>Typography</li>
<li>Colour theory</li>
<li>Whitespace</li>
<li>Scalable design (math; see Basscss)</li>
<li>Styleguides (writing, maintaining, conforming)</li>
<li>Image manipulation (mostly what <em>not</em> to do)</li>
<li>Importance and longevity of simplicity</li>
<li>KISS</li>
<li><a href="http://jxnblk.com/principles/">Principles</a></li>
</ul>
<p>Please <a href="https://twitter.com/@zacanger">tweet at me</a> if you think you&#39;d be into
it, or have any suggestions/additions/whatever.</p>
]]></description><link>/2016/design-for-devs.html</link><guid isPermaLink="true">/2016/design-for-devs.html</guid><category><![CDATA[design]]></category><category><![CDATA[idea]]></category><category><![CDATA[dev]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Wed, 03 Aug 2016 00:42:58 GMT</pubDate></item><item><title><![CDATA[redux in two lines]]></title><description><![CDATA[<p>Okay, not actually Redux in two lines, just the idea behind it
And really one of those is basically the idea of React, I guess.</p>
<pre class="hljs"><code>const render = <span class="hljs-keyword">state</span> =&gt; ui
const reducer = (oldState, action) =&gt; newState</code></pre>]]></description><link>/2016/redux-in-two-lines.html</link><guid isPermaLink="true">/2016/redux-in-two-lines.html</guid><category><![CDATA[react]]></category><category><![CDATA[redux]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Fri, 29 Jul 2016 07:09:37 GMT</pubDate></item><item><title><![CDATA[More More Notes Taken While Watching MPJ's Videos]]></title><description><![CDATA[<p>lol streams are like the weird lovechild of promises and arrays i love that
analogy</p>
<p>here&#39;s a stream-making thingy</p>
<pre class="hljs"><code>const foo = {
  each (cb) {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> cb(<span class="hljs-number">1</span>), <span class="hljs-number">100</span>)
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> cb(<span class="hljs-number">2</span>), <span class="hljs-number">200</span>)
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> cb(<span class="hljs-number">3</span>), <span class="hljs-number">300</span>)
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> cb(<span class="hljs-number">4</span>), <span class="hljs-number">400</span>)
  }
}
foo.each(<span class="hljs-built_in">console</span>.log)</code></pre><p>prototypes are faster than factory functions but geez they&#39;re
kinda gross to think about you know so unless we&#39;re doing something
like making ten million objects just use a factory there i guess</p>
<p>streams are functors</p>
<p>functors are just a thing that implements map</p>
<p>monads are functors that also implement <em>flatMap</em></p>
<p>flatMap just flattens, i guess? that&#39;s what it sounds like.</p>
<p>so like with Promises for example, <code>.then</code> is like <code>.flatMap</code>.
same with stuff like bind and chain methods and stuff. it&#39;s basically
flattening into its <em>value</em> rather than having the actual (semi-expected)
value (function/promise/stream/whatever).</p>
<p>so if you have a flatMap that would return another monad, i guess,
it&#39;d actually return its value, not that other monad.</p>
<p>if you are a tooling addict, don&#39;t do tools. (this actually totally applies to
me, because i&#39;ve spent more time on <a href="https://github.com/zacanger/z.git">my dotfiles</a>
than on any other individual project... <em>but</em> i feel like it&#39;s worth it, mostly.
being able to just use vim and not go through the work of setting up any other
editor on any computer, being able to just clone that repo and symlink what i need,
that really does make me more productive. as long as i don&#39;t forget how to use
computers without my dotfiles, i don&#39;t think they&#39;re really a waste of time.)</p>
]]></description><link>/2016/fff2.html</link><guid isPermaLink="true">/2016/fff2.html</guid><category><![CDATA[js]]></category><category><![CDATA[fp]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Sun, 24 Jul 2016 22:00:00 GMT</pubDate></item></channel></rss>