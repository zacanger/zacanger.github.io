<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[undefined - angr]]></title><description><![CDATA[writings from zac anger]]></description><link>http://blog.zacanger.com/</link><generator>Ghost</generator><lastBuildDate>Mon, 24 Jul 2017 13:30:16 GMT</lastBuildDate><atom:link href="http://blog.zacanger.com/tag/undefined/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[WTF is Set?]]></title><description><![CDATA[<h1 id="wtf-is-set-">WTF is Set?</h1>
<p>Please excuse the funky syntax highlighting in this post. Apparently
the thing my blog uses for that doesn&#39;t know what to do about template strings.</p>
<p>So, someone asked in a Slack channel how they might clean up the following code:</p>
<pre class="hljs"><code>getNames (contacts) {
  <span class="hljs-built_in">let</span> contacts_<span class="hljs-built_in">set</span> = []

  contacts.forEach((contact) =&gt; {
    <span class="hljs-built_in">let</span> firstName = get(contact, <span class="hljs-string">&#39;contactInfo.firstName&#39;</span>)
    <span class="hljs-built_in">let</span> lastName  = get(contact, <span class="hljs-string">&#39;contactInfo.lastName&#39;</span>)
    <span class="hljs-built_in">let</span> fullName = `<span class="hljs-variable">${firstName}</span> <span class="hljs-variable">${lastName}</span>`

    <span class="hljs-keyword">if</span> (contacts_set.includes(fullName)) {
      <span class="hljs-built_in">return</span>
    } <span class="hljs-keyword">else</span> {
      contacts_set.push(fullName)
    }

    <span class="hljs-built_in">set</span>(this, <span class="hljs-string">&#39;contactsSet&#39;</span>, contactsSet)
  })
}</code></pre><p>Note that the <code>get</code> and <code>set</code> going on here seemed to be Ember-specific. I don&#39;t
know Ember so don&#39;t ask me.</p>
<p>And I said, how about this?</p>
<pre class="hljs"><code><span class="hljs-attribute">getNames</span>: <span class="hljs-function"><span class="hljs-params">(contacts)</span> =&gt;</span>
  [...<span class="hljs-keyword">new</span> Set(
    contacts.map(<span class="hljs-function"><span class="hljs-params">({ contactInfo: { firstName, lastName }})</span> =&gt;</span>
      `<span class="javascript">${firstName} ${lastName}</span>`))]</code></pre><p>I like this version because it&#39;s very concise and still readable (to me).
It also doesn&#39;t do mutation-y stuff, which is a good thing.</p>
<p>And then someone else asked:</p>
<blockquote>
<p>Can some one eli5 what <code>Set</code> is that&#39;s referenced above?</p>
</blockquote>
<p>Which made me realise that a lot of folks still aren&#39;t using a lot of the nice
new things from ES2015, so I explained a bit. Here&#39;s how I understand it.</p>
<p>Set is a new (in ES2015) iterable builtin (like Array, String, TypedArray). Map
is also new in 2015. Set is to Array as Map is to Object, kinda.</p>
<p>For practical usage Set is basically Array but unique, and with different
methods. <code>add</code>, <code>has</code>, <code>delete</code>, <code>size</code>, and some others. There&#39;s a lot more
info <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">on MDN</a>.</p>
<p>You can pass <code>Set</code> an iterable, which is why the thing I have above works
(because thing inside <code>new Set()</code> results in an array).</p>
<p>In that case <code>Set</code> isn&#39;t being used for too much besides just the fact that it&#39;s
<code>Set</code> (so it only holds unique values). Someone else pointed out in the same
channel that maybe it&#39;s not the best idea if you have a lot of values, because
then you&#39;re creating another thing, which is totally true.</p>
<p>There&#39;s a bit more background
<a href="https://en.wikipedia.org/wiki/Set_(mathematics">here</a>) on what JS&#39;s <code>Set</code> is
suppose to be kind of like.</p>
<p>And underneath it sorta looks vaguely like this:</p>
<pre class="hljs"><code><span class="hljs-keyword">class</span> Set {
  <span class="hljs-constructor"><span class="hljs-keyword">constructor</span> () </span>{
    <span class="hljs-keyword">this</span>.storage = []
  }
  add (a) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.storage.includes(a)) {
      <span class="hljs-keyword">this</span>.storage.push(a)
    }
  }
  has (a) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.storage.includes(a)
  }
  remove (a) {
    <span class="hljs-keyword">this</span>.storage.splice(<span class="hljs-keyword">this</span>.storage.indexOf(a), <span class="hljs-number">1</span>)
  }
}</code></pre><p>That&#39;s a lot of stuff, but mostly you can think of <code>Set</code> as a thing that&#39;s like
<code>Array</code> but it only holds unique things.</p>
<p>There&#39;s also a <code>WeakSet</code> which can only hold objects. I haven&#39;t really found a
valid use case for <code>WeakSet</code> and <code>WeakMap</code> yet, personally.</p>
<p><code>Set</code> turns out to be pretty useful. I&#39;ve used it a few times <a href="https://jane.com">at
work</a> (with appropriate polyfills) without any problems, and I
use it in a few places in <a href="https://github.com/zacanger/zeelib">zeelib</a>, my
sort-of-sometimes-popular utility library. Definitely play around with it!</p>
]]></description><link>/2017/wtf-is-set.html</link><guid isPermaLink="true">/2017/wtf-is-set.html</guid><category><![CDATA[js]]></category><category><![CDATA[es2015]]></category><category><![CDATA[set]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Wed, 26 Apr 2017 05:00:00 GMT</pubDate></item><item><title><![CDATA[Promises]]></title><description><![CDATA[<p>Important things:</p>
<ul>
<li>The actual promise is immutable (nothing can change that)</li>
<li>There&#39;s a guarantee that we&#39;ll get something back</li>
<li>Usually create a promise with a constructor (<code>new Promise</code>)</li>
<li>Usually its two handlers are named <code>resolve</code> and <code>reject</code></li>
<li>A promise will have one of three states:<ul>
<li>Pending (until something happens)</li>
<li>Fulfilled (if the first handler is called)</li>
<li>Rejected (if the second handler is called)</li>
</ul>
</li>
<li>It can only be &#39;settled&#39; (either resolved or rejected) once.</li>
<li>Can&#39;t cancel a promise.</li>
<li>No way to check the status (if pending, fulfilled, or rejected).</li>
<li>An immediately-resolved promise can be created like <code>Promise.resolve(&#39;something&#39;)</code>.</li>
<li>An immediately-rejected promise can be created like <code>Promise.reject(&#39;something&#39;)</code>.</li>
<li>Attach a <code>then()</code> to consume the promise.</li>
<li><code>.then</code> takes a callback that gets passed the resolved value, on fulfillment.</li>
<li>It can actually take a rejection callback too.</li>
<li>You can pass in <code>null</code> instead of the first one, which is the same as just doing a <code>.catch()</code>.</li>
<li>You can chain <code>.then()</code>s.</li>
<li>You SHOULD use <code>.catch()</code> instead of the <code>.then(null, cb)</code> style.</li>
<li>This way you can chain multiple <code>then</code>s and then have a final <code>catch</code>.</li>
<li><code>throw</code>ing will automatically reject that promise.</li>
<li><code>Promise.all()</code> takes arr of promises; once all are fulfilled, it returns arr of fulfilled values.<ul>
<li>Otherwise (if any are rejected) it will reject.</li>
</ul>
</li>
<li><code>Promise.race()</code> is similar, but will fulfill once first promise in the array fulfills.</li>
<li>Don&#39;t program with promises using same patterns as with callbacks.<ul>
<li>(Don&#39;t do a <code>.then(fn(res), fn(err))</code>; use <code>.then().catch()</code>.)</li>
</ul>
</li>
<li>Don&#39;t nest promises. Use a <code>.all</code> instead.</li>
</ul>
<p>Examples:</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
  <span class="hljs-keyword">if</span> (something) {
    resolve(value)
  } <span class="hljs-keyword">else</span> {
    reject(reason)
  }
})

<span class="hljs-keyword">const</span> p = Promise.resolve(<span class="hljs-string">&#39;something&#39;</span>)
p.then(res =&gt; console.log(res))
<span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(<span class="hljs-string">&#39;asdf&#39;</span>), <span class="hljs-number">2000</span>)
})
p2.then(res =&gt; {
  res += <span class="hljs-string">&#39;ghjkl;&#39;</span>
  console.log(res)
})
p2.then(res =&gt; console.log(res)) <span class="hljs-comment">// this is still &#39;asdf&#39;</span>

somePromise.then(
  val =&gt; console.log(<span class="hljs-string">&#39;fulfilled&#39;</span>, val)
, err =&gt; console.error(<span class="hljs-string">&#39;rejected&#39;</span>, err))

pr.then(val =&gt; console.log(<span class="hljs-string">&#39;fulfilled&#39;</span>, val))
  .then(<span class="hljs-keyword">null</span>, err =&gt; console.error(<span class="hljs-string">&#39;rejected&#39;</span>, err))

<span class="hljs-keyword">const</span> throwProm = <span class="hljs-keyword">new</span> Promise((res, rej) =&gt; {
  <span class="hljs-keyword">if</span> (something) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#39;rejected&#39;</span>)
  } <span class="hljs-keyword">else</span> {
  resolve(stuff)
  }
})
throwProm
.then(val =&gt; val + <span class="hljs-number">8</span>)
.then(val =&gt; console.log(<span class="hljs-string">&#39;hey&#39;</span>, val))
.<span class="hljs-keyword">catch</span>(err =&gt; console.error(<span class="hljs-string">&#39;err&#39;</span>, err.message))

<span class="hljs-keyword">const</span> fulProm = <span class="hljs-keyword">new</span> Promise((res, rej) =&gt; res(<span class="hljs-number">8</span>))
fulProm
.then(val =&gt; val + <span class="hljs-number">8</span>)
.then(val =&gt; {<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#39;failure&#39;</span>)})
.then(val =&gt; console.log(<span class="hljs-string">&#39;yay&#39;</span>, val))
.<span class="hljs-keyword">catch</span>(err =&gt; console.error(<span class="hljs-string">&#39;error&#39;</span>, err.message))

one()
.then(res =&gt; Promise.all([res, two(res)]))
  .then(results =&gt; <span class="hljs-comment">/<em> stuff </em>/</span>)
  .<span class="hljs-keyword">catch</span>(err =&gt; <span class="hljs-comment">/<em> handle err </em>/</span>)</code></pre>]]></description><link>/2016/promises.html</link><guid isPermaLink="true">/2016/promises.html</guid><category><![CDATA[promises]]></category><category><![CDATA[es6]]></category><category><![CDATA[es2015]]></category><category><![CDATA[js]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Thu, 05 May 2016 19:00:00 GMT</pubDate></item></channel></rss>