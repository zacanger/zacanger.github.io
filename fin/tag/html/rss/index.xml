<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[undefined - angr]]></title><description><![CDATA[writings from zac anger]]></description><link>http://blog.zacanger.com/</link><generator>Ghost</generator><lastBuildDate>Sat, 18 Mar 2017 17:26:51 GMT</lastBuildDate><atom:link href="http://blog.zacanger.com/tag/undefined/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[html2text in node tutorial]]></title><description><![CDATA[<p>Okay, ready to build another command-line app in Node?</p>
<p>If you haven&#39;t seen my last two posts, you should check them out, since I&#39;m not
going to cover a lot of the basics again. They&#39;re both on writing small cli apps
in Node, with no dependencies.</p>
<ul>
<li><a href="http://blog.zacanger.com/2016/a-basic-cli-app-in-node.html">React component generator</a></li>
<li><a href="http://blog.zacanger.com/2016/note-taking-app.html">JSON Note-taking app</a></li>
</ul>
<p>And here&#39;s the finished product from the latter:</p>
<pre class="hljs"><code>#!/usr/bin/env node

&#39;<span class="hljs-keyword">use</span> strict&#39;

<span class="hljs-keyword">const</span> {
  readFileSync
, writeFile
}       = require(&#39;fs&#39;)
, <span class="hljs-keyword">log</span>   = console.<span class="hljs-literal">log</span>
, arg   = process.argv[2]
, <span class="hljs-keyword">n</span>     = &#39;./<span class="hljs-keyword">notes</span>.json&#39;
, <span class="hljs-keyword">file</span>  = readFileSync(<span class="hljs-keyword">n</span>)
, <span class="hljs-keyword">notes</span> = JSON.<span class="hljs-keyword">parse</span>(<span class="hljs-keyword">file</span>)

<span class="hljs-keyword">const</span> writeTheFile = () =&gt; {
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}

<span class="hljs-keyword">const</span> takeNote = (<span class="hljs-keyword">notes</span>, <span class="hljs-keyword">note</span>) =&gt; {
  <span class="hljs-keyword">notes</span>.push(<span class="hljs-keyword">note</span>)
  writeTheFile()
}

<span class="hljs-keyword">const</span> removeNote = (<span class="hljs-keyword">notes</span>, noteIndex) =&gt; {
  <span class="hljs-keyword">notes</span>.splice(noteIndex -1, 1)
  writeTheFile()
}

<span class="hljs-keyword">const</span> runApp = () =&gt; {
  <span class="hljs-keyword">if</span> (arg) {
    switch (arg) {
      case &#39;-s&#39;:
        <span class="hljs-literal">log</span>(<span class="hljs-keyword">notes</span>)
        <span class="hljs-keyword">break</span>
      case &#39;-r&#39;:
        <span class="hljs-keyword">const</span> noteIndex = process.argv[3]
        removeNote(<span class="hljs-keyword">notes</span>, noteIndex)
        <span class="hljs-keyword">break</span>
      default:
        takeNote(<span class="hljs-keyword">notes</span>, arg)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(&#39;Please pass <span class="hljs-keyword">an</span> argument&#39;)
  }
}

<span class="hljs-keyword">if</span> (!module.parent) {
  runApp()
}</code></pre><hr>
<p>What we&#39;re going to build this time is going to be a little more complex. We&#39;re
going to write a program that downloads a website and turns it into Markdown for
easy offline reading. This isn&#39;t a new concept, and I actually use a Python script
called <a href="https://github.com/aaronsw/html2text">html2text</a> for this on an
almost-daily basis, but just for fun, we&#39;ll do something similar in Node.</p>
<p>This will also be the first time we&#39;ll be working with external modules, which
is really the most exciting and awesome thing about Node.</p>
<p>Our goal here is to have a small tool we can use like this:</p>
<pre class="hljs"><code>./index<span class="hljs-class">.js</span> zacanger.com</code></pre><p>And it&#39;ll give us back the contents of <code>zacanger.com</code>, in Markdown, ready to
read in the terminal, pipe to an editor, or whatever.</p>
<p>First things first: we&#39;ll need a project. Make a new directory and get into it,
and <code>npm init</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">mkdir</span> html2txt
<span class="hljs-keyword">cd</span> html2xt
npm init -<span class="hljs-literal">y</span></code></pre><p>The <code>-y</code> flag just means &quot;don&#39;t ask me questions.&quot; You can skip that flag and
fill in the info for your <code>package.json</code> if you&#39;d like, or just go back and edit
it later.</p>
<p>We&#39;re going to be using a couple of things built-in to Node, so we can go ahead
and require them now. We&#39;ll need <code>http</code>&#39;s <code>get</code> method, and also a way to work
with an argument. If you&#39;ve done either of my previous tutorials, you&#39;ll already
be familiar with Node&#39;s <code>process.argv</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { <span class="hljs-keyword">get</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>)
<span class="hljs-keyword">const</span> url = process.argv[<span class="hljs-number">2</span>]</code></pre><p>Let&#39;s see if we can&#39;t get some HTML, just as a starting point.</p>
<pre class="hljs"><code>get<span class="hljs-list">(<span class="hljs-keyword">url</span>, res =&gt; {
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;data</span>&#39;, d =&gt; {
    console.log<span class="hljs-list">(<span class="hljs-keyword">d</span>)</span>
  })</span>
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;end</span>&#39;, <span class="hljs-list">()</span> =&gt; {
    console.log<span class="hljs-list">(<span class="hljs-quoted">&#39;done</span>&#39;)</span>
  })</span>
})</span></code></pre><p>Try that out with something like <code>node index.js http://google.com</code>.</p>
<p>You should see something like <code>&lt;Buffer 3c 21 64 6f 63 74 7</code> (and so on).
<a href="https://nodejs.org/api/buffer.html">Buffers</a> are great and all, but that&#39;s
pretty useless for actual reading. Try calling <code>toString</code> on that data and you
should see some actual HTML (<code>console.log(d.toString())</code>).</p>
<p>(Note: you may see a 301 page here.)</p>
<p>Awesome! We now have all the functionality of prepending <code>view-source:</code> to a URL
in the browser. Let&#39;s do something with that HTML, since it&#39;s probably not how
you prefer to read stuff.</p>
<p>There are a lot of great modules out there for working with Markdown. For this
post, I&#39;ve decided to go with a super simple one without a whole lot of options,
<a href="https://www.npmjs.com/package/to-markdown">to-markdown</a>. If you&#39;re not super
familiar with npm, you&#39;re about to learn just about all you need to know to get
started.</p>
<p>In your terminal, <code>npm i -S to-markdown</code>. This is a shorthand for the command
<code>npm install --save to-markdown</code>; most npm commands have shorter versions, and
it can really save you a lot of time if you get used to using them.</p>
<p>You should see a bunch of stuff happen in the terminal. If you check your
<code>package.json</code>, you&#39;ll now see <code>to-markdown</code> in there. It should like something
like this:</p>
<pre class="hljs"><code><span class="hljs-collection">{
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;something&quot;</span>,
  // probably some other stuff
  <span class="hljs-string">&quot;dependencies&quot;</span>: <span class="hljs-collection">{
    <span class="hljs-string">&quot;to-markdown&quot;</span>: <span class="hljs-string">&quot;^3.0.1&quot;</span>
  }</span>
}</span></code></pre><p>(Yes, I know you can&#39;t have comments in JSON.)</p>
<p>Next we&#39;ll need to get that into the program. If you&#39;re using Babel, you can use
<code>import</code>, but to keep things simple we&#39;ll stick with <code>require</code>.</p>
<pre class="hljs"><code>const toMarkdown = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">&#39;to-markdown&#39;</span>)</span></span></code></pre><p>Now try running the HTML through this before logging it out.</p>
<pre class="hljs"><code><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> toMarkdown = require(&#39;to-markdown&#39;)
<span class="hljs-comment">// ...</span>
  res.<span class="hljs-keyword">on</span>(&#39;data&#39;, <span class="hljs-keyword">d</span> =&gt; {
    console.<span class="hljs-literal">log</span>(toMarkdown(<span class="hljs-keyword">d</span>.<span class="hljs-keyword">toString</span>()))
  })
<span class="hljs-comment">// ...</span></code></pre><p>If you run the script again, you should see beautiful, super-readable Markdown!
All done!</p>
<hr>
<p>Well, mostly. This is nice and all, but there are definitely some things we can
do to make this script a bit better. Firstly, it&#39;s annoying to have to always
type <code>http://</code> before a URL, so maybe we should automatically add that on.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> url = process.argv[<span class="hljs-number">2</span>]
<span class="hljs-keyword">const</span> src = url.includes(<span class="hljs-string">&#39;http://&#39;</span> || <span class="hljs-string">&#39;https://&#39;</span>) ? url : `http:<span class="hljs-comment">//${url}`</span></code></pre><p>All this extra bit is doing is checking if the passed in argument aleady has a
scheme, and if it doesn&#39;t, just sticking on on the beginning. If you&#39;re not
familiar with template literals, check out the previous tutorials and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">docs
on
MDN</a>.</p>
<p>If you&#39;re not familiar with <code>Array.prototype.includes()</code>, it&#39;s basically a
shorthand for <code>.indexOf(foo !== -1)</code>.</p>
<p>Make sure you change the <code>get</code> call to use <code>src</code> instead of <code>url</code>.</p>
<p>And, as in the previous tutorials, we&#39;ll want to just be able to execute this
script, without needing to type in <code>node</code> each time, so add a shebang and make
it exectuable.</p>
<pre class="hljs"><code><span class="hljs-keyword">chmod</span> +<span class="hljs-keyword">x</span> <span class="hljs-keyword">index</span>.js</code></pre><pre class="hljs"><code>#!<span class="hljs-regexp">/usr/</span>bin/env node

<span class="hljs-keyword">const</span> { <span class="hljs-keyword">get</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>)
<span class="hljs-comment">// ...</span></code></pre><p>Now you should be able to just do something like <code>./index.js zacanger.com</code> and
see some results.</p>
<p><code>to-markdown</code> can handle take some options. One of them is to use
<a href="https://help.github.com/categories/writing-on-github">GitHub-Flavored
Markdown</a>, which is
pretty nice since that&#39;s probably what most of us are used to using. To enable
this, just pass <code>{ gfm: true }</code> in the call to <code>toMarkdown</code>:</p>
<pre class="hljs"><code><span class="hljs-comment">// ...</span>
<span class="hljs-tag">console</span><span class="hljs-class">.log</span>(<span class="hljs-function">toMarkdown</span>(d.<span class="hljs-function">toString</span>(), { <span class="hljs-attribute">gfm</span>: true }))
<span class="hljs-comment">// ...</span></code></pre><p>You may notice some tags are making it through the conversion (<code>script</code>, <code>span</code>,
<code>div</code>, and probably a few others); I&#39;m not going to go over all of the options
that <code>to-markdown</code> can take, but you should check out the docs and learn how to
write filters, if you&#39;re interested. You could also write your own function to
strip out unwanted elements, and run the Markdown through this:</p>
<pre class="hljs"><code>const cleanOutStuff = <span class="hljs-keyword">string</span> =&gt;
  <span class="hljs-keyword">string</span>.<span class="hljs-built_in">replace</span>(/(<span class="hljs-operator">div</span>|script|span)/g, <span class="hljs-string">&#39;&#39;</span>)

console.<span class="hljs-built_in">log</span>(cleanOutStuff(toMarkdown(d.toString(), { gfm: <span class="hljs-constant">true</span> })))</code></pre><p>But it&#39;d probably be easier to just learn the options rather that spinning
something custom like this.</p>
<p>One thing that really irks me when I&#39;m reading in the terminal is text that
doesn&#39;t wrap. Sometimes I&#39;m on a very large screen, and it can get difficult to
keep track of where I am when the text is too wide. 80 characters is a pretty
reasonable limit, so why don&#39;t we get this text to wrap there? We&#39;re going to
use another module for this:
<a href="https://github.com/substack/node-wordwrap">wordwrap</a>.</p>
<pre class="hljs"><code>npm <span class="hljs-tag">i</span> -S wordwrap</code></pre><pre class="hljs"><code>const wordwrap = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">&#39;wordwrap&#39;</span>)</span></span></code></pre><p>This module needs to know how many characters it can put in a line. We could
just pass it <code>80</code>, but I think maybe we should handle cases where the terminal
is resized very small but maybe won&#39;t stay that way, so we&#39;re going to find out
how big the terminal currently is and base our decision on that.
<code>process.stdout</code> has a way for us to find this out.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> wordwrap = require(<span class="hljs-string">&#39;wordwrap&#39;</span>)
<span class="hljs-keyword">const</span> { rows } = process.stdout
<span class="hljs-keyword">const</span> wraplength = (rows &lt; <span class="hljs-number">80</span> ? <span class="hljs-number">80</span> : rows)
<span class="hljs-keyword">const</span> wrapper = wordwrap(wraplength)</code></pre><p>All we&#39;re doing here is wrapping to either the width of the terminal or 80
characters, whichever happens to be greater.</p>
<p>Now we can use that <code>wrapper</code> when we log out the results.</p>
<pre class="hljs"><code><span class="hljs-tag">console</span><span class="hljs-class">.log</span>(<span class="hljs-tag">wrapper</span>(<span class="hljs-tag">toMarkdown</span>(<span class="hljs-tag">d</span><span class="hljs-class">.toString</span>(), <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">gfm</span>:<span class="hljs-value"> true </span></span></span>})))</code></pre><hr>
<p>So, awesome! Your script should now do just about everything you want it to do.
There&#39;s really only one big thing left to do: make it less ugly. That
<code>console.log</code> is really getting gross, don&#39;t you think? I like to handle this by
just defining a bunch of functions I can throw together, so I don&#39;t have to have
all this junk cluttering up my space.</p>
<pre class="hljs"><code>const opts = { gfm: <span class="hljs-constant">true</span> }
const <span class="hljs-built_in">convert</span> = <span class="hljs-operator">a</span> =&gt; toMarkdown(<span class="hljs-operator">a</span>, opts)
const <span class="hljs-operator">wrap</span> = <span class="hljs-operator">a</span> =&gt; wrapper(<span class="hljs-operator">a</span>)
const <span class="hljs-built_in">log</span> = <span class="hljs-operator">a</span> =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-operator">a</span>)</code></pre><p>I&#39;m using <code>a</code> as a parameter here. You can use something more descriptive if
you&#39;d like, it really doesn&#39;t matter.</p>
<p>And I think we should also just wait until we have all the data before logging
anything, so let&#39;s adjust our HTTP call (and stick it in a function):</p>
<pre class="hljs"><code>const main = arg =&gt; get<span class="hljs-list">(<span class="hljs-keyword">arg</span>, res =&gt; {
  let b = &#39;&#39; // <code>b</code> for <code>body</code>
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;data</span>&#39;, d =&gt; b += d.toString)</span>
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;end</span>&#39;, <span class="hljs-list">()</span> =&gt; log<span class="hljs-list">(<span class="hljs-keyword">wrap</span><span class="hljs-list">(<span class="hljs-keyword">convert</span><span class="hljs-list">(<span class="hljs-keyword">b</span>)</span>)</span>)</span>)</span>
})</span></code></pre><p>Your linter might yell at you saying you can&#39;t return assignment. It&#39;s probably
right, but nothing&#39;s going to break. If you&#39;re concerned about it, just wrap
that <code>b += d.toString()</code> in some braces.</p>
<p>Obviously, this is a function, so we need to call it somewhere.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(src)</span></span></code></pre><p>We&#39;re just passing it our URL that may or may not have <code>http://</code> stuck on to it.</p>
<hr>
<p>Now you&#39;re really done! I suggest you go check out <code>to-markdown</code>, play around
with <code>process</code>, and see what else you can do with this thing. If you make
something pretty neat, you should consider releasing it! Check out <code>npm help
adduser</code> and <code>npm help publish</code> to see how you could go about this. (There are
probably similar modules out there, though, so make sure you&#39;re not stepping on
anyone&#39;s toes first!)</p>
<p>I&#39;d also suggest you do some basic error handling, but that&#39;s totally up to you.</p>
<p>For the previous two tutorials I waited until the following post to show a
finished version of the script; since this is the last tutorial on writing CLI
apps in Node that I intend to write, the full script is below, as well as my
manifest file (<code>package.json</code>).</p>
<p>Note: I tend to prefer shorter (but hopefully still readable) names for things,
and a somewhat opinionated code style, so the full script below may differ
a bit from your results, and that&#39;s totally fine.</p>
<pre class="hljs"><code>{
  &quot;<span class="hljs-attribute">name</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;html2txt&quot;</span></span>,
  &quot;<span class="hljs-attribute">description</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;html2text sorta thing for blog post&quot;</span></span>,
  &quot;<span class="hljs-attribute">version</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;0.0.1&quot;</span></span>,
  &quot;<span class="hljs-attribute">author</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">name</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;Zac Anger&quot;</span></span>,
    &quot;<span class="hljs-attribute">email</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;zac@zacanger.com&quot;</span></span>,
    &quot;<span class="hljs-attribute">url</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="http://zacanger.com">http://zacanger.com</a>&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">license</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;WTFPL&quot;</span></span>,
  &quot;<span class="hljs-attribute">main</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;index.js&quot;</span></span>,
  &quot;<span class="hljs-attribute">scripts</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">start</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;node index&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">homepage</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="https://github.com/zacanger/blog#readme">https://github.com/zacanger/blog#readme</a>&quot;</span></span>,
  &quot;<span class="hljs-attribute">repository</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">type</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;git&quot;</span></span>,
    &quot;<span class="hljs-attribute">url</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="https://github.com/zacanger/blog.git">https://github.com/zacanger/blog.git</a>&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">bugs</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="https://github.com/zacanger/blog/issues">https://github.com/zacanger/blog/issues</a>&quot;</span></span>,
  &quot;<span class="hljs-attribute">keywords</span>&quot;: <span class="hljs-value">[
    <span class="hljs-string">&quot;html&quot;</span>,
    <span class="hljs-string">&quot;markdown&quot;</span>
  ]</span>,
  &quot;<span class="hljs-attribute">dependencies</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">to-markdown</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;^3.0.1&quot;</span></span>,
    &quot;<span class="hljs-attribute">wordwrap</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;^1.0.0&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">devDependencies</span>&quot;: <span class="hljs-value">{}
</span>}</code></pre><pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env node</span>

const
  url      = <span class="hljs-built_in">process</span>.argv[<span class="hljs-number">2</span>] || <span class="hljs-string">&#39;zacanger.com&#39;</span>
, { <span class="hljs-built_in">get</span> }  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>)
, { rows } = <span class="hljs-built_in">process</span>.<span class="hljs-keyword">stdout</span>
, <span class="hljs-built_in">len</span>      = (rows &lt; <span class="hljs-number">80</span> ? <span class="hljs-number">80</span> : rows)
, toMd     = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;to-markdown&#39;</span>)
, ww       = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;wordwrap&#39;</span>)
, wrapper  = ww(<span class="hljs-built_in">len</span>)
, opts     = { gfm: <span class="hljs-constant">true</span> }
, conv     = <span class="hljs-operator">a</span> =&gt; toMd(<span class="hljs-operator">a</span>, opts)
, <span class="hljs-operator">wrap</span>     = <span class="hljs-operator">a</span> =&gt; wrapper(<span class="hljs-operator">a</span>)
, <span class="hljs-built_in">log</span>      = <span class="hljs-operator">a</span> =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-operator">a</span>)
, src      = url.includes(<span class="hljs-string">&#39;http://&#39;</span> || <span class="hljs-string">&#39;https://&#39;</span>) ? url : `<span class="hljs-keyword">http</span>://${url}`

const main = <span class="hljs-operator">a</span> =&gt; <span class="hljs-built_in">get</span>(<span class="hljs-operator">a</span>, res =&gt; {
  let b = <span class="hljs-string">&#39;&#39;</span>
  res.on(<span class="hljs-string">&#39;data&#39;</span>, d =&gt; {b += d.toString()})
  res.on(<span class="hljs-string">&#39;end&#39;</span>, () =&gt; <span class="hljs-built_in">log</span>(<span class="hljs-operator">wrap</span>(conv(b))))
})

<span class="hljs-keyword">if</span> (!module.parent) main(src)</code></pre><p>Thanks for reading! If you note any problems, please hit me up <a href="https://twitter.com/zacanger">on
Twitter</a> or put in an issue <a href="https://github.com/zacanger/blog/issues">on
Github</a>.</p>
]]></description><link>/2016/cli-apps-part-three.html</link><guid isPermaLink="true">/2016/cli-apps-part-three.html</guid><category><![CDATA[node]]></category><category><![CDATA[cli]]></category><category><![CDATA[terminal]]></category><category><![CDATA[html]]></category><category><![CDATA[markdown]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Wed, 28 Sep 2016 02:36:00 GMT</pubDate></item><item><title><![CDATA[void elements]]></title><description><![CDATA[<p>i posted this a while back on <a href="http://zacanger.com/blog">my old blog</a> but it&#39;s worth posting again.</p>
<p>obviously this doesn&#39;t apply when using jsx, because everything needs to be closed. but, in jsx, if
it <em>can</em> be a self-closed tag (meaning literally any of these but also anything else that doesn&#39;t
have children), please self-close it.</p>
<ul>
<li>area</li>
<li>base</li>
<li>br</li>
<li>col</li>
<li>embed</li>
<li>hr</li>
<li>img</li>
<li>input</li>
<li>keygen</li>
<li>link</li>
<li>menuitem</li>
<li>meta</li>
<li>param</li>
<li>source</li>
<li>track</li>
<li>wbr</li>
</ul>
<p>see what they all have in common?</p>
<p>you can&#39;t possibly have anything in any of them, like, between tags. what can you put between
an opening and closing line break tag? <strong>nothing</strong>. so why would you need a closing tag?  <strong>you wouldn&#39;t</strong>.
so don&#39;t close it. none of that <code>&lt;img src=&quot;img.jpg&quot;&gt;&lt;/img&gt;</code> bs. No <code>&lt;br /&gt;</code>. and please, please,
never do something just weird like <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styles.css&quot; /&gt;</code>.</p>
]]></description><link>/2016/void-elements.html</link><guid isPermaLink="true">/2016/void-elements.html</guid><category><![CDATA[html]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Tue, 09 Aug 2016 19:58:00 GMT</pubDate></item></channel></rss>