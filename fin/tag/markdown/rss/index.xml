<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[undefined - angr]]></title><description><![CDATA[writings from zac anger]]></description><link>http://blog.zacanger.com/</link><generator>Ghost</generator><lastBuildDate>Fri, 12 May 2017 18:10:17 GMT</lastBuildDate><atom:link href="http://blog.zacanger.com/tag/undefined/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[html2text in node tutorial]]></title><description><![CDATA[<p>Okay, ready to build another command-line app in Node?</p>
<p>If you haven&#39;t seen my last two posts, you should check them out, since I&#39;m not
going to cover a lot of the basics again. They&#39;re both on writing small cli apps
in Node, with no dependencies.</p>
<ul>
<li><a href="http://blog.zacanger.com/2016/a-basic-cli-app-in-node.html">React component generator</a></li>
<li><a href="http://blog.zacanger.com/2016/note-taking-app.html">JSON Note-taking app</a></li>
</ul>
<p>And here&#39;s the finished product from the latter:</p>
<pre class="hljs"><code>#!/usr/bin/env node

&#39;<span class="hljs-keyword">use</span> strict&#39;

<span class="hljs-keyword">const</span> {
  readFileSync
, writeFile
}       = require(&#39;fs&#39;)
, <span class="hljs-keyword">log</span>   = console.<span class="hljs-literal">log</span>
, arg   = process.argv[2]
, <span class="hljs-keyword">n</span>     = &#39;./<span class="hljs-keyword">notes</span>.json&#39;
, <span class="hljs-keyword">file</span>  = readFileSync(<span class="hljs-keyword">n</span>)
, <span class="hljs-keyword">notes</span> = JSON.<span class="hljs-keyword">parse</span>(<span class="hljs-keyword">file</span>)

<span class="hljs-keyword">const</span> writeTheFile = () =&gt; {
  <span class="hljs-keyword">const</span> taken = JSON.stringify(<span class="hljs-keyword">notes</span>, null, 2)
  writeFile(<span class="hljs-keyword">n</span>, taken, &#39;utf8&#39;, <span class="hljs-keyword">err</span> =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">err</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(<span class="hljs-keyword">err</span>)
  })
}

<span class="hljs-keyword">const</span> takeNote = (<span class="hljs-keyword">notes</span>, <span class="hljs-keyword">note</span>) =&gt; {
  <span class="hljs-keyword">notes</span>.push(<span class="hljs-keyword">note</span>)
  writeTheFile()
}

<span class="hljs-keyword">const</span> removeNote = (<span class="hljs-keyword">notes</span>, noteIndex) =&gt; {
  <span class="hljs-keyword">notes</span>.splice(noteIndex -1, 1)
  writeTheFile()
}

<span class="hljs-keyword">const</span> runApp = () =&gt; {
  <span class="hljs-keyword">if</span> (arg) {
    switch (arg) {
      case &#39;-s&#39;:
        <span class="hljs-literal">log</span>(<span class="hljs-keyword">notes</span>)
        <span class="hljs-keyword">break</span>
      case &#39;-r&#39;:
        <span class="hljs-keyword">const</span> noteIndex = process.argv[3]
        removeNote(<span class="hljs-keyword">notes</span>, noteIndex)
        <span class="hljs-keyword">break</span>
      default:
        takeNote(<span class="hljs-keyword">notes</span>, arg)
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">log</span>(&#39;Please pass <span class="hljs-keyword">an</span> argument&#39;)
  }
}

<span class="hljs-keyword">if</span> (!module.parent) {
  runApp()
}</code></pre><hr>
<p>What we&#39;re going to build this time is going to be a little more complex. We&#39;re
going to write a program that downloads a website and turns it into Markdown for
easy offline reading. This isn&#39;t a new concept, and I actually use a Python script
called <a href="https://github.com/aaronsw/html2text">html2text</a> for this on an
almost-daily basis, but just for fun, we&#39;ll do something similar in Node.</p>
<p>This will also be the first time we&#39;ll be working with external modules, which
is really the most exciting and awesome thing about Node.</p>
<p>Our goal here is to have a small tool we can use like this:</p>
<pre class="hljs"><code>./index<span class="hljs-class">.js</span> zacanger.com</code></pre><p>And it&#39;ll give us back the contents of <code>zacanger.com</code>, in Markdown, ready to
read in the terminal, pipe to an editor, or whatever.</p>
<p>First things first: we&#39;ll need a project. Make a new directory and get into it,
and <code>npm init</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">mkdir</span> html2txt
<span class="hljs-keyword">cd</span> html2xt
npm init -<span class="hljs-literal">y</span></code></pre><p>The <code>-y</code> flag just means &quot;don&#39;t ask me questions.&quot; You can skip that flag and
fill in the info for your <code>package.json</code> if you&#39;d like, or just go back and edit
it later.</p>
<p>We&#39;re going to be using a couple of things built-in to Node, so we can go ahead
and require them now. We&#39;ll need <code>http</code>&#39;s <code>get</code> method, and also a way to work
with an argument. If you&#39;ve done either of my previous tutorials, you&#39;ll already
be familiar with Node&#39;s <code>process.argv</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> { <span class="hljs-keyword">get</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>)
<span class="hljs-keyword">const</span> url = process.argv[<span class="hljs-number">2</span>]</code></pre><p>Let&#39;s see if we can&#39;t get some HTML, just as a starting point.</p>
<pre class="hljs"><code>get<span class="hljs-list">(<span class="hljs-keyword">url</span>, res =&gt; {
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;data</span>&#39;, d =&gt; {
    console.log<span class="hljs-list">(<span class="hljs-keyword">d</span>)</span>
  })</span>
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;end</span>&#39;, <span class="hljs-list">()</span> =&gt; {
    console.log<span class="hljs-list">(<span class="hljs-quoted">&#39;done</span>&#39;)</span>
  })</span>
})</span></code></pre><p>Try that out with something like <code>node index.js http://google.com</code>.</p>
<p>You should see something like <code>&lt;Buffer 3c 21 64 6f 63 74 7</code> (and so on).
<a href="https://nodejs.org/api/buffer.html">Buffers</a> are great and all, but that&#39;s
pretty useless for actual reading. Try calling <code>toString</code> on that data and you
should see some actual HTML (<code>console.log(d.toString())</code>).</p>
<p>(Note: you may see a 301 page here.)</p>
<p>Awesome! We now have all the functionality of prepending <code>view-source:</code> to a URL
in the browser. Let&#39;s do something with that HTML, since it&#39;s probably not how
you prefer to read stuff.</p>
<p>There are a lot of great modules out there for working with Markdown. For this
post, I&#39;ve decided to go with a super simple one without a whole lot of options,
<a href="https://www.npmjs.com/package/to-markdown">to-markdown</a>. If you&#39;re not super
familiar with npm, you&#39;re about to learn just about all you need to know to get
started.</p>
<p>In your terminal, <code>npm i -S to-markdown</code>. This is a shorthand for the command
<code>npm install --save to-markdown</code>; most npm commands have shorter versions, and
it can really save you a lot of time if you get used to using them.</p>
<p>You should see a bunch of stuff happen in the terminal. If you check your
<code>package.json</code>, you&#39;ll now see <code>to-markdown</code> in there. It should like something
like this:</p>
<pre class="hljs"><code><span class="hljs-collection">{
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;something&quot;</span>,
  // probably some other stuff
  <span class="hljs-string">&quot;dependencies&quot;</span>: <span class="hljs-collection">{
    <span class="hljs-string">&quot;to-markdown&quot;</span>: <span class="hljs-string">&quot;^3.0.1&quot;</span>
  }</span>
}</span></code></pre><p>(Yes, I know you can&#39;t have comments in JSON.)</p>
<p>Next we&#39;ll need to get that into the program. If you&#39;re using Babel, you can use
<code>import</code>, but to keep things simple we&#39;ll stick with <code>require</code>.</p>
<pre class="hljs"><code>const toMarkdown = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">&#39;to-markdown&#39;</span>)</span></span></code></pre><p>Now try running the HTML through this before logging it out.</p>
<pre class="hljs"><code><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> toMarkdown = require(&#39;to-markdown&#39;)
<span class="hljs-comment">// ...</span>
  res.<span class="hljs-keyword">on</span>(&#39;data&#39;, <span class="hljs-keyword">d</span> =&gt; {
    console.<span class="hljs-literal">log</span>(toMarkdown(<span class="hljs-keyword">d</span>.<span class="hljs-keyword">toString</span>()))
  })
<span class="hljs-comment">// ...</span></code></pre><p>If you run the script again, you should see beautiful, super-readable Markdown!
All done!</p>
<hr>
<p>Well, mostly. This is nice and all, but there are definitely some things we can
do to make this script a bit better. Firstly, it&#39;s annoying to have to always
type <code>http://</code> before a URL, so maybe we should automatically add that on.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> url = process.argv[<span class="hljs-number">2</span>]
<span class="hljs-keyword">const</span> src = url.includes(<span class="hljs-string">&#39;http://&#39;</span> || <span class="hljs-string">&#39;https://&#39;</span>) ? url : `http:<span class="hljs-comment">//${url}`</span></code></pre><p>All this extra bit is doing is checking if the passed in argument aleady has a
scheme, and if it doesn&#39;t, just sticking on on the beginning. If you&#39;re not
familiar with template literals, check out the previous tutorials and the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">docs
on
MDN</a>.</p>
<p>If you&#39;re not familiar with <code>Array.prototype.includes()</code>, it&#39;s basically a
shorthand for <code>.indexOf(foo !== -1)</code>.</p>
<p>Make sure you change the <code>get</code> call to use <code>src</code> instead of <code>url</code>.</p>
<p>And, as in the previous tutorials, we&#39;ll want to just be able to execute this
script, without needing to type in <code>node</code> each time, so add a shebang and make
it exectuable.</p>
<pre class="hljs"><code><span class="hljs-keyword">chmod</span> +<span class="hljs-keyword">x</span> <span class="hljs-keyword">index</span>.js</code></pre><pre class="hljs"><code>#!<span class="hljs-regexp">/usr/</span>bin/env node

<span class="hljs-keyword">const</span> { <span class="hljs-keyword">get</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>)
<span class="hljs-comment">// ...</span></code></pre><p>Now you should be able to just do something like <code>./index.js zacanger.com</code> and
see some results.</p>
<p><code>to-markdown</code> can handle take some options. One of them is to use
<a href="https://help.github.com/categories/writing-on-github">GitHub-Flavored
Markdown</a>, which is
pretty nice since that&#39;s probably what most of us are used to using. To enable
this, just pass <code>{ gfm: true }</code> in the call to <code>toMarkdown</code>:</p>
<pre class="hljs"><code><span class="hljs-comment">// ...</span>
<span class="hljs-tag">console</span><span class="hljs-class">.log</span>(<span class="hljs-function">toMarkdown</span>(d.<span class="hljs-function">toString</span>(), { <span class="hljs-attribute">gfm</span>: true }))
<span class="hljs-comment">// ...</span></code></pre><p>You may notice some tags are making it through the conversion (<code>script</code>, <code>span</code>,
<code>div</code>, and probably a few others); I&#39;m not going to go over all of the options
that <code>to-markdown</code> can take, but you should check out the docs and learn how to
write filters, if you&#39;re interested. You could also write your own function to
strip out unwanted elements, and run the Markdown through this:</p>
<pre class="hljs"><code>const cleanOutStuff = <span class="hljs-keyword">string</span> =&gt;
  <span class="hljs-keyword">string</span>.<span class="hljs-built_in">replace</span>(/(<span class="hljs-operator">div</span>|script|span)/g, <span class="hljs-string">&#39;&#39;</span>)

console.<span class="hljs-built_in">log</span>(cleanOutStuff(toMarkdown(d.toString(), { gfm: <span class="hljs-constant">true</span> })))</code></pre><p>But it&#39;d probably be easier to just learn the options rather that spinning
something custom like this.</p>
<p>One thing that really irks me when I&#39;m reading in the terminal is text that
doesn&#39;t wrap. Sometimes I&#39;m on a very large screen, and it can get difficult to
keep track of where I am when the text is too wide. 80 characters is a pretty
reasonable limit, so why don&#39;t we get this text to wrap there? We&#39;re going to
use another module for this:
<a href="https://github.com/substack/node-wordwrap">wordwrap</a>.</p>
<pre class="hljs"><code>npm <span class="hljs-tag">i</span> -S wordwrap</code></pre><pre class="hljs"><code>const wordwrap = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">&#39;wordwrap&#39;</span>)</span></span></code></pre><p>This module needs to know how many characters it can put in a line. We could
just pass it <code>80</code>, but I think maybe we should handle cases where the terminal
is resized very small but maybe won&#39;t stay that way, so we&#39;re going to find out
how big the terminal currently is and base our decision on that.
<code>process.stdout</code> has a way for us to find this out.</p>
<pre class="hljs"><code><span class="hljs-keyword">const</span> wordwrap = require(<span class="hljs-string">&#39;wordwrap&#39;</span>)
<span class="hljs-keyword">const</span> { rows } = process.stdout
<span class="hljs-keyword">const</span> wraplength = (rows &lt; <span class="hljs-number">80</span> ? <span class="hljs-number">80</span> : rows)
<span class="hljs-keyword">const</span> wrapper = wordwrap(wraplength)</code></pre><p>All we&#39;re doing here is wrapping to either the width of the terminal or 80
characters, whichever happens to be greater.</p>
<p>Now we can use that <code>wrapper</code> when we log out the results.</p>
<pre class="hljs"><code><span class="hljs-tag">console</span><span class="hljs-class">.log</span>(<span class="hljs-tag">wrapper</span>(<span class="hljs-tag">toMarkdown</span>(<span class="hljs-tag">d</span><span class="hljs-class">.toString</span>(), <span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">gfm</span>:<span class="hljs-value"> true </span></span></span>})))</code></pre><hr>
<p>So, awesome! Your script should now do just about everything you want it to do.
There&#39;s really only one big thing left to do: make it less ugly. That
<code>console.log</code> is really getting gross, don&#39;t you think? I like to handle this by
just defining a bunch of functions I can throw together, so I don&#39;t have to have
all this junk cluttering up my space.</p>
<pre class="hljs"><code>const opts = { gfm: <span class="hljs-constant">true</span> }
const <span class="hljs-built_in">convert</span> = <span class="hljs-operator">a</span> =&gt; toMarkdown(<span class="hljs-operator">a</span>, opts)
const <span class="hljs-operator">wrap</span> = <span class="hljs-operator">a</span> =&gt; wrapper(<span class="hljs-operator">a</span>)
const <span class="hljs-built_in">log</span> = <span class="hljs-operator">a</span> =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-operator">a</span>)</code></pre><p>I&#39;m using <code>a</code> as a parameter here. You can use something more descriptive if
you&#39;d like, it really doesn&#39;t matter.</p>
<p>And I think we should also just wait until we have all the data before logging
anything, so let&#39;s adjust our HTTP call (and stick it in a function):</p>
<pre class="hljs"><code>const main = arg =&gt; get<span class="hljs-list">(<span class="hljs-keyword">arg</span>, res =&gt; {
  let b = &#39;&#39; // <code>b</code> for <code>body</code>
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;data</span>&#39;, d =&gt; b += d.toString)</span>
  res.on<span class="hljs-list">(<span class="hljs-quoted">&#39;end</span>&#39;, <span class="hljs-list">()</span> =&gt; log<span class="hljs-list">(<span class="hljs-keyword">wrap</span><span class="hljs-list">(<span class="hljs-keyword">convert</span><span class="hljs-list">(<span class="hljs-keyword">b</span>)</span>)</span>)</span>)</span>
})</span></code></pre><p>Your linter might yell at you saying you can&#39;t return assignment. It&#39;s probably
right, but nothing&#39;s going to break. If you&#39;re concerned about it, just wrap
that <code>b += d.toString()</code> in some braces.</p>
<p>Obviously, this is a function, so we need to call it somewhere.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(src)</span></span></code></pre><p>We&#39;re just passing it our URL that may or may not have <code>http://</code> stuck on to it.</p>
<hr>
<p>Now you&#39;re really done! I suggest you go check out <code>to-markdown</code>, play around
with <code>process</code>, and see what else you can do with this thing. If you make
something pretty neat, you should consider releasing it! Check out <code>npm help
adduser</code> and <code>npm help publish</code> to see how you could go about this. (There are
probably similar modules out there, though, so make sure you&#39;re not stepping on
anyone&#39;s toes first!)</p>
<p>I&#39;d also suggest you do some basic error handling, but that&#39;s totally up to you.</p>
<p>For the previous two tutorials I waited until the following post to show a
finished version of the script; since this is the last tutorial on writing CLI
apps in Node that I intend to write, the full script is below, as well as my
manifest file (<code>package.json</code>).</p>
<p>Note: I tend to prefer shorter (but hopefully still readable) names for things,
and a somewhat opinionated code style, so the full script below may differ
a bit from your results, and that&#39;s totally fine.</p>
<pre class="hljs"><code>{
  &quot;<span class="hljs-attribute">name</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;html2txt&quot;</span></span>,
  &quot;<span class="hljs-attribute">description</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;html2text sorta thing for blog post&quot;</span></span>,
  &quot;<span class="hljs-attribute">version</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;0.0.1&quot;</span></span>,
  &quot;<span class="hljs-attribute">author</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">name</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;Zac Anger&quot;</span></span>,
    &quot;<span class="hljs-attribute">email</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;zac@zacanger.com&quot;</span></span>,
    &quot;<span class="hljs-attribute">url</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="http://zacanger.com">http://zacanger.com</a>&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">license</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;WTFPL&quot;</span></span>,
  &quot;<span class="hljs-attribute">main</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;index.js&quot;</span></span>,
  &quot;<span class="hljs-attribute">scripts</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">start</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;node index&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">homepage</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="https://github.com/zacanger/blog#readme">https://github.com/zacanger/blog#readme</a>&quot;</span></span>,
  &quot;<span class="hljs-attribute">repository</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">type</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;git&quot;</span></span>,
    &quot;<span class="hljs-attribute">url</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="https://github.com/zacanger/blog.git">https://github.com/zacanger/blog.git</a>&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">bugs</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;<a href="https://github.com/zacanger/blog/issues">https://github.com/zacanger/blog/issues</a>&quot;</span></span>,
  &quot;<span class="hljs-attribute">keywords</span>&quot;: <span class="hljs-value">[
    <span class="hljs-string">&quot;html&quot;</span>,
    <span class="hljs-string">&quot;markdown&quot;</span>
  ]</span>,
  &quot;<span class="hljs-attribute">dependencies</span>&quot;: <span class="hljs-value">{
    &quot;<span class="hljs-attribute">to-markdown</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;^3.0.1&quot;</span></span>,
    &quot;<span class="hljs-attribute">wordwrap</span>&quot;: <span class="hljs-value"><span class="hljs-string">&quot;^1.0.0&quot;</span>
  </span>}</span>,
  &quot;<span class="hljs-attribute">devDependencies</span>&quot;: <span class="hljs-value">{}
</span>}</code></pre><pre class="hljs"><code><span class="hljs-comment">#!/usr/bin/env node</span>

const
  url      = <span class="hljs-built_in">process</span>.argv[<span class="hljs-number">2</span>] || <span class="hljs-string">&#39;zacanger.com&#39;</span>
, { <span class="hljs-built_in">get</span> }  = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;http&#39;</span>)
, { rows } = <span class="hljs-built_in">process</span>.<span class="hljs-keyword">stdout</span>
, <span class="hljs-built_in">len</span>      = (rows &lt; <span class="hljs-number">80</span> ? <span class="hljs-number">80</span> : rows)
, toMd     = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;to-markdown&#39;</span>)
, ww       = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#39;wordwrap&#39;</span>)
, wrapper  = ww(<span class="hljs-built_in">len</span>)
, opts     = { gfm: <span class="hljs-constant">true</span> }
, conv     = <span class="hljs-operator">a</span> =&gt; toMd(<span class="hljs-operator">a</span>, opts)
, <span class="hljs-operator">wrap</span>     = <span class="hljs-operator">a</span> =&gt; wrapper(<span class="hljs-operator">a</span>)
, <span class="hljs-built_in">log</span>      = <span class="hljs-operator">a</span> =&gt; console.<span class="hljs-built_in">log</span>(<span class="hljs-operator">a</span>)
, src      = url.includes(<span class="hljs-string">&#39;http://&#39;</span> || <span class="hljs-string">&#39;https://&#39;</span>) ? url : `<span class="hljs-keyword">http</span>://${url}`

const main = <span class="hljs-operator">a</span> =&gt; <span class="hljs-built_in">get</span>(<span class="hljs-operator">a</span>, res =&gt; {
  let b = <span class="hljs-string">&#39;&#39;</span>
  res.on(<span class="hljs-string">&#39;data&#39;</span>, d =&gt; {b += d.toString()})
  res.on(<span class="hljs-string">&#39;end&#39;</span>, () =&gt; <span class="hljs-built_in">log</span>(<span class="hljs-operator">wrap</span>(conv(b))))
})

<span class="hljs-keyword">if</span> (!module.parent) main(src)</code></pre><p>Thanks for reading! If you note any problems, please hit me up <a href="https://twitter.com/zacanger">on
Twitter</a> or put in an issue <a href="https://github.com/zacanger/blog/issues">on
Github</a>.</p>
]]></description><link>/2016/cli-apps-part-three.html</link><guid isPermaLink="true">/2016/cli-apps-part-three.html</guid><category><![CDATA[node]]></category><category><![CDATA[cli]]></category><category><![CDATA[terminal]]></category><category><![CDATA[html]]></category><category><![CDATA[markdown]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Wed, 28 Sep 2016 02:36:00 GMT</pubDate></item><item><title><![CDATA[notes from my personal project at devmountain]]></title><description><![CDATA[<h1 id="this-is-probably-a-mess">this is probably a mess</h1>
<p>a whole bunch of basically totally disorganised notes from when i was working
on my &#39;personal project&#39; at devmountain.</p>
<p>this was meant to be a sort of ghost/medium for the desktop -- a blogging platform
for people who actually cared about writing. turns out no one really wants that.
also it turns out <a href="https://github.com/TryGhost/Ghost-Desktop">ghost was working on a desktop application</a>
cool.</p>
<p>requirements for this: make a mean stack app, basically.</p>
<p>anyway <a href="https://github.com/zacanger/ayuba">this is the remains of that poor app i built</a>
and more importantly here&#39;s the mess of notes i took while doing stuff with that.</p>
<hr>
<h2 id="planner">Planner</h2>
<p>At DevMountain, for projects, you&#39;re encouraged (required, really) to use a planning
paper, which is basically a big sheet of paper divided up into sections that represent
pieces of a standard MEAN-stack app, and a sort of roadmap-to-an-end-product thing along
the bottom.</p>
<p>I was actually out sick the day those got handed out for the personal projects, but NBD,
there was a PDF version floating around so I threw a little app up using that (converted to
PNG and colour-inverted) using a little bit of PHP and jQuery to make a kind of sticky-notes
bulletin-board kind of thingy to serve the same purpose. One benefit of this is that I was
able to easily just save all my notes out (they were all just in a big text file anyway, on
my server). Note: I&#39;d initially planned on using my earlier app from my &#39;no-server&#39; project
(something we do at DevMountain early on, just an Angular app that can actually use a server
so long as it&#39;s a BaaS and not one we&#39;ve spent time doing, because we don&#39;t actually know how
to do that at that point) called <a href="https://github.com/zacanger/markvi">markvi</a>.</p>
<p>Anyway, these are the contents from my planning thing.</p>
<h3 id="ideas-and-users">Ideas and Users</h3>
<p>concept: a blogging platform <em>for writers, and readers</em>, based not around the
ADHD social media style of content-creation and likes and shares that&#39;s taken
over the popular idea of the blog, but instead around long-form writing; essays,
meaningful stories, and such. the target audience here is the moderately
technically savvy pseudo-bohemian; 25-50, used to smoke cloves, probably hangs
out in coffee shops too much.</p>
<h3 id="features">Features</h3>
<ul>
<li>mvp: oh wait, that&#39;s already done. well, except for getting it to work in the
desktop client, which is the entire idea here.</li>
<li>the rest:<ul>
<li>a clean, simple &#39;feed&#39; (a la jekyll archive pages), filterable by tag and possibly date.</li>
<li>comments.</li>
<li>import/export without relying on the browser (to markdown and html).</li>
</ul>
</li>
</ul>
<h3 id="views">Views</h3>
<ol>
<li>the existing markdown editor (however, likely revamped to move away from
plain old codemirror, and to include a basic rte-style toolbar).</li>
<li>the rendered panel, alone (the reading view; same on one&#39;s own posts as
someone else&#39;s).</li>
<li>the &#39;social&#39; view: a feed, no &#39;content-based&#39; sorting, just purely ordered
chronologically, and filterable by tag (and POSSIBLY date range).</li>
<li>-ish?: comments. they&#39;ll be isolated (data-wise), so it may be smarter to
load them in dynamically (see: discourse [not discuz, they&#39;re ruby], but don&#39;t
do that stupid thing where half the page disappears, that&#39;s some annoying-ass
bullshit).</li>
<li>settings. VERY simple. name, email, password, export (if possible) to an
archive file, delete account.</li>
</ol>
<h3 id="controllers">Controllers</h3>
<ul>
<li>browser, main, and nav (see existing codebase)</li>
<li>not controllers, but...</li>
<li>services: files (existing)</li>
<li>filters: filename and cut (existing)<ul>
<li>by tag (feed view)</li>
<li>(also possibly by date -- narrowing -- feed view)</li>
</ul>
</li>
</ul>
<h3 id="endpoints">Endpoints</h3>
<p>Those are a thing, yes.</p>
<h3 id="schemas">Schemas</h3>
<pre class="hljs"><code>// possible schemas ??

<span class="hljs-keyword">const</span> mongoose = require(&#39;mongoose&#39;)

<span class="hljs-keyword">const</span> user = mongoose.<span class="hljs-type">Schema</span>({
  username : {<span class="hljs-keyword">type</span> : <span class="hljs-type">String</span>, required : <span class="hljs-literal">true</span>}
, pass     : {<span class="hljs-keyword">type</span> : <span class="hljs-type">String</span>, required : <span class="hljs-literal">true</span>, minlength : <span class="hljs-number">6</span>}
, post     : [{mongoose.<span class="hljs-type">Types</span>.<span class="hljs-type">ObjectId</span>, <span class="hljs-keyword">ref</span> : &#39;post&#39;}]
, comments : [{mongoose.<span class="hljs-type">Types</span>.<span class="hljs-type">ObjectId</span>, <span class="hljs-keyword">ref</span> : &#39;comment&#39;}]
})

<span class="hljs-keyword">const</span> post = mongoose.<span class="hljs-type">Schema</span>({
  title    : {<span class="hljs-keyword">type</span> : <span class="hljs-type">String</span>, required : <span class="hljs-literal">true</span>}
, content  : {<span class="hljs-keyword">type</span> : <span class="hljs-type">String</span>, required : <span class="hljs-literal">true</span>}
, tags     : <span class="hljs-type">Array</span>
, date     : {<span class="hljs-keyword">type</span> : <span class="hljs-type">Number</span>, default : new <span class="hljs-type">Date</span>()}
, author   : [{mongoose.<span class="hljs-type">Types</span>.<span class="hljs-type">ObjectId</span>, <span class="hljs-keyword">ref</span> : &#39;user&#39;}]
, comments : [{mongoose.<span class="hljs-type">Types</span>.<span class="hljs-type">ObjectID</span>, <span class="hljs-keyword">ref</span> : &#39;comment&#39;}]
})

<span class="hljs-keyword">const</span> comment = mongoose.<span class="hljs-type">Schema</span>({
  date    : {<span class="hljs-keyword">type</span> : <span class="hljs-type">Number</span>, default  : new <span class="hljs-type">Date</span>()}
, content : {<span class="hljs-keyword">type</span> : <span class="hljs-type">String</span>, required : <span class="hljs-literal">true</span>}
, post    : [{mongoose.<span class="hljs-type">Types</span>.<span class="hljs-type">ObjectId</span>, <span class="hljs-keyword">ref</span> : &#39;posts&#39;}]
, author  : [{mongoose.<span class="hljs-type">Types</span>.<span class="hljs-type">ObjectId</span>, <span class="hljs-keyword">ref</span> : &#39;user&#39;}]
})

mongoose.model(&#39;user&#39;, user)
mongoose.model(&#39;post&#39;, post)
mongoose.model(&#39;comment&#39;, comment)</code></pre><h3 id="other-thoughts-">Other Thoughts:</h3>
<p>this would be relatively easy to throw up in a web browser. blogging platforms
are a dime a dozen, especially ones built on node. the idea here isn&#39;t to make
another tumblr, but to bring actual writing back to the web. sort of like
medium, but without all the twitter. a key part of that is having it NOT be in a
browser. right now the goal is to put all this in an electron shell, but i&#39;m not
going to focus super hardcore on that right this moment. if i can get everything
else in place and rock-solid first, then i&#39;ll stuff it all in electron. if not,
then i&#39;ll just write up a manifest file and call it a chrome app. either way,
fuck y&#39;all, it&#39;s already got nigh on a thousand installs....</p>
<hr>
<h2 id="the-presentation-speech">The Presentation Speech</h2>
<p>This is what I&#39;d planned to say when presenting my app. I think instead
I just kind of mumbled a little bit about how neat CodeMirror is and how
annoying it was to struggle with the <code>&#39;node-integration&#39;</code> issue with
Electron.</p>
<h3 id="markdown">Markdown</h3>
<p>…is a lightweight markup language which makes writing for the web a much quicker
and easier process than if using a rich text editor (like Word), which wouldn&#39;t
translate to HTML anyway, or writing HTML manually. Intead of <code>&lt;em&gt;</code> or
<code>&lt;strong&gt;</code>, in Markdown you&#39;d use a <code>_</code> or <code>*</code>, or <code>__</code> or <code>**</code>. Readme files on
Github are usually written in an implementation of Markdown called Github
Flavoured Markdown, which shows just how popular the format has grown. Stack
Overflow, the Discourse comment system, and various blog systems including
Ghost, Wordpress, Tumblr all use Markdown, if not by default than as an option.</p>
<p>vi is possibly the most influential editor of, like, ever. it was written in
1976, and either vi or one of its descendants (usually vim, which stands for &#39;vi
improved&#39;) has been on almost every unix-based system since then, including
every computer in this building (except the microsoft machines -- and even on
those, if you have git-bash or something similar). vim&#39;s power comes from how
easily and quickly it can manipulate large chunks of text. For example, typing
in <code>d5k</code> will delete five lines upwards, and<code>497G</code> jumps to line 497.</p>
<p>So, putting these things together makes for a really great tool for writing. Not
necessarily writing Tweets or Facebook posts, but writing longer texts, like
articles or essays. That&#39;s the purpose of this app. It&#39;s not a social blog. It&#39;s
kind of like Medium minus Twitter, Tumblr minus reblogging, or LiveJournal
minus… teenagers.</p>
<p>Since the editor component itself is based around CodeMirror, it&#39;s very
extensible, which is exciting because it leaves so much open for future
development. For example, if we wanted to make this a Javascript editor instead,
we could just change a few lines and now we have the right syntax highlighting,
automatic indentation, et cetera.</p>
<p>Oh, and, so, this is all a desktop app. It runs perfectly fine in a browser, but
from the beginning it was really meant to be a desktop tool; browsers are
distracting, this not so much.</p>
<p>Aaaand here&#39;s the code.</p>
<hr>
<h2 id="misc-notes">misc notes</h2>
<p>All this stuff was just thrown in another file.
It&#39;s mostly to do with <a href="https://electron.atom.io">Electron</a>, I think.</p>
<p>check <a href="https://github.com/atom/electron/blob/master/docs%2Fapi%2Fbrowser-window.md">https://github.com/atom/electron/blob/master/docs%2Fapi%2Fbrowser-window.md</a>
before trying to get any other browser-shit going on--we&#39;ll want to move things
into their own windows, i feel; chromeless might be a good idea, at least for
the editor view</p>
<pre class="hljs"><code>const BrowserWindow = <span class="hljs-function"><span class="hljs-title">require</span><span class="hljs-params">(<span class="hljs-string">&#39;electron&#39;</span>)</span></span><span class="hljs-class">.BrowserWindow</span>
let win = new <span class="hljs-function"><span class="hljs-title">BrowserWindow</span><span class="hljs-params">({width : <span class="hljs-number">1900</span>, height : <span class="hljs-number">1600</span>, frame : false})</span></span></code></pre><p>so basically it&#39;s just a new browser window, frame as false, but we want to
probably lock the px to whatever screen we&#39;re working with, if CSS continues to
fail miserably.</p>
<p>-- note: check how atom manages to not fuck that up. except those bits where
they do.</p>
<p>frameless = non-draggable (even with alt?). specify <code>-webkit-app-region: drag</code>
in css. or, say, <code>body { -webkit-app-region: drag }</code> for all of that. this
necessitates <code>button { -webkit-app-region: no-drag }</code> (same for non-button
clickables, one assumes).</p>
<ul>
<li><code>DownloadItem</code> is an eventemitter. will-download event of Session.</li>
<li>downloadItem.setSavePath(path)</li>
<li>downloadItem.cancel()</li>
<li>downloadItem.getURL() // origin url</li>
<li>file.path = real (fs) path</li>
</ul>
<h3 id="printing">printing</h3>
<pre class="hljs"><code>webContents.printToPDF(opts, cb) <span class="hljs-comment">// where:</span>
opts:
  marginsType: <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> (<span class="hljs-number">0</span> <span class="hljs-keyword">default</span>)
  pageSize: <span class="hljs-string">&#39;A4&#39;</span>, <span class="hljs-string">&#39;A3&#39;</span>, <span class="hljs-string">&#39;Legal&#39;</span>, <span class="hljs-string">&#39;Letter&#39;</span>, <span class="hljs-string">&#39;Tabloid&#39;</span>
  printBackground: <span class="hljs-keyword">false</span> (duh)
  landscape: <span class="hljs-keyword">false</span> (is portrait)
cb <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err, data)</span></span>{<span class="hljs-keyword">if</span> err etc, data = content buffer}

<span class="hljs-keyword">empty</span> opts = <code>{marginsType: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, printBackground: &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;, printSelectionOnly: &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;, landscape: &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;}</code>

<span class="hljs-comment">// sample from electron docs</span>
<span class="hljs-keyword">const</span> BrowserWindow = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#39;electron&#39;</span>).BrowserWindow
<span class="hljs-keyword">const</span> fs = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#39;fs&#39;</span>)
<span class="hljs-keyword">let</span> win = <span class="hljs-keyword">new</span> BrowserWindow({width: <span class="hljs-number">800</span>, height: <span class="hljs-number">600</span>})
win.loadURL(<span class="hljs-string">&#39;<a href="http://github.com">http://github.com</a>&#39;</span>)
win.webContents.on(<span class="hljs-string">&#39;did-finish-load&#39;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// Use default printing options</span>
  win.webContents.printToPDF({}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error, data)</span> </span>{
    <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-keyword">throw</span> error
    }
    fs.writeFile(<span class="hljs-string">&#39;/tmp/print.pdf&#39;</span>, data, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
      <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-keyword">throw</span> error
      }
      console.log(<span class="hljs-string">&#39;done did dat&#39;</span>)
    })
  })
})</code></pre><ul>
<li>main process is a normal node script</li>
<li>renderer process is a normal website, plus node modules (eg in script tags or whatever)</li>
<li>electron&#39;s built-in modules don&#39;t need <code>require(&#39;asdf&#39;)</code>; set
<code>process.env.ELECTRON_HIDE_INTERNAL_MODULES = TRUE</code></li>
<li>shell.openExternal(url) opens in eg xdg-browser</li>
<li>shell.openItem(&#39;/FULL/path/to/item&#39;) = xdg-open</li>
</ul>
<h3 id="menus">menus</h3>
<ul>
<li>new MenuItem(opts):<ul>
<li>id: string, unique within menu</li>
<li>submenu</li>
<li>checked: bool</li>
<li>visible: bool</li>
<li>enabled: bool</li>
<li>label: string</li>
<li>type: normal, separator, submenu, checkbox, or radio</li>
<li>role: action; if specified, next thing will be ignored</li>
<li>click: function -- click(menuItem, browserWindow) -- this is that &#39;next thing&#39;</li>
</ul>
</li>
<li>recommended to set role:<ul>
<li>undo</li>
<li>redo</li>
<li>cut</li>
<li>copy</li>
<li>paste</li>
<li>selectall</li>
<li>minimize</li>
<li>close</li>
</ul>
</li>
</ul>
<p>electron-rebuild would automatically take care of headers &amp; native node module
builds. so, after each <code>npm i</code>, do a <code>./node_modules/.bin/electron-rebuild</code></p>
<p>the &#39;npm&#39; way: same as usual, except env variables:</p>
<pre class="hljs"><code><span class="hljs-keyword">export</span>
  npm_config_disturl=https:<span class="hljs-comment">//atom.io/download/atom-shell</span>
  npm_config_target=<span class="hljs-number">0.33</span><span class="hljs-number">.1</span> <span class="hljs-preprocessor"># ???</span>
  npm_config_arch=x64
  npm_config_runtime=electron
HOME=~/.electron-gyp npm install module-name <span class="hljs-preprocessor"># home equals? what?</span></code></pre><p>one important thing: nw.js&#39;s url in the package file? nah, bro, electron don&#39;t
do that shit. so manually creating the browser window and loading HTML is the
right way with electron.</p>
]]></description><link>/2016/personal-project.html</link><guid isPermaLink="true">/2016/personal-project.html</guid><category><![CDATA[devmtn]]></category><category><![CDATA[electron]]></category><category><![CDATA[nwjs]]></category><category><![CDATA[markdown]]></category><category><![CDATA[angular]]></category><dc:creator><![CDATA[zac anger]]></dc:creator><pubDate>Fri, 20 May 2016 05:00:00 GMT</pubDate></item></channel></rss>